# Azure Key Vault CSI Secret Store Driver Integration
# This syncs certificates from Kubernetes secrets to Azure Key Vault
#
# Prerequisites:
# 1. Azure Key Vault: cloudtolocalllm-kv
# 2. Service Principal or Managed Identity with Key Vault access
# 3. Azure CSI Secret Store Driver installed in cluster
#
# Installation:
#   kubectl apply -f https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/deployment/secrets-store-csi-driver.yaml
#   Or use Helm: helm install csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver --namespace kube-system

---
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: azure-keyvault-certificates
  namespace: cloudtolocalllm
spec:
  provider: azure
  parameters:
    # Authentication method (choose one):
    # Option 1: Use Managed Identity (recommended for AKS)
    # useVMManagedIdentity: "true"
    # userAssignedIdentityID: "<USER_ASSIGNED_IDENTITY_ID>"  # From AKS managed identity
    
    # Option 2: Use Service Principal
    usePodIdentity: "false"
    useVMManagedIdentity: "false"
    clientId: "<AZURE_CLIENT_ID>"  # Replace with client ID from azure-dns-config secret
    clientSecret: "<AZURE_CLIENT_SECRET>"  # Replace with client secret from azure-dns-config secret
    
    keyvaultName: "cloudtolocalllm-kv"
    tenantId: "<AZURE_TENANT_ID>"  # Replace with tenant ID from azure-dns-config secret
    
    # Objects to sync from Key Vault to Kubernetes
    objects: |
      array:
        - |
          objectName: cloudtolocalllm-wildcard-tls
          objectType: secret
          objectVersion: ""
          objectEncoding: base64
    
    # Create Kubernetes secret from Key Vault secret
    secretObjects:
      - secretName: cloudtolocalllm-wildcard-tls
        type: kubernetes.io/tls
        data:
          - objectName: cloudtolocalllm-wildcard-tls
            key: tls.crt
          - objectName: cloudtolocalllm-wildcard-tls
            key: tls.key

---
# CronJob to sync certificates FROM Kubernetes secrets TO Azure Key Vault
# This runs periodically to keep Key Vault in sync with cert-manager-issued certificates
apiVersion: batch/v1
kind: CronJob
metadata:
  name: sync-cert-to-keyvault
  namespace: cloudtolocalllm
spec:
  # Run every 6 hours to sync certificates
  schedule: "0 */6 * * *"
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: cert-sync
        spec:
          serviceAccountName: cert-sync
          containers:
          - name: sync
            image: mcr.microsoft.com/azure-cli:latest
            command:
            - /bin/bash
            - -c
            - |
              set -e
              echo "üîÑ Syncing certificate from Kubernetes to Azure Key Vault..."
              
              NAMESPACE="cloudtolocalllm"
              SECRET_NAME="cloudtolocalllm-wildcard-tls"
              KEY_VAULT_NAME="cloudtolocalllm-kv"
              CERT_NAME="cloudtolocalllm-wildcard"
              
              # Check if secret exists
              if ! kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" &>/dev/null; then
                echo "‚ö†Ô∏è Secret $SECRET_NAME not found, skipping sync"
                exit 0
              fi
              
              # Get certificate from Kubernetes secret
              echo "üì• Retrieving certificate from Kubernetes secret..."
              kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" -o jsonpath='{.data.tls\.crt}' | base64 -d > /tmp/tls.crt
              kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" -o jsonpath='{.data.tls\.key}' | base64 -d > /tmp/tls.key
              
              # Check certificate expiry
              CERT_EXPIRY=$(openssl x509 -in /tmp/tls.crt -noout -enddate | cut -d= -f2)
              echo "üìÖ Certificate expires: $CERT_EXPIRY"
              
              # Create PFX file for Key Vault
              echo "üì¶ Creating PFX file..."
              openssl pkcs12 -export \
                -out /tmp/cert.pfx \
                -inkey /tmp/tls.key \
                -in /tmp/tls.crt \
                -name "$CERT_NAME" \
                -passout pass: \
                -nodes
              
              # Import to Azure Key Vault
              echo "‚òÅÔ∏è Importing to Azure Key Vault..."
              az keyvault certificate import \
                --vault-name "$KEY_VAULT_NAME" \
                --name "$CERT_NAME" \
                --file /tmp/tls.crt \
                --tags "Source=Kubernetes" "IssuedBy=cert-manager" "Namespace=$NAMESPACE" || \
              az keyvault secret set \
                --vault-name "$KEY_VAULT_NAME" \
                --name "$CERT_NAME" \
                --value "$(cat /tmp/tls.crt | base64)" \
                --tags "Source=Kubernetes" "IssuedBy=cert-manager" "Namespace=$NAMESPACE"
              
              echo "‚úÖ Certificate synced to Azure Key Vault: $KEY_VAULT_NAME/$CERT_NAME"
              
              # Cleanup
              rm -f /tmp/tls.crt /tmp/tls.key /tmp/cert.pfx
            env:
            - name: AZURE_CLIENT_ID
              valueFrom:
                secretKeyRef:
                  name: azure-keyvault-sync
                  key: client-id
            - name: AZURE_CLIENT_SECRET
              valueFrom:
                secretKeyRef:
                  name: azure-keyvault-sync
                  key: client-secret
            - name: AZURE_TENANT_ID
              valueFrom:
                secretKeyRef:
                  name: azure-keyvault-sync
                  key: tenant-id
          restartPolicy: OnFailure

---
# ServiceAccount for cert sync CronJob
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cert-sync
  namespace: cloudtolocalllm

---
# Secret for Azure credentials (can use managed identity instead)
apiVersion: v1
kind: Secret
metadata:
  name: azure-keyvault-sync
  namespace: cloudtolocalllm
type: Opaque
stringData:
  # IMPORTANT: Replace these with actual values from your Azure credentials
  # DO NOT commit actual secrets to git - use GitHub Secrets or environment variables
  # Get values from existing secret: kubectl get secret azure-dns-config -n cert-manager -o json
  # Or use the setup script: .\scripts\setup-azure-keyvault-cert-sync.ps1
  client-id: "<AZURE_CLIENT_ID>"
  client-secret: "<AZURE_CLIENT_SECRET>"
  tenant-id: "<AZURE_TENANT_ID>"

---
# RBAC for cert sync
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: cert-sync
  namespace: cloudtolocalllm
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: cert-sync
  namespace: cloudtolocalllm
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: cert-sync
subjects:
- kind: ServiceAccount
  name: cert-sync
  namespace: cloudtolocalllm


