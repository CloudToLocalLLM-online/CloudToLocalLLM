name: Version Analysis & Platform Distribution

on:
  push:
    branches:
      - main
  workflow_dispatch:

# Prevent multiple version bumps running simultaneously
concurrency:
  group: version-distribution
  cancel-in-progress: false

jobs:
  analyze_and_distribute:
    if: ${{ !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[no-version]') }}
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 50
          fetch-tags: true
          token: "${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}"

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Verify Current Version
        run: |
          chmod +x scripts/verify-version.sh
          ./scripts/verify-version.sh

      - name: Setup Gemini CLI
        env:
          GEMINI_API_KEY: "${{ secrets.GEMINI_API_KEY }}"
        run: |
          chmod +x scripts/gemini-cli.cjs
          sudo ln -sf "$(pwd)/scripts/gemini-cli.cjs" /usr/local/bin/gemini-cli

          gemini-cli "Respond with just OK" && echo "âœ… Gemini CLI test passed" || echo "âš ï¸  Gemini test failed"
          echo "âœ… Gemini CLI ready"

      - name: Install jq
        run: |
          if ! command -v jq &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          fi
          jq --version

      - name: Analyze Changes with Gemini
        id: analyze
        env:
          GEMINI_API_KEY: "${{ secrets.GEMINI_API_KEY }}"
        run: |
          chmod +x scripts/analyze-platforms.sh
          ./scripts/analyze-platforms.sh

      - name: Update Version Files
        env:
          NEW_VERSION: "${{ steps.analyze.outputs.new_version }}"
          COMMIT_SHA: "${{ github.sha }}"
          GEMINI_API_KEY: "${{ secrets.GEMINI_API_KEY }}"
        run: |
          chmod +x scripts/update-all-versions.sh
          ./scripts/update-all-versions.sh "$NEW_VERSION" "$COMMIT_SHA"

      - name: Commit and Push to Platform Branches
        env:
          NEW_VERSION: "${{ steps.analyze.outputs.new_version }}"
          NEEDS_CLOUD: "${{ steps.analyze.outputs.needs_cloud }}"
          NEEDS_DESKTOP: "${{ steps.analyze.outputs.needs_desktop }}"
          NEEDS_MOBILE: "${{ steps.analyze.outputs.needs_mobile }}"
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)

          # Commit version changes to main
          git add -A
          if ! git diff --cached --quiet; then
            git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
            git push origin main
          fi

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Platform Distribution for v$NEW_VERSION"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

           # Push to cloud branch
           echo "â˜ï¸  Pushing to cloud branch..."
           chmod +x scripts/push-to-cloud-branch.sh
           CLOUD_PUSH_PAT="${{ secrets.CLOUD_PUSH_PAT }}" ./scripts/push-to-cloud-branch.sh "$NEW_VERSION"


          # Trigger AKS deployment if cloud deployment is needed
          if [ "$NEEDS_CLOUD" = "true" ]; then
            echo "ğŸš€ Triggering AKS deployment for cloud branch..."
            curl -X POST \
              -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Content-Type: application/json" \
              https://api.github.com/repos/${{ github.repository }}/dispatches \
              -d "{\"event_type\":\"cloud-deploy-$NEW_VERSION\",\"client_payload\":{\"version\":\"$NEW_VERSION\",\"branch\":\"cloud\"}}"
            echo "âœ… AKS deployment triggered"
          fi

          # Push to desktop branch
          echo "ğŸ–¥ï¸  Pushing to desktop branch..."
          git checkout -B desktop main
          git push -f origin desktop
          git tag "${NEW_VERSION}-desktop-${SHORT_SHA}" -f
          git push origin "${NEW_VERSION}-desktop-${SHORT_SHA}" -f
          echo "âœ… Desktop: v${NEW_VERSION}-desktop-${SHORT_SHA}"

          # Push to mobile branch
          echo "ğŸ“± Pushing to mobile branch..."
          git checkout -B mobile main
          git push -f origin mobile
          git tag "${NEW_VERSION}-mobile-${SHORT_SHA}" -f
          git push origin "${NEW_VERSION}-mobile-${SHORT_SHA}" -f

          echo "âœ… Mobile: v${NEW_VERSION}-mobile-${SHORT_SHA}"

          # Return to main
          git checkout main

          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Version $NEW_VERSION distributed to platforms"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
