name: Version Analysis & Platform Distribution

on:
  push:
    branches:
      - main
    # Don't trigger on version bump commits or platform branch merges
  workflow_dispatch:

# Prevent multiple version bumps running simultaneously
concurrency:
  group: version-distribution
  cancel-in-progress: false

jobs:
  analyze_and_distribute:
    if: "!contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[no-version]')"
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 50
          fetch-tags: true
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
      
      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: Setup Gemini CLI
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          chmod +x scripts/gemini-cli.cjs
          sudo ln -sf "$(pwd)/scripts/gemini-cli.cjs" /usr/local/bin/gemini-cli
          if [ -n "$GEMINI_API_KEY" ]; then
            gemini-cli "Respond with just OK" && echo "âœ… Gemini CLI test passed" || echo "âš ï¸  Gemini test failed"
          fi
          echo "âœ… Gemini CLI ready"
      
      - name: Analyze Changes with Gemini
        id: analyze
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          chmod +x scripts/analyze-platforms.sh
          ./scripts/analyze-platforms.sh
      
      - name: Update Version Files
        env:
          NEW_VERSION: ${{ steps.analyze.outputs.new_version }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          chmod +x scripts/update-all-versions.sh
          ./scripts/update-all-versions.sh "$NEW_VERSION" "$COMMIT_SHA"
      
      - name: Commit and Push to Platform Branches
        env:
          NEW_VERSION: ${{ steps.analyze.outputs.new_version }}
          NEEDS_CLOUD: ${{ steps.analyze.outputs.needs_cloud }}
          NEEDS_DESKTOP: ${{ steps.analyze.outputs.needs_desktop }}
          NEEDS_MOBILE: ${{ steps.analyze.outputs.needs_mobile }}
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          
          # Commit version changes to main
          git add -A
          if ! git diff --cached --quiet; then
            git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
            git push origin main
          fi
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Platform Distribution for v$NEW_VERSION"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          # Push to cloud branch if needed
          if [ "$NEEDS_CLOUD" = "true" ]; then
            echo "â˜ï¸  Pushing to cloud branch..."
            git checkout -B cloud
            git push -f origin cloud
            git tag "${NEW_VERSION}-cloud-${SHORT_SHA}" -f
            git push origin "${NEW_VERSION}-cloud-${SHORT_SHA}" -f
            echo "âœ… Cloud: v${NEW_VERSION}-cloud-${SHORT_SHA}"
          else
            echo "â­ï¸  Cloud: No changes, skipping"
          fi
          
          # Push to desktop branch if needed
          if [ "$NEEDS_DESKTOP" = "true" ]; then
            echo "ğŸ–¥ï¸  Pushing to desktop branch..."
            git checkout -B desktop main
            git push -f origin desktop
            git tag "${NEW_VERSION}-desktop-${SHORT_SHA}" -f
            git push origin "${NEW_VERSION}-desktop-${SHORT_SHA}" -f
            echo "âœ… Desktop: v${NEW_VERSION}-desktop-${SHORT_SHA}"
          else
            echo "â­ï¸  Desktop: No changes, skipping"
          fi
          
          # Push to mobile branch if needed
          if [ "$NEEDS_MOBILE" = "true" ]; then
            echo "ğŸ“± Pushing to mobile branch..."
            git checkout -B mobile main
            git push -f origin mobile
            git tag "${NEW_VERSION}-mobile-${SHORT_SHA}" -f
            git push origin "${NEW_VERSION}-mobile-${SHORT_SHA}" -f
            echo "âœ… Mobile: v${NEW_VERSION}-mobile-${SHORT_SHA}"
          else
            echo "â­ï¸  Mobile: No changes, skipping"
          fi
          
          # Return to main
          git checkout main
          
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Version $NEW_VERSION distributed to platforms"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          # Trigger deployments via repository_dispatch (GitHub limitation workaround)
          # Note: Workflows cannot trigger other workflows even with PAT (security feature)
          if [ "$NEEDS_CLOUD" = "true" ]; then
            echo "Triggering cloud deployment..."
            curl -X POST \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/dispatches" \
              -d "{\"event_type\":\"cloud-deploy\",\"client_payload\":{\"version\":\"${NEW_VERSION}\",\"commit\":\"${SHORT_SHA}\"}}"
            echo "âœ… Cloud deployment triggered"
          fi

