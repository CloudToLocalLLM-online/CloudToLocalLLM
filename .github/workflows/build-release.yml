name: Build Desktop Apps & Create Release

on:
  push:
    branches: [main]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: true
        default: 'main'
        type: choice
        options:
          - main
          - release

concurrency:
  group: build-release-${{ github.ref }}
  cancel-in-progress: true

env:
  FLUTTER_VERSION: '3.24.0'

jobs:
  # Extract version information
  version-info:
    name: Extract Version Information
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      build_number: ${{ steps.version.outputs.build_number }}
      full_version: ${{ steps.version.outputs.full_version }}
      tag_name: ${{ steps.version.outputs.tag_name }}
      release_name: ${{ steps.version.outputs.release_name }}
      is_release: ${{ steps.version.outputs.is_release }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for version detection
        
    - name: Setup GitHub CLI
      run: |
        if ! command -v gh &> /dev/null; then
          echo "Installing GitHub CLI..."
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt update && sudo apt install gh -y
        fi
        echo "GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_ENV
      
    - name: Extract version and generate build number
      id: version
      run: |
        # Check if this is a tag push, workflow_dispatch with release, or main branch
        BUILD_TYPE="${{ github.event.inputs.build_type }}"
        
        if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          # Release build from tag
          TAG_REF="${GITHUB_REF_NAME:-${{ github.ref_name }}}"
          VERSION="${TAG_REF#v}"
          IS_RELEASE="true"
        elif [[ "$BUILD_TYPE" == "release" ]]; then
          # Manual release build via workflow_dispatch
          if [ -f pubspec.yaml ]; then
            VERSION=$(grep "^version:" pubspec.yaml | sed 's/version: //' | sed 's/+.*//')
          fi
          
          # Fallback if version not found
          if [ -z "$VERSION" ]; then
            SHORT_SHA=$(git rev-parse --short HEAD)
            VERSION="0.0.0-dev-$SHORT_SHA"
          fi
          IS_RELEASE="true"
        else
          # Main branch build - extract version from pubspec.yaml
          if [ -f pubspec.yaml ]; then
            VERSION=$(grep "^version:" pubspec.yaml | sed 's/version: //' | sed 's/+.*//')
          fi
          
          # Fallback to commit-based version if not found
          if [ -z "$VERSION" ]; then
            SHORT_SHA=$(git rev-parse --short HEAD)
            VERSION="0.0.0+dev-$SHORT_SHA"
            IS_RELEASE="false"
          else
            # Always create release for any version on main branch
            # Extract version from previous commit's pubspec.yaml if available
            PREV_PUBSPEC_VERSION=""
            if git show HEAD~1:pubspec.yaml 2>/dev/null | grep -q "^version:"; then
              PREV_PUBSPEC_VERSION=$(git show HEAD~1:pubspec.yaml 2>/dev/null | grep "^version:" | sed 's/version: //' | sed 's/+.*//' | tr -d ' ' || echo "")
            fi
            
            echo "Current version: $VERSION"
            echo "Previous version: $PREV_PUBSPEC_VERSION"
            
            # Always create release for main branch builds
            echo "Creating release for version $VERSION on main branch"
            IS_RELEASE="true"
          fi
        fi

        # Generate build number as YYYYMMDDHHMM (UTC)
        BUILD_NUMBER=$(date -u +%Y%m%d%H%M)

        # Full version: x.x.x+YYYYMMDDHHMM (or with commit SHA for dev builds)
        if [ "$IS_RELEASE" == "true" ]; then
          FULL_VERSION="$VERSION+$BUILD_NUMBER"
          TAG_NAME="v$VERSION"
          RELEASE_NAME="CloudToLocalLLM v$VERSION"
        else
          SHORT_SHA=$(git rev-parse --short HEAD)
          FULL_VERSION="$VERSION+$BUILD_NUMBER-$SHORT_SHA"
          TAG_NAME=""
          RELEASE_NAME="CloudToLocalLLM Dev Build $BUILD_NUMBER"
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
        echo "full_version=$FULL_VERSION" >> $GITHUB_OUTPUT
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
        echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

        echo "Version: $VERSION"
        echo "Build Number: $BUILD_NUMBER"
        echo "Full Version: $FULL_VERSION"
        echo "Is Release: $IS_RELEASE"
        if [ "$IS_RELEASE" == "true" ]; then
          echo "Tag: $TAG_NAME"
          echo "Release Name: $RELEASE_NAME"
        fi

  # Build desktop application for Windows
  build-desktop:
    name: Build Windows Desktop App
    runs-on: [self-hosted, windows]
    needs: version-info
    if: always() && needs.version-info.result == 'success'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Cache Flutter dependencies
      uses: actions/cache@v3
      with:
        path: |
          ${{ runner.temp }}\.pub-cache
          .dart_tool
        key: windows-flutter-${{ hashFiles('**/pubspec.lock') }}
        restore-keys: |
          windows-flutter-
        
    - name: Verify Windows build environment
      run: |
        Write-Host "Checking Windows build prerequisites..."
        flutter --version
        flutter config --enable-windows-desktop
        flutter doctor -v
      shell: powershell
      
    - name: Get Flutter dependencies
      run: flutter pub get
      shell: powershell
      
    - name: Build Windows desktop application
      run: flutter build windows --release
      shell: powershell
      
    - name: Verify Inno Setup
      run: |
        Write-Host "Checking for Inno Setup..."
        $innoSetupPaths = @(
          "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe",
          "${env:ProgramFiles}\Inno Setup 6\ISCC.exe",
          "${env:ProgramFiles(x86)}\Inno Setup 5\ISCC.exe",
          "${env:ProgramFiles}\Inno Setup 5\ISCC.exe"
        )
        
        $innoPath = $null
        foreach ($path in $innoSetupPaths) {
          if (Test-Path $path) {
            $innoPath = $path
            break
          }
        }
        
        if ($innoPath) {
          Write-Host "Inno Setup found at: $innoPath"
          echo "INNO_SETUP_PATH=$innoPath" >> $env:GITHUB_ENV
        } else {
          Write-Error "Inno Setup not found. The runner must have Inno Setup installed."
          Write-Host "Install via Chocolatey: choco install innosetup -y"
          Write-Host "Or download from: https://jrsoftware.org/isdl.php"
          exit 1
        }
      shell: powershell
      
    - name: Create Windows installer
      run: |
        $FULL_VERSION = "${{ needs.version-info.outputs.full_version }}"
        $VERSION = "${{ needs.version-info.outputs.version }}"
        $PACKAGE_PATH = "dist/windows"
        
        # Create dist directory
        New-Item -ItemType Directory -Force -Path $PACKAGE_PATH
        
        # Path to InnoSetup script
        $issFile = "build-tools\installers\windows\CloudToLocalLLM_Simple.iss"
        
        if (-not (Test-Path $issFile)) {
          throw "InnoSetup script not found at: $issFile"
        }
        
        # Compile installer
        Write-Host "Compiling Windows installer with Inno Setup..."
        # Escape the version for Inno Setup preprocessor (quote if contains special chars)
        $escapedVersion = $VERSION
        if ($escapedVersion -match '[^0-9.]') {
          $escapedVersion = "`"$escapedVersion`""
        }
        # Get absolute paths
        $projectRoot = (Get-Location).Path
        $buildSource = Join-Path $projectRoot "build\windows\x64\runner\Release"
        Write-Host "Project root: $projectRoot"
        Write-Host "Build source: $buildSource"
        
        $innoArgs = @(
          "`"$issFile`"",
          "/DMyAppVersion=$escapedVersion",
          "/DSourceDir=$projectRoot",
          "/DBuildDir=$buildSource",
          "/O`"$PACKAGE_PATH`""
        )
        
        $process = Start-Process -FilePath $env:INNO_SETUP_PATH -ArgumentList $innoArgs -Wait -PassThru -NoNewWindow
        
        if ($process.ExitCode -ne 0) {
          throw "Inno Setup compilation failed with exit code: $($process.ExitCode)"
        }
        
        # Find the created installer (output filename may vary)
        $installerPattern = "CloudToLocalLLM*Setup*.exe"
        $installer = Get-ChildItem -Path $PACKAGE_PATH -Filter $installerPattern -ErrorAction SilentlyContinue | Select-Object -First 1
        
        if ($installer) {
          Write-Host "Installer created: $($installer.FullName)"
          echo "INSTALLER_FILE=$($installer.FullName)" >> $env:GITHUB_ENV
          
          # Generate SHA256 checksum for installer
          $hash = Get-FileHash $installer.FullName -Algorithm SHA256
          $checksumFile = "$($installer.FullName).sha256"
          $hash.Hash + "  $($installer.Name)" | Out-File $checksumFile -Encoding ASCII
          echo "INSTALLER_CHECKSUM=$checksumFile" >> $env:GITHUB_ENV
        } else {
          throw "Installer file not found in $PACKAGE_PATH"
        }
      shell: powershell
      
    - name: Create portable package
      run: |
        $FULL_VERSION = "${{ needs.version-info.outputs.full_version }}"
        $PACKAGE_NAME = "cloudtolocalllm-$FULL_VERSION-portable"
        $PACKAGE_PATH = "dist/windows"

        # Copy build output
        Copy-Item -Recurse "build\windows\x64\runner\Release" "$PACKAGE_PATH/$PACKAGE_NAME"

        # Create ZIP archive
        Compress-Archive -Path "$PACKAGE_PATH/$PACKAGE_NAME" -DestinationPath "$PACKAGE_PATH/$PACKAGE_NAME.zip"

        # Generate SHA256 checksum
        $hash = Get-FileHash "$PACKAGE_PATH/$PACKAGE_NAME.zip" -Algorithm SHA256
        $hash.Hash + "  $PACKAGE_NAME.zip" | Out-File "$PACKAGE_PATH/$PACKAGE_NAME.zip.sha256" -Encoding ASCII

        echo "PACKAGE_FILE=$PACKAGE_PATH/$PACKAGE_NAME.zip" >> $env:GITHUB_ENV
        echo "CHECKSUM_FILE=$PACKAGE_PATH/$PACKAGE_NAME.zip.sha256" >> $env:GITHUB_ENV
      shell: powershell
      
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: windows-desktop
        path: |
          ${{ env.PACKAGE_FILE }}
          ${{ env.CHECKSUM_FILE }}
          ${{ env.INSTALLER_FILE }}
          ${{ env.INSTALLER_CHECKSUM }}
        retention-days: 30

  # Upload artifacts for main branch builds (no release)
  upload-artifacts:
    name: Upload Build Artifacts
    if: needs.version-info.outputs.is_release != 'true'
    runs-on: ubuntu-latest
    needs: [version-info, build-desktop]

    steps:
    - name: Download all build artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
        
    - name: Upload artifacts summary
      run: |
        echo "## ðŸ“¦ Build Artifacts Available" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Build Details:**" >> $GITHUB_STEP_SUMMARY
        echo "- **Version:** ${{ needs.version-info.outputs.full_version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Available Artifacts:**" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Installer (.exe)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Portable (ZIP)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Artifacts are available in the Actions workflow run for 30 days." >> $GITHUB_STEP_SUMMARY

  # Create GitHub release with all platform builds (only for tag pushes)
  create-release:
    name: Create GitHub Release
    if: needs.version-info.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    needs: [version-info, build-desktop]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
      
    - name: Download all build artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
        pattern: windows-desktop
        merge-multiple: true
        if-no-files-found: warn
        
    - name: Prepare release assets
      run: |
        mkdir -p release-assets
        
        # Copy all artifacts to release assets directory (Windows only)
        find artifacts/ -type f \( -name "*.exe" -o -name "*.zip" -o -name "*.sha256" \) -exec cp {} release-assets/ \;
        
        # List all assets
        echo "Release assets:"
        ls -la release-assets/
        
    - name: Generate release notes
      run: |
        VERSION="${{ needs.version-info.outputs.version }}"
        cat > release-notes.md << EOF
        # CloudToLocalLLM v$VERSION
        
        ## What's Changed
        - Version $VERSION release
        - Updated dependencies and bug fixes
        - Performance improvements
        
        ## Download
        Choose the appropriate package for Windows:
        
        - **CloudToLocalLLM-Windows-$VERSION-Setup.exe** - Windows installer (recommended)
        - **cloudtolocalllm-$VERSION-portable.zip** - Portable version (no installation required)
        
        ## Checksums
        SHA256 checksums are provided for all packages to verify integrity.
        
        **Full Changelog**: https://github.com/imrightguy/CloudToLocalLLM/compare/v${{ needs.version-info.outputs.version }}...v$VERSION
        EOF
        
    - name: Create git tag
      run: |
        VERSION="${{ needs.version-info.outputs.version }}"
        TAG_NAME="v$VERSION"
        
        # Configure git
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        
        # Check if tag already exists locally or remotely
        if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
          echo "Tag $TAG_NAME already exists locally, skipping tag creation"
        elif git ls-remote --tags origin "$TAG_NAME" | grep -q "$TAG_NAME"; then
          echo "Tag $TAG_NAME already exists on remote, skipping tag creation"
        else
          echo "Creating tag $TAG_NAME"
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME" || echo "Tag push failed (may already exist)"
        fi
      
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ needs.version-info.outputs.tag_name }}
        name: ${{ needs.version-info.outputs.release_name }}
        body_path: release-notes.md
        files: release-assets/*
        draft: false
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Create release summary
      run: |
        echo "## ðŸŽ‰ Desktop Release Created" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Release Details:**" >> $GITHUB_STEP_SUMMARY
        echo "- **Version:** ${{ needs.version-info.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Tag:** ${{ needs.version-info.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Available Platforms:**" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Installer (.exe)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Portable (ZIP)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Download:** [GitHub Releases](https://github.com/imrightguy/CloudToLocalLLM/releases/tag/${{ needs.version-info.outputs.tag_name }})" >> $GITHUB_STEP_SUMMARY