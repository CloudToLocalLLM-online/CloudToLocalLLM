name: Build Desktop Apps & Create Release

on:
  push:
    branches: [main]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: true
        default: 'main'
        type: choice
        options:
          - main
          - release

concurrency:
  group: build-release-${{ github.ref }}
  cancel-in-progress: true

env:
  FLUTTER_VERSION: '3.24.0'

jobs:
  # Extract version information
  version-info:
    name: Extract Version Information
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      build_number: ${{ steps.version.outputs.build_number }}
      full_version: ${{ steps.version.outputs.full_version }}
      tag_name: ${{ steps.version.outputs.tag_name }}
      release_name: ${{ steps.version.outputs.release_name }}
      is_release: ${{ steps.version.outputs.is_release }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for version detection
      
    - name: Extract version and generate build number
      id: version
      run: |
        # Check if this is a tag push or main branch
        if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          # Release build from tag
          TAG_REF="${GITHUB_REF_NAME:-${{ github.ref_name }}}"
          VERSION="${TAG_REF#v}"
          IS_RELEASE="true"
        else
          # Main branch build - extract version from pubspec.yaml or use commit-based version
          if [ -f pubspec.yaml ]; then
            VERSION=$(grep "^version:" pubspec.yaml | sed 's/version: //' | sed 's/+.*//')
          fi
          
          # Fallback to commit-based version if not found
          if [ -z "$VERSION" ]; then
            SHORT_SHA=$(git rev-parse --short HEAD)
            VERSION="0.0.0+dev-$SHORT_SHA"
          fi
          IS_RELEASE="false"
        fi

        # Generate build number as YYYYMMDDHHMM (UTC)
        BUILD_NUMBER=$(date -u +%Y%m%d%H%M)

        # Full version: x.x.x+YYYYMMDDHHMM (or with commit SHA for dev builds)
        if [ "$IS_RELEASE" == "true" ]; then
          FULL_VERSION="$VERSION+$BUILD_NUMBER"
          TAG_NAME="v$VERSION"
          RELEASE_NAME="CloudToLocalLLM v$VERSION"
        else
          SHORT_SHA=$(git rev-parse --short HEAD)
          FULL_VERSION="$VERSION+$BUILD_NUMBER-$SHORT_SHA"
          TAG_NAME=""
          RELEASE_NAME="CloudToLocalLLM Dev Build $BUILD_NUMBER"
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
        echo "full_version=$FULL_VERSION" >> $GITHUB_OUTPUT
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
        echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

        echo "Version: $VERSION"
        echo "Build Number: $BUILD_NUMBER"
        echo "Full Version: $FULL_VERSION"
        echo "Is Release: $IS_RELEASE"
        if [ "$IS_RELEASE" == "true" ]; then
          echo "Tag: $TAG_NAME"
          echo "Release Name: $RELEASE_NAME"
        fi

  # Build desktop applications for Windows and Linux
  build-desktop:
    name: Build Desktop Apps
    runs-on: ${{ matrix.runner }}
    needs: version-info
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: [self-hosted, windows]
            platform: windows
            artifact_name: windows-desktop
            build_command: flutter build windows --release
            package_path: build/windows/x64/runner/Release
            executable_name: cloudtolocalllm.exe
          - runner: [self-hosted, linux]
            platform: linux
            artifact_name: linux-desktop
            build_command: flutter build linux --release
            package_path: build/linux/x64/release/bundle
            executable_name: cloudtolocalllm
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Flutter on Windows
      if: matrix.platform == 'windows'
      run: |
        # Check if Flutter is already in PATH
        $flutterPath = Get-Command flutter -ErrorAction SilentlyContinue
        if ($flutterPath) {
          Write-Host "Flutter found in PATH: $($flutterPath.Source)"
          flutter --version
        } else {
          # Try common Flutter installation paths
          $flutterPaths = @(
            "$env:USERPROFILE\flutter",
            "$env:PROGRAMFILES\flutter",
            "C:\flutter",
            "C:\tools\flutter",
            "$env:LOCALAPPDATA\flutter"
          )
          
          $foundFlutter = $false
          foreach ($path in $flutterPaths) {
            $flutterBin = Join-Path $path "bin\flutter.bat"
            if (Test-Path $flutterBin) {
              Write-Host "Found Flutter at: $path"
              $env:PATH = "$path\bin;$env:PATH"
              [Environment]::SetEnvironmentVariable("PATH", "$path\bin;$env:PATH", "Process")
              flutter --version
              $foundFlutter = $true
              break
            }
          }
          
          if (-not $foundFlutter) {
            throw "Flutter not found. Please install Flutter on the Windows runner."
          }
        }
        
        # Verify Flutter version
        $flutterVersion = (flutter --version | Select-String -Pattern "Flutter (\d+\.\d+\.\d+)" | ForEach-Object { $_.Matches.Groups[1].Value })
        Write-Host "Installed Flutter version: $flutterVersion"
        
        # Verify Windows desktop support is enabled
        flutter config --enable-windows-desktop
      shell: powershell
      
    - name: Cache Flutter dependencies
      if: matrix.platform == 'windows'
      uses: actions/cache@v3
      with:
        path: |
          ${{ runner.temp }}\.pub-cache
          .dart_tool
        key: windows-flutter-${{ hashFiles('**/pubspec.lock') }}
        restore-keys: |
          windows-flutter-
        
    - name: Verify Windows build environment
      if: matrix.platform == 'windows'
      run: |
        Write-Host "Checking Windows build prerequisites..."
        flutter doctor -v
      shell: powershell
        
    - name: Setup Flutter on Linux
      if: matrix.platform == 'linux'
      run: |
        # Check if Flutter is already in PATH
        if command -v flutter &> /dev/null; then
          echo "Flutter found in PATH"
          flutter --version
        else
          # Try common Flutter installation paths
          FLUTTER_PATHS=(
            "$HOME/flutter"
            "/opt/flutter"
            "$HOME/.local/flutter"
          )
          
          FOUND_FLUTTER=false
          for path in "${FLUTTER_PATHS[@]}"; do
            if [ -f "$path/bin/flutter" ]; then
              echo "Found Flutter at: $path"
              export PATH="$path/bin:$PATH"
              flutter --version
              FOUND_FLUTTER=true
              break
            fi
          done
          
          if [ "$FOUND_FLUTTER" = false ]; then
            echo "ERROR: Flutter not found. Please install Flutter on the Linux runner."
            exit 1
          fi
        fi
        
        # Verify Flutter version
        FLUTTER_VERSION=$(flutter --version | grep -oP 'Flutter \K[\d.]+' | head -1)
        echo "Installed Flutter version: $FLUTTER_VERSION"
        
        # Verify Linux desktop support is enabled
        flutter config --enable-linux-desktop
        
    - name: Cache Flutter dependencies (Linux)
      if: matrix.platform == 'linux'
      uses: actions/cache@v3
      with:
        path: |
          ~/.pub-cache
          .dart_tool
        key: linux-flutter-${{ hashFiles('**/pubspec.lock') }}
        restore-keys: |
          linux-flutter-
          
    - name: Verify Linux build environment
      if: matrix.platform == 'linux'
      run: |
        echo "Checking Linux build prerequisites..."
        flutter doctor -v
        
    - name: Get Flutter dependencies
      run: flutter pub get
      
    - name: Enable desktop platform
      run: |
        flutter config --enable-${{ matrix.platform }}-desktop
        
    - name: Build desktop application
      run: ${{ matrix.build_command }}
      
    - name: Install Inno Setup
      if: matrix.platform == 'windows'
      run: |
        $innoSetupPaths = @(
          "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe",
          "${env:ProgramFiles}\Inno Setup 6\ISCC.exe",
          "${env:ProgramFiles(x86)}\Inno Setup 5\ISCC.exe",
          "${env:ProgramFiles}\Inno Setup 5\ISCC.exe"
        )
        
        $innoPath = $null
        foreach ($path in $innoSetupPaths) {
          if (Test-Path $path) {
            $innoPath = $path
            break
          }
        }
        
        if (-not $innoPath) {
          Write-Host "Inno Setup not found. Installing..."
          $downloadUrl = "https://jrsoftware.org/download.php/is.exe"
          $tempFile = Join-Path $env:TEMP "innosetup.exe"
          
          Invoke-WebRequest -Uri $downloadUrl -OutFile $tempFile -UseBasicParsing
          Start-Process -FilePath $tempFile -ArgumentList "/SILENT" -Wait
          Remove-Item $tempFile -Force -ErrorAction SilentlyContinue
          
          # Check again after installation
          foreach ($path in $innoSetupPaths) {
            if (Test-Path $path) {
              $innoPath = $path
              break
            }
          }
        }
        
        if ($innoPath) {
          Write-Host "Inno Setup found at: $innoPath"
          echo "INNO_SETUP_PATH=$innoPath" >> $env:GITHUB_ENV
        } else {
          throw "Failed to install or locate Inno Setup"
        }
      shell: powershell
      
    - name: Create Windows installer
      if: matrix.platform == 'windows'
      run: |
        $FULL_VERSION = "${{ needs.version-info.outputs.full_version }}"
        $VERSION = "${{ needs.version-info.outputs.version }}"
        $PACKAGE_PATH = "dist/windows"
        
        # Create dist directory
        New-Item -ItemType Directory -Force -Path $PACKAGE_PATH
        
        # Path to InnoSetup script
        $issFile = "build-tools\installers\windows\CloudToLocalLLM_Simple.iss"
        
        if (-not (Test-Path $issFile)) {
          throw "InnoSetup script not found at: $issFile"
        }
        
        # Compile installer
        Write-Host "Compiling Windows installer with Inno Setup..."
        $innoArgs = @(
          "`"$issFile`"",
          "/DMyAppVersion=$VERSION",
          "/O`"$PACKAGE_PATH`""
        )
        
        $process = Start-Process -FilePath $env:INNO_SETUP_PATH -ArgumentList $innoArgs -Wait -PassThru -NoNewWindow
        
        if ($process.ExitCode -ne 0) {
          throw "Inno Setup compilation failed with exit code: $($process.ExitCode)"
        }
        
        # Find the created installer (output filename may vary)
        $installerPattern = "CloudToLocalLLM*Setup*.exe"
        $installer = Get-ChildItem -Path $PACKAGE_PATH -Filter $installerPattern -ErrorAction SilentlyContinue | Select-Object -First 1
        
        if ($installer) {
          Write-Host "Installer created: $($installer.FullName)"
          echo "INSTALLER_FILE=$($installer.FullName)" >> $env:GITHUB_ENV
          
          # Generate SHA256 checksum for installer
          $hash = Get-FileHash $installer.FullName -Algorithm SHA256
          $checksumFile = "$($installer.FullName).sha256"
          $hash.Hash + "  $($installer.Name)" | Out-File $checksumFile -Encoding ASCII
          echo "INSTALLER_CHECKSUM=$checksumFile" >> $env:GITHUB_ENV
        } else {
          throw "Installer file not found in $PACKAGE_PATH"
        }
      shell: powershell
      
    - name: Create portable package (Windows)
      if: matrix.platform == 'windows'
      run: |
        $FULL_VERSION = "${{ needs.version-info.outputs.full_version }}"
        $PACKAGE_NAME = "cloudtolocalllm-$FULL_VERSION-portable"
        $PACKAGE_PATH = "dist/windows"

        # Copy build output
        Copy-Item -Recurse "${{ matrix.package_path }}" "$PACKAGE_PATH/$PACKAGE_NAME"

        # Create ZIP archive
        Compress-Archive -Path "$PACKAGE_PATH/$PACKAGE_NAME" -DestinationPath "$PACKAGE_PATH/$PACKAGE_NAME.zip"

        # Generate SHA256 checksum
        $hash = Get-FileHash "$PACKAGE_PATH/$PACKAGE_NAME.zip" -Algorithm SHA256
        $hash.Hash + "  $PACKAGE_NAME.zip" | Out-File "$PACKAGE_PATH/$PACKAGE_NAME.zip.sha256" -Encoding ASCII

        echo "PACKAGE_FILE=$PACKAGE_PATH/$PACKAGE_NAME.zip" >> $env:GITHUB_ENV
        echo "CHECKSUM_FILE=$PACKAGE_PATH/$PACKAGE_NAME.zip.sha256" >> $env:GITHUB_ENV
      shell: powershell
      
    - name: Install RPM build tools
      if: matrix.platform == 'linux'
      run: |
        # Detect distribution
        if [ -f /etc/os-release ]; then
          . /etc/os-release
          DISTRO=$ID
        else
          DISTRO="unknown"
        fi
        
        # Install RPM build tools based on distribution
        if [[ "$DISTRO" == "fedora" ]] || [[ "$DISTRO" == "rhel" ]] || [[ "$DISTRO" == "centos" ]]; then
          sudo dnf install -y rpm-build rpmdevtools rpmlint
        elif [[ "$DISTRO" == "opensuse-leap" ]] || [[ "$DISTRO" == "opensuse-tumbleweed" ]] || [[ "$DISTRO" == "sles" ]]; then
          sudo zypper install -y rpm-build rpmdevtools rpmlint
        else
          # Try to install with generic package manager
          if command -v dnf &> /dev/null; then
            sudo dnf install -y rpm-build rpmdevtools || true
          elif command -v yum &> /dev/null; then
            sudo yum install -y rpm-build rpmdevtools || true
          elif command -v zypper &> /dev/null; then
            sudo zypper install -y rpm-build rpmdevtools || true
          else
            echo "WARNING: Could not determine package manager for RPM build tools"
          fi
        fi
        
    - name: Setup RPM build environment
      if: matrix.platform == 'linux'
      run: |
        # Setup RPM build directories
        mkdir -p ~/rpmbuild/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}
        
    - name: Create Linux package
      if: matrix.platform == 'linux'
      run: |
        VERSION="${{ needs.version-info.outputs.version }}"
        FULL_VERSION="${{ needs.version-info.outputs.full_version }}"
        PACKAGE_NAME="cloudtolocalllm-${VERSION}-linux"
        PACKAGE_PATH="dist/linux"
        
        # Create dist directory
        mkdir -p "$PACKAGE_PATH"
        
        # Copy build output
        cp -R "${{ matrix.package_path }}" "$PACKAGE_PATH/$PACKAGE_NAME"
        
        # Create tar.gz archive
        cd "$PACKAGE_PATH"
        tar -czf "$PACKAGE_NAME.tar.gz" "$PACKAGE_NAME"
        
        # Generate SHA256 checksum
        sha256sum "$PACKAGE_NAME.tar.gz" > "$PACKAGE_NAME.tar.gz.sha256"
        
        echo "PACKAGE_FILE=$PACKAGE_PATH/$PACKAGE_NAME.tar.gz" >> $GITHUB_ENV
        echo "CHECKSUM_FILE=$PACKAGE_PATH/$PACKAGE_NAME.tar.gz.sha256" >> $GITHUB_ENV
        
    - name: Build RPM packages
      if: matrix.platform == 'linux'
      run: |
        VERSION="${{ needs.version-info.outputs.version }}"
        PACKAGE_PATH="dist/linux"
        
        # Detect distribution for RPM naming
        if [ -f /etc/os-release ]; then
          . /etc/os-release
          DISTRO=$ID
          DISTRO_VERSION=$VERSION_ID || $VERSION
        else
          DISTRO="linux"
          DISTRO_VERSION=""
        fi
        
        # Copy source tarball to RPM SOURCES
        cp "$PACKAGE_PATH/cloudtolocalllm-${VERSION}-linux.tar.gz" ~/rpmbuild/SOURCES/
        
        # Copy and customize spec file
        SPEC_FILE="build-tools/packaging/rpm/cloudtolocalllm.spec"
        if [ -f "$SPEC_FILE" ]; then
          # Replace version in spec file
          sed "s/%{version}/${VERSION}/g" "$SPEC_FILE" > ~/rpmbuild/SPECS/cloudtolocalllm.spec
          
          # Determine dist tag based on distribution
          if [[ "$DISTRO" == "fedora" ]]; then
            DIST_TAG=".fc${DISTRO_VERSION:-39}"
          elif [[ "$DISTRO" == "opensuse-leap" ]] || [[ "$DISTRO" == "opensuse-tumbleweed" ]]; then
            DIST_TAG=".suse${DISTRO_VERSION:-15}"
          else
            DIST_TAG=""
          fi
          
          # Build RPM for Fedora-style (uses .fc tag)
          echo "Building RPM package..."
          rpmbuild -ba --define "_topdir $(pwd)/rpmbuild" \
            --define "dist ${DIST_TAG}" \
            ~/rpmbuild/SPECS/cloudtolocalllm.spec
          
          # Copy built RPMs to dist directory
          mkdir -p "$PACKAGE_PATH/rpm"
          
          # Find and copy RPM files
          find ~/rpmbuild/RPMS -name "*.rpm" -exec cp {} "$PACKAGE_PATH/rpm/" \;
          
          # Rename RPMs to include distribution name
          for rpm_file in "$PACKAGE_PATH/rpm"/*.rpm; do
            if [ -f "$rpm_file" ]; then
              filename=$(basename "$rpm_file")
              if [[ "$DISTRO" == "fedora" ]]; then
                new_name=$(echo "$filename" | sed "s/${DIST_TAG}/.fc${DISTRO_VERSION:-39}/")
              elif [[ "$DISTRO" == "opensuse-leap" ]] || [[ "$DISTRO" == "opensuse-tumbleweed" ]]; then
                new_name=$(echo "$filename" | sed "s/${DIST_TAG}/.suse${DISTRO_VERSION:-15}/")
              else
                new_name="$filename"
              fi
              if [ "$filename" != "$new_name" ]; then
                mv "$rpm_file" "$PACKAGE_PATH/rpm/$new_name"
              fi
            fi
          done
          
          # Generate checksums for RPMs
          cd "$PACKAGE_PATH/rpm"
          for rpm_file in *.rpm; do
            if [ -f "$rpm_file" ]; then
              sha256sum "$rpm_file" > "${rpm_file}.sha256"
            fi
          done
          
          # Set environment variables for RPM files
          RPM_FILES=$(ls "$PACKAGE_PATH/rpm"/*.rpm 2>/dev/null | tr '\n' ' ' || echo "")
          RPM_CHECKSUMS=$(ls "$PACKAGE_PATH/rpm"/*.sha256 2>/dev/null | tr '\n' ' ' || echo "")
          
          echo "RPM_FILES=${RPM_FILES}" >> $GITHUB_ENV
          echo "RPM_CHECKSUMS=${RPM_CHECKSUMS}" >> $GITHUB_ENV
          
          echo "RPM packages built successfully"
          ls -lh "$PACKAGE_PATH/rpm/"
        else
          echo "WARNING: RPM spec file not found at $SPEC_FILE, skipping RPM build"
        fi
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact_name }}
        path: |
          ${{ env.PACKAGE_FILE }}
          ${{ env.CHECKSUM_FILE }}
          ${{ env.INSTALLER_FILE }}
          ${{ env.INSTALLER_CHECKSUM }}
          ${{ env.RPM_FILES }}
          ${{ env.RPM_CHECKSUMS }}
        retention-days: 30

  # Upload artifacts for main branch builds (no release)
  upload-artifacts:
    name: Upload Build Artifacts
    if: needs.version-info.outputs.is_release != 'true'
    runs-on: ubuntu-latest
    needs: [version-info, build-desktop]

    steps:
    - name: Download all build artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
        
    - name: Upload artifacts summary
      run: |
        echo "## ðŸ“¦ Build Artifacts Available" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Build Details:**" >> $GITHUB_STEP_SUMMARY
        echo "- **Version:** ${{ needs.version-info.outputs.full_version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Available Artifacts:**" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Installer (.exe)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Portable (ZIP)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Linux (Tar.gz Archive)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Artifacts are available in the Actions workflow run for 30 days." >> $GITHUB_STEP_SUMMARY

  # Create GitHub release with all platform builds (only for tag pushes)
  create-release:
    name: Create GitHub Release
    if: needs.version-info.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    needs: [version-info, build-desktop]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download all build artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
        
    - name: Prepare release assets
      run: |
        mkdir -p release-assets
        
        # Copy all artifacts to release assets directory
        find artifacts/ -type f \( -name "*.zip" -o -name "*.tar.gz" -o -name "*.sha256" \) -exec cp {} release-assets/ \;
        
        # List all assets
        echo "Release assets:"
        ls -la release-assets/
        
    - name: Generate release notes
      run: |
        VERSION="${{ needs.version-info.outputs.version }}"
        cat > release-notes.md << EOF
        # CloudToLocalLLM v$VERSION
        
        ## What's Changed
        - Version $VERSION release
        - Updated dependencies and bug fixes
        - Performance improvements
        
        ## Download
        Choose the appropriate package for your system:
        
        ### Windows
        - **CloudToLocalLLM-Windows-$VERSION-Setup.exe** - Windows installer (recommended)
        - **cloudtolocalllm-$VERSION-portable.zip** - Portable version (no installation required)
        
        ### Linux
        - **cloudtolocalllm-$VERSION-linux.tar.gz** - Linux application bundle
        - **cloudtolocalllm-$VERSION-*.rpm** - RPM packages for Fedora and openSUSE
        
        ## Checksums
        SHA256 checksums are provided for all packages to verify integrity.
        
        **Full Changelog**: https://github.com/imrightguy/CloudToLocalLLM/compare/v${{ needs.version-info.outputs.version }}...v$VERSION
        EOF
        
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ needs.version-info.outputs.tag_name }}
        name: ${{ needs.version-info.outputs.release_name }}
        body_path: release-notes.md
        files: release-assets/*
        draft: false
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Create release summary
      run: |
        echo "## ðŸŽ‰ Desktop Release Created" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Release Details:**" >> $GITHUB_STEP_SUMMARY
        echo "- **Version:** ${{ needs.version-info.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Tag:** ${{ needs.version-info.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Available Platforms:**" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Installer (.exe)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Portable (ZIP)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Linux (Tar.gz Archive)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Download:** [GitHub Releases](https://github.com/imrightguy/CloudToLocalLLM/releases/tag/${{ needs.version-info.outputs.tag_name }})" >> $GITHUB_STEP_SUMMARY