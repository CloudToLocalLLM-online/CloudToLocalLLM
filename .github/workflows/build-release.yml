name: Build Desktop Apps & Create Release

on:
  push:
    branches: [main]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: true
        default: 'main'
        type: choice
        options:
          - main
          - release

concurrency:
  group: build-release-${{ github.ref }}
  cancel-in-progress: true

env:
  FLUTTER_VERSION: '3.24.0'

jobs:
  # Extract version information
  version-info:
    name: Extract Version Information
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      build_number: ${{ steps.version.outputs.build_number }}
      full_version: ${{ steps.version.outputs.full_version }}
      tag_name: ${{ steps.version.outputs.tag_name }}
      release_name: ${{ steps.version.outputs.release_name }}
      is_release: ${{ steps.version.outputs.is_release }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for version detection
      
    - name: Extract version and generate build number
      id: version
      run: |
        # Check if this is a tag push or main branch
        if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          # Release build from tag
          TAG_REF="${GITHUB_REF_NAME:-${{ github.ref_name }}}"
          VERSION="${TAG_REF#v}"
          IS_RELEASE="true"
        else
          # Main branch build - extract version from pubspec.yaml or use commit-based version
          if [ -f pubspec.yaml ]; then
            VERSION=$(grep "^version:" pubspec.yaml | sed 's/version: //' | sed 's/+.*//')
          fi
          
          # Fallback to commit-based version if not found
          if [ -z "$VERSION" ]; then
            SHORT_SHA=$(git rev-parse --short HEAD)
            VERSION="0.0.0+dev-$SHORT_SHA"
          fi
          IS_RELEASE="false"
        fi

        # Generate build number as YYYYMMDDHHMM (UTC)
        BUILD_NUMBER=$(date -u +%Y%m%d%H%M)

        # Full version: x.x.x+YYYYMMDDHHMM (or with commit SHA for dev builds)
        if [ "$IS_RELEASE" == "true" ]; then
          FULL_VERSION="$VERSION+$BUILD_NUMBER"
          TAG_NAME="v$VERSION"
          RELEASE_NAME="CloudToLocalLLM v$VERSION"
        else
          SHORT_SHA=$(git rev-parse --short HEAD)
          FULL_VERSION="$VERSION+$BUILD_NUMBER-$SHORT_SHA"
          TAG_NAME=""
          RELEASE_NAME="CloudToLocalLLM Dev Build $BUILD_NUMBER"
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
        echo "full_version=$FULL_VERSION" >> $GITHUB_OUTPUT
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
        echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

        echo "Version: $VERSION"
        echo "Build Number: $BUILD_NUMBER"
        echo "Full Version: $FULL_VERSION"
        echo "Is Release: $IS_RELEASE"
        if [ "$IS_RELEASE" == "true" ]; then
          echo "Tag: $TAG_NAME"
          echo "Release Name: $RELEASE_NAME"
        fi

  # Build desktop applications for Windows only
  build-desktop:
    name: Build Windows Desktop App
    runs-on: [self-hosted, windows]
    needs: version-info
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: windows
            artifact_name: windows-desktop
            build_command: flutter build windows --release
            package_path: build/windows/x64/runner/Release
            executable_name: cloudtolocalllm.exe
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: ${{ env.FLUTTER_VERSION }}
        channel: 'stable'

    - name: Cache Flutter dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.pub-cache
          .dart_tool
        key: ${{ runner.os }}-flutter-${{ hashFiles('**/pubspec.lock') }}
        restore-keys: |
          ${{ runner.os }}-flutter-
        
    - name: Verify Windows build environment
      run: |
        echo "Checking Windows build prerequisites..."
        flutter doctor -v
        
    - name: Get Flutter dependencies
      run: flutter pub get
      
    - name: Enable desktop platform
      run: |
        flutter config --enable-${{ matrix.platform }}-desktop
        
    - name: Build desktop application
      run: ${{ matrix.build_command }}
      
    - name: Install Inno Setup
      if: matrix.platform == 'windows'
      run: |
        $innoSetupPaths = @(
          "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe",
          "${env:ProgramFiles}\Inno Setup 6\ISCC.exe",
          "${env:ProgramFiles(x86)}\Inno Setup 5\ISCC.exe",
          "${env:ProgramFiles}\Inno Setup 5\ISCC.exe"
        )
        
        $innoPath = $null
        foreach ($path in $innoSetupPaths) {
          if (Test-Path $path) {
            $innoPath = $path
            break
          }
        }
        
        if (-not $innoPath) {
          Write-Host "Inno Setup not found. Installing..."
          $downloadUrl = "https://jrsoftware.org/download.php/is.exe"
          $tempFile = Join-Path $env:TEMP "innosetup.exe"
          
          Invoke-WebRequest -Uri $downloadUrl -OutFile $tempFile -UseBasicParsing
          Start-Process -FilePath $tempFile -ArgumentList "/SILENT" -Wait
          Remove-Item $tempFile -Force -ErrorAction SilentlyContinue
          
          # Check again after installation
          foreach ($path in $innoSetupPaths) {
            if (Test-Path $path) {
              $innoPath = $path
              break
            }
          }
        }
        
        if ($innoPath) {
          Write-Host "Inno Setup found at: $innoPath"
          echo "INNO_SETUP_PATH=$innoPath" >> $env:GITHUB_ENV
        } else {
          throw "Failed to install or locate Inno Setup"
        }
      shell: powershell
      
    - name: Create Windows installer
      if: matrix.platform == 'windows'
      run: |
        $FULL_VERSION = "${{ needs.version-info.outputs.full_version }}"
        $VERSION = "${{ needs.version-info.outputs.version }}"
        $PACKAGE_PATH = "dist/windows"
        
        # Create dist directory
        New-Item -ItemType Directory -Force -Path $PACKAGE_PATH
        
        # Path to InnoSetup script
        $issFile = "build-tools\installers\windows\CloudToLocalLLM_Simple.iss"
        
        if (-not (Test-Path $issFile)) {
          throw "InnoSetup script not found at: $issFile"
        }
        
        # Compile installer
        Write-Host "Compiling Windows installer with Inno Setup..."
        $innoArgs = @(
          "`"$issFile`"",
          "/DMyAppVersion=$VERSION",
          "/O`"$PACKAGE_PATH`""
        )
        
        $process = Start-Process -FilePath $env:INNO_SETUP_PATH -ArgumentList $innoArgs -Wait -PassThru -NoNewWindow
        
        if ($process.ExitCode -ne 0) {
          throw "Inno Setup compilation failed with exit code: $($process.ExitCode)"
        }
        
        # Find the created installer (output filename may vary)
        $installerPattern = "CloudToLocalLLM*Setup*.exe"
        $installer = Get-ChildItem -Path $PACKAGE_PATH -Filter $installerPattern -ErrorAction SilentlyContinue | Select-Object -First 1
        
        if ($installer) {
          Write-Host "Installer created: $($installer.FullName)"
          echo "INSTALLER_FILE=$($installer.FullName)" >> $env:GITHUB_ENV
          
          # Generate SHA256 checksum for installer
          $hash = Get-FileHash $installer.FullName -Algorithm SHA256
          $checksumFile = "$($installer.FullName).sha256"
          $hash.Hash + "  $($installer.Name)" | Out-File $checksumFile -Encoding ASCII
          echo "INSTALLER_CHECKSUM=$checksumFile" >> $env:GITHUB_ENV
        } else {
          throw "Installer file not found in $PACKAGE_PATH"
        }
      shell: powershell
      
    - name: Create portable package (Windows)
      if: matrix.platform == 'windows'
      run: |
        $FULL_VERSION = "${{ needs.version-info.outputs.full_version }}"
        $PACKAGE_NAME = "cloudtolocalllm-$FULL_VERSION-portable"
        $PACKAGE_PATH = "dist/windows"

        # Copy build output
        Copy-Item -Recurse "${{ matrix.package_path }}" "$PACKAGE_PATH/$PACKAGE_NAME"

        # Create ZIP archive
        Compress-Archive -Path "$PACKAGE_PATH/$PACKAGE_NAME" -DestinationPath "$PACKAGE_PATH/$PACKAGE_NAME.zip"

        # Generate SHA256 checksum
        $hash = Get-FileHash "$PACKAGE_PATH/$PACKAGE_NAME.zip" -Algorithm SHA256
        $hash.Hash + "  $PACKAGE_NAME.zip" | Out-File "$PACKAGE_PATH/$PACKAGE_NAME.zip.sha256" -Encoding ASCII

        echo "PACKAGE_FILE=$PACKAGE_PATH/$PACKAGE_NAME.zip" >> $env:GITHUB_ENV
        echo "CHECKSUM_FILE=$PACKAGE_PATH/$PACKAGE_NAME.zip.sha256" >> $env:GITHUB_ENV
      shell: powershell
      
    - name: Create portable package (macOS)
      if: matrix.platform == 'macos'
      run: |
        FULL_VERSION="${{ needs.version-info.outputs.full_version }}"
        PACKAGE_NAME="cloudtolocalllm-$FULL_VERSION-macos"
        PACKAGE_PATH="dist/macos"

        # Create dist directory
        mkdir -p "$PACKAGE_PATH"

        # Create DMG (simplified - copy app bundle for now)
        cp -R "${{ matrix.package_path }}/${{ matrix.executable_name }}" "$PACKAGE_PATH/"

        # Create ZIP archive
        cd "$PACKAGE_PATH"
        zip -r "$PACKAGE_NAME.zip" "${{ matrix.executable_name }}"

        # Generate SHA256 checksum
        shasum -a 256 "$PACKAGE_NAME.zip" > "$PACKAGE_NAME.zip.sha256"

        echo "PACKAGE_FILE=$PACKAGE_PATH/$PACKAGE_NAME.zip" >> $GITHUB_ENV
        echo "CHECKSUM_FILE=$PACKAGE_PATH/$PACKAGE_NAME.zip.sha256" >> $GITHUB_ENV
        
    - name: Create portable package (Linux)
      if: matrix.platform == 'linux'
      run: |
        VERSION="${{ needs.version-info.outputs.version }}"
        PACKAGE_NAME="cloudtolocalllm-$VERSION-linux"
        PACKAGE_PATH="dist/linux"
        
        # Create dist directory
        mkdir -p "$PACKAGE_PATH"
        
        # Copy build output
        cp -R "${{ matrix.package_path }}" "$PACKAGE_PATH/$PACKAGE_NAME"
        
        # Create tar.gz archive
        cd "$PACKAGE_PATH"
        tar -czf "$PACKAGE_NAME.tar.gz" "$PACKAGE_NAME"
        
        # Generate SHA256 checksum
        sha256sum "$PACKAGE_NAME.tar.gz" > "$PACKAGE_NAME.tar.gz.sha256"
        
        echo "PACKAGE_FILE=$PACKAGE_PATH/$PACKAGE_NAME.tar.gz" >> $GITHUB_ENV
        echo "CHECKSUM_FILE=$PACKAGE_PATH/$PACKAGE_NAME.tar.gz.sha256" >> $GITHUB_ENV
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact_name }}
        path: |
          ${{ env.PACKAGE_FILE }}
          ${{ env.CHECKSUM_FILE }}
          ${{ env.INSTALLER_FILE }}
          ${{ env.INSTALLER_CHECKSUM }}
        retention-days: 30

  # Upload artifacts for main branch builds (no release)
  upload-artifacts:
    name: Upload Build Artifacts
    if: needs.version-info.outputs.is_release != 'true'
    runs-on: ubuntu-latest
    needs: [version-info, build-desktop]

    steps:
    - name: Download all build artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
        
    - name: Upload artifacts summary
      run: |
        echo "## ðŸ“¦ Build Artifacts Available" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Build Details:**" >> $GITHUB_STEP_SUMMARY
        echo "- **Version:** ${{ needs.version-info.outputs.full_version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Available Artifacts:**" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Installer (.exe)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Portable (ZIP)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Artifacts are available in the Actions workflow run for 30 days." >> $GITHUB_STEP_SUMMARY

  # Create GitHub release with all platform builds (only for tag pushes)
  create-release:
    name: Create GitHub Release
    if: needs.version-info.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    needs: [version-info, build-desktop]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download all build artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
        
    - name: Prepare release assets
      run: |
        mkdir -p release-assets
        
        # Copy all artifacts to release assets directory
        find artifacts/ -type f \( -name "*.zip" -o -name "*.tar.gz" -o -name "*.sha256" \) -exec cp {} release-assets/ \;
        
        # List all assets
        echo "Release assets:"
        ls -la release-assets/
        
    - name: Generate release notes
      run: |
        VERSION="${{ needs.version-info.outputs.version }}"
        cat > release-notes.md << EOF
        # CloudToLocalLLM v$VERSION
        
        ## What's Changed
        - Version $VERSION release
        - Updated dependencies and bug fixes
        - Performance improvements
        
        ## Download
        Choose the appropriate package for your system:
        
        ### Windows
        - **CloudToLocalLLM-Windows-$VERSION-Setup.exe** - Windows installer (recommended)
        - **cloudtolocalllm-$VERSION-portable.zip** - Portable version (no installation required)
        
        ## Checksums
        SHA256 checksums are provided for all packages to verify integrity.
        
        **Full Changelog**: https://github.com/imrightguy/CloudToLocalLLM/compare/v${{ needs.version-info.outputs.version }}...v$VERSION
        EOF
        
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ needs.version-info.outputs.tag_name }}
        name: ${{ needs.version-info.outputs.release_name }}
        body_path: release-notes.md
        files: release-assets/*
        draft: false
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Create release summary
      run: |
        echo "## ðŸŽ‰ Desktop Release Created" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Release Details:**" >> $GITHUB_STEP_SUMMARY
        echo "- **Version:** ${{ needs.version-info.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Tag:** ${{ needs.version-info.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Available Platforms:**" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Installer (.exe)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Portable (ZIP)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Download:** [GitHub Releases](https://github.com/imrightguy/CloudToLocalLLM/releases/tag/${{ needs.version-info.outputs.tag_name }})" >> $GITHUB_STEP_SUMMARY