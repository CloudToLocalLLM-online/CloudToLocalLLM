name: Build Desktop Apps & Create Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: true
        default: 'release'
        type: choice
        options:
          - release

permissions:
  contents: write
  id-token: write

concurrency:
  group: build-release-${{ github.ref }}
  cancel-in-progress: true

env:
  FLUTTER_VERSION: '3.27.1'

jobs:
  # Extract version information
  version-info:
    name: Extract Version Information
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      build_number: ${{ steps.version.outputs.build_number }}
      full_version: ${{ steps.version.outputs.full_version }}
      tag_name: ${{ steps.version.outputs.tag_name }}
      release_name: ${{ steps.version.outputs.release_name }}
      is_release: ${{ steps.version.outputs.is_release }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for version detection
        
    - name: Setup GitHub CLI
      run: |
        if ! command -v gh &> /dev/null; then
          echo "Installing GitHub CLI..."
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt update && sudo apt install gh -y
        fi
        echo "GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_ENV
      
    - name: Extract version and generate build number
      id: version
      run: |
        # Check if this is a tag push, workflow_dispatch with release, or main branch
        BUILD_TYPE="${{ github.event.inputs.build_type }}"
        
        if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          # Release build from tag
          TAG_REF="${GITHUB_REF_NAME:-${{ github.ref_name }}}"
          VERSION="${TAG_REF#v}"
          IS_RELEASE="true"
        elif [[ "$BUILD_TYPE" == "release" ]]; then
          # Manual release build via workflow_dispatch
          if [ -f pubspec.yaml ]; then
            VERSION=$(grep "^version:" pubspec.yaml | sed 's/version: //' | sed 's/+.*//')
          fi
          
          # Fallback if version not found
          if [ -z "$VERSION" ]; then
            SHORT_SHA=$(git rev-parse --short HEAD)
            VERSION="0.0.0-dev-$SHORT_SHA"
          fi
          IS_RELEASE="true"
        else
          # Main branch build - extract version from pubspec.yaml
          if [ -f pubspec.yaml ]; then
            VERSION=$(grep "^version:" pubspec.yaml | sed 's/version: //' | sed 's/+.*//')
          fi
          
          # Fallback to commit-based version if not found
          if [ -z "$VERSION" ]; then
            SHORT_SHA=$(git rev-parse --short HEAD)
            VERSION="0.0.0+dev-$SHORT_SHA"
            IS_RELEASE="false"
          else
            # Always create release for any version on main branch
            # Extract version from previous commit's pubspec.yaml if available
            PREV_PUBSPEC_VERSION=""
            if git show HEAD~1:pubspec.yaml 2>/dev/null | grep -q "^version:"; then
              PREV_PUBSPEC_VERSION=$(git show HEAD~1:pubspec.yaml 2>/dev/null | grep "^version:" | sed 's/version: //' | sed 's/+.*//' | tr -d ' ' || echo "")
            fi
            
            echo "Current version: $VERSION"
            echo "Previous version: $PREV_PUBSPEC_VERSION"
            
            # Always create release for main branch builds
            echo "Creating release for version $VERSION on main branch"
            IS_RELEASE="true"
          fi
        fi

        # Generate build number as YYYYMMDDHHMM (UTC)
        BUILD_NUMBER=$(date -u +%Y%m%d%H%M)

        # Full version: x.x.x+YYYYMMDDHHMM (or with commit SHA for dev builds)
        if [ "$IS_RELEASE" == "true" ]; then
          FULL_VERSION="$VERSION+$BUILD_NUMBER"
          TAG_NAME="v$VERSION"
          RELEASE_NAME="CloudToLocalLLM v$VERSION"
        else
          SHORT_SHA=$(git rev-parse --short HEAD)
          FULL_VERSION="$VERSION+$BUILD_NUMBER-$SHORT_SHA"
          TAG_NAME=""
          RELEASE_NAME="CloudToLocalLLM Dev Build $BUILD_NUMBER"
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
        echo "full_version=$FULL_VERSION" >> $GITHUB_OUTPUT
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
        echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT

        echo "Version: $VERSION"
        echo "Build Number: $BUILD_NUMBER"
        echo "Full Version: $FULL_VERSION"
        echo "Is Release: $IS_RELEASE"
        if [ "$IS_RELEASE" == "true" ]; then
          echo "Tag: $TAG_NAME"
          echo "Release Name: $RELEASE_NAME"
        fi

  # Build desktop application using matrix strategy
  build-desktop:
    name: Build ${{ matrix.platform }} Desktop App
    runs-on: ${{ matrix.os }}
    needs: version-info
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: windows
            os: windows-latest
            build-command: flutter build windows --release
            artifact-name: windows-desktop
    
    steps:
    - name: Debug - Job started
      run: |
        Write-Host "=== Build Desktop Job Started ===" -ForegroundColor Green
        Write-Host "Platform: ${{ matrix.platform }}" -ForegroundColor Cyan
        Write-Host "Version: ${{ needs.version-info.outputs.version }}" -ForegroundColor Cyan
        Write-Host "Is Release: ${{ needs.version-info.outputs.is_release }}" -ForegroundColor Cyan
        Write-Host "Runner OS: ${{ runner.os }}" -ForegroundColor Cyan
      shell: powershell
      
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Flutter SDK
      uses: subosito/flutter-action@v2
      with:
        flutter-version: ${{ env.FLUTTER_VERSION }}
        channel: 'stable'
        cache: true
        cache-key: 'flutter-:os:-:channel:-:version:-:arch:-:hash:'
        cache-path: '${{ runner.tool_cache }}/flutter/:channel:-:version:-:arch:'
      
    - name: Cache Flutter pub dependencies
      uses: actions/cache@v4
      with:
        path: |
          ${{ runner.temp }}\.pub-cache
          ${{ runner.temp }}\pub-cache
          ~\.pub-cache
          .dart_tool
        key: ${{ matrix.platform }}-flutter-pub-${{ hashFiles('**/pubspec.lock') }}
        restore-keys: |
          ${{ matrix.platform }}-flutter-pub-${{ hashFiles('**/pubspec.lock') }}
          ${{ matrix.platform }}-flutter-pub-
          flutter-pub-
      continue-on-error: true
      
    - name: Cache Chocolatey packages
      uses: actions/cache@v4
      with:
        path: |
          ${{ runner.temp }}\chocolatey
          C:\ProgramData\chocolatey\lib
          C:\ProgramData\chocolatey\bin
        key: ${{ runner.os }}-chocolatey-innosetup-${{ hashFiles('.github/workflows/build-release.yml') }}
        restore-keys: |
          ${{ runner.os }}-chocolatey-innosetup-
          ${{ runner.os }}-chocolatey-
      continue-on-error: true
        
    - name: Verify all build dependencies
      run: |
        Write-Host "=== Verifying Build Dependencies ===" -ForegroundColor Green
        flutter --version
        flutter doctor -v
        git --version
      shell: powershell
        
    - name: Configure Windows desktop support
      run: |
        Write-Host "Enabling Windows desktop support..."
        flutter config --enable-windows-desktop
      shell: powershell
      
    - name: Get Flutter dependencies
      run: flutter pub get
      shell: powershell
      
    - name: Build Windows desktop application
      run: flutter build windows --release
      shell: powershell
      
    - name: Install Inno Setup
      run: |
        Write-Host "=== Installing Inno Setup ===" -ForegroundColor Green
        Write-Host ""
        
        # Check if Inno Setup is already installed
        $innoSetupPaths = @(
          "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe",
          "${env:ProgramFiles}\Inno Setup 6\ISCC.exe",
          "${env:ProgramFiles(x86)}\Inno Setup 5\ISCC.exe",
          "${env:ProgramFiles}\Inno Setup 5\ISCC.exe"
        )
        
        $innoPath = $null
        foreach ($path in $innoSetupPaths) {
          if (Test-Path $path) {
            $innoPath = $path
            Write-Host "Inno Setup already installed at: $innoPath" -ForegroundColor Cyan
            break
          }
        }
        
        # Install if not found
        if (-not $innoPath) {
          Write-Host "Inno Setup not found. Installing..." -ForegroundColor Yellow
          Write-Host ""
          
          # Try Chocolatey first
          Write-Host "Attempting installation via Chocolatey..." -ForegroundColor Cyan
          try {
            $chocoInstalled = Get-Command choco -ErrorAction SilentlyContinue
            if ($chocoInstalled) {
              Write-Host "Chocolatey found. Installing Inno Setup..."
              choco install innosetup -y --no-progress
              
              if ($LASTEXITCODE -eq 0) {
                Write-Host "Inno Setup installed successfully via Chocolatey" -ForegroundColor Green
                
                # Verify installation
                foreach ($path in $innoSetupPaths) {
                  if (Test-Path $path) {
                    $innoPath = $path
                    break
                  }
                }
              } else {
                Write-Host "Chocolatey installation failed with exit code: $LASTEXITCODE" -ForegroundColor Yellow
              }
            } else {
              Write-Host "Chocolatey not found on system" -ForegroundColor Yellow
            }
          } catch {
            Write-Host "Chocolatey installation failed: $_" -ForegroundColor Yellow
          }
          
          # Fallback to Winget if Chocolatey failed
          if (-not $innoPath) {
            Write-Host ""
            Write-Host "Attempting installation via Winget..." -ForegroundColor Cyan
            try {
              $wingetInstalled = Get-Command winget -ErrorAction SilentlyContinue
              if ($wingetInstalled) {
                Write-Host "Winget found. Installing Inno Setup..."
                winget install --id JRSoftware.InnoSetup --silent --accept-source-agreements --accept-package-agreements
                
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "Inno Setup installed successfully via Winget" -ForegroundColor Green
                  
                  # Verify installation
                  foreach ($path in $innoSetupPaths) {
                    if (Test-Path $path) {
                      $innoPath = $path
                      break
                    }
                  }
                } else {
                  Write-Host "Winget installation failed with exit code: $LASTEXITCODE" -ForegroundColor Yellow
                }
              } else {
                Write-Host "Winget not found on system" -ForegroundColor Yellow
              }
            } catch {
              Write-Host "Winget installation failed: $_" -ForegroundColor Yellow
            }
          }
          
          # Final check
          if (-not $innoPath) {
            Write-Error "Failed to install Inno Setup via Chocolatey or Winget"
            Write-Host ""
            Write-Host "Manual installation options:" -ForegroundColor Yellow
            Write-Host "1. Chocolatey: choco install innosetup -y"
            Write-Host "2. Winget: winget install JRSoftware.InnoSetup"
            Write-Host "3. Direct download: https://jrsoftware.org/isdl.php"
            exit 1
          }
        }
        
        Write-Host ""
        Write-Host "Inno Setup installation verified successfully" -ForegroundColor Green
      shell: powershell
      
    - name: Detect Inno Setup path and set environment variable
      run: |
        Write-Host "=== Detecting Inno Setup Installation Path ===" -ForegroundColor Green
        Write-Host ""
        
        $innoSetupPaths = @(
          "${env:ProgramFiles(x86)}\Inno Setup 6\ISCC.exe",
          "${env:ProgramFiles}\Inno Setup 6\ISCC.exe",
          "${env:ProgramFiles(x86)}\Inno Setup 5\ISCC.exe",
          "${env:ProgramFiles}\Inno Setup 5\ISCC.exe"
        )
        
        $innoPath = $null
        foreach ($path in $innoSetupPaths) {
          if (Test-Path $path) {
            $innoPath = $path
            Write-Host "Inno Setup found at: $innoPath" -ForegroundColor Cyan
            break
          }
        }
        
        if (-not $innoPath) {
          Write-Error "Inno Setup executable not found after installation"
          Write-Host "Searched paths:" -ForegroundColor Yellow
          foreach ($path in $innoSetupPaths) {
            Write-Host "  - $path"
          }
          exit 1
        }
        
        # Set environment variable for subsequent steps
        echo "INNO_SETUP_PATH=$innoPath" >> $env:GITHUB_ENV
        Write-Host ""
        Write-Host "Environment variable INNO_SETUP_PATH set to: $innoPath" -ForegroundColor Green
      shell: powershell
      
    - name: Verify Inno Setup is accessible
      run: |
        Write-Host "=== Verifying Inno Setup Accessibility ===" -ForegroundColor Green
        Write-Host ""
        
        if (-not $env:INNO_SETUP_PATH) {
          Write-Error "INNO_SETUP_PATH environment variable is not set"
          exit 1
        }
        
        if (-not (Test-Path $env:INNO_SETUP_PATH)) {
          Write-Error "Inno Setup executable not found at: $env:INNO_SETUP_PATH"
          exit 1
        }
        
        Write-Host "Inno Setup path: $env:INNO_SETUP_PATH" -ForegroundColor Cyan
        
        # Try to get version information
        try {
          Write-Host ""
          Write-Host "Inno Setup version information:" -ForegroundColor Cyan
          & $env:INNO_SETUP_PATH /? 2>&1 | Select-Object -First 5
          Write-Host ""
          Write-Host "Inno Setup is accessible and ready to use" -ForegroundColor Green
        } catch {
          Write-Error "Failed to execute Inno Setup: $_"
          exit 1
        }
      shell: powershell
      
    - name: Create Windows installer
      run: |
        $FULL_VERSION = "${{ needs.version-info.outputs.full_version }}"
        $VERSION = "${{ needs.version-info.outputs.version }}"
        $PACKAGE_PATH = "dist/windows"
        
        # Create dist directory
        New-Item -ItemType Directory -Force -Path $PACKAGE_PATH
        
        # Path to InnoSetup script
        $issFile = "build-tools\installers\windows\CloudToLocalLLM_Simple.iss"
        
        if (-not (Test-Path $issFile)) {
          throw "InnoSetup script not found at: $issFile"
        }
        
        # Compile installer
        Write-Host "Compiling Windows installer with Inno Setup..."
        # Escape the version for Inno Setup preprocessor (quote if contains special chars)
        $escapedVersion = $VERSION
        if ($escapedVersion -match '[^0-9.]') {
          $escapedVersion = "`"$escapedVersion`""
        }
        # Get absolute paths
        $projectRoot = (Get-Location).Path
        $buildSource = Join-Path $projectRoot "build\windows\x64\runner\Release"
        Write-Host "Project root: $projectRoot"
        Write-Host "Build source: $buildSource"
        
        $innoArgs = @(
          "`"$issFile`"",
          "/DMyAppVersion=$escapedVersion",
          "/DSourceDir=$projectRoot",
          "/DBuildDir=$buildSource",
          "/O`"$PACKAGE_PATH`""
        )
        
        $process = Start-Process -FilePath $env:INNO_SETUP_PATH -ArgumentList $innoArgs -Wait -PassThru -NoNewWindow
        
        if ($process.ExitCode -ne 0) {
          throw "Inno Setup compilation failed with exit code: $($process.ExitCode)"
        }
        
        # Find the created installer (output filename may vary)
        $installerPattern = "CloudToLocalLLM*Setup*.exe"
        $installer = Get-ChildItem -Path $PACKAGE_PATH -Filter $installerPattern -ErrorAction SilentlyContinue | Select-Object -First 1
        
        if ($installer) {
          Write-Host "Installer created: $($installer.FullName)"
          echo "INSTALLER_FILE=$($installer.FullName)" >> $env:GITHUB_ENV
          
          # Generate SHA256 checksum for installer
          $hash = Get-FileHash $installer.FullName -Algorithm SHA256
          $checksumFile = "$($installer.FullName).sha256"
          $hash.Hash + "  $($installer.Name)" | Out-File $checksumFile -Encoding ASCII
          echo "INSTALLER_CHECKSUM=$checksumFile" >> $env:GITHUB_ENV
        } else {
          throw "Installer file not found in $PACKAGE_PATH"
        }
      shell: powershell
      
    - name: Create portable package
      run: |
        $FULL_VERSION = "${{ needs.version-info.outputs.full_version }}"
        $PACKAGE_NAME = "cloudtolocalllm-$FULL_VERSION-portable"
        $PACKAGE_PATH = "dist/windows"

        # Copy build output
        Copy-Item -Recurse "build\windows\x64\runner\Release" "$PACKAGE_PATH/$PACKAGE_NAME"

        # Create ZIP archive
        Compress-Archive -Path "$PACKAGE_PATH/$PACKAGE_NAME" -DestinationPath "$PACKAGE_PATH/$PACKAGE_NAME.zip"

        # Generate SHA256 checksum
        $hash = Get-FileHash "$PACKAGE_PATH/$PACKAGE_NAME.zip" -Algorithm SHA256
        $hash.Hash + "  $PACKAGE_NAME.zip" | Out-File "$PACKAGE_PATH/$PACKAGE_NAME.zip.sha256" -Encoding ASCII

        echo "PACKAGE_FILE=$PACKAGE_PATH/$PACKAGE_NAME.zip" >> $env:GITHUB_ENV
        echo "CHECKSUM_FILE=$PACKAGE_PATH/$PACKAGE_NAME.zip.sha256" >> $env:GITHUB_ENV
      shell: powershell
      
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.artifact-name }}
        path: |
          ${{ env.PACKAGE_FILE }}
          ${{ env.CHECKSUM_FILE }}
          ${{ env.INSTALLER_FILE }}
          ${{ env.INSTALLER_CHECKSUM }}
        retention-days: 30

  # Create GitHub release with all platform builds (only for tag pushes)
  create-release:
    name: Create GitHub Release
    if: needs.version-info.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    needs: [version-info, build-desktop]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
      
    - name: Download all build artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
        pattern: '*-desktop'
        merge-multiple: true
        
    - name: Prepare release assets
      run: |
        mkdir -p release-assets
        
        # Copy only the latest artifacts to release assets directory (Windows only)
        # Find the most recent files by modification time
        LATEST_EXE=$(find artifacts/ -name "*.exe" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2-)
        LATEST_ZIP=$(find artifacts/ -name "*.zip" -type f ! -name "*.exe.zip" -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2-)
        LATEST_EXE_HASH=$(find artifacts/ -name "*.exe.sha256" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2-)
        LATEST_ZIP_HASH=$(find artifacts/ -name "*.zip.sha256" -type f ! -name "*.exe.zip.sha256" -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2-)
        
        # Copy only the latest files
        if [ -n "$LATEST_EXE" ]; then cp "$LATEST_EXE" release-assets/; fi
        if [ -n "$LATEST_ZIP" ]; then cp "$LATEST_ZIP" release-assets/; fi
        if [ -n "$LATEST_EXE_HASH" ]; then cp "$LATEST_EXE_HASH" release-assets/; fi
        if [ -n "$LATEST_ZIP_HASH" ]; then cp "$LATEST_ZIP_HASH" release-assets/; fi
        
        # List all assets
        echo "Release assets:"
        ls -la release-assets/
        
    - name: Generate release notes
      run: |
        VERSION="${{ needs.version-info.outputs.version }}"
        cat > release-notes.md << EOF
        # CloudToLocalLLM v$VERSION
        
        ## What's Changed
        - Version $VERSION release
        - Updated dependencies and bug fixes
        - Performance improvements
        
        ## Download
        Choose the appropriate package for Windows:
        
        - **CloudToLocalLLM-Windows-$VERSION-Setup.exe** - Windows installer (recommended)
        - **cloudtolocalllm-$VERSION-portable.zip** - Portable version (no installation required)
        
        ## Checksums
        SHA256 checksums are provided for all packages to verify integrity.
        
        **Full Changelog**: https://github.com/imrightguy/CloudToLocalLLM/compare/v${{ needs.version-info.outputs.version }}...v$VERSION
        EOF
        
    - name: Create git tag
      run: |
        VERSION="${{ needs.version-info.outputs.version }}"
        TAG_NAME="v$VERSION"
        
        # Configure git
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        
        # Check if tag already exists locally or remotely
        if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
          echo "Tag $TAG_NAME already exists locally, skipping tag creation"
        elif git ls-remote --tags origin "$TAG_NAME" | grep -q "$TAG_NAME"; then
          echo "Tag $TAG_NAME already exists on remote, skipping tag creation"
        else
          echo "Creating tag $TAG_NAME"
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME" || echo "Tag push failed (may already exist)"
        fi
      
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ needs.version-info.outputs.tag_name }}
        name: ${{ needs.version-info.outputs.release_name }}
        body_path: release-notes.md
        files: release-assets/*
        draft: false
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Create release summary
      run: |
        echo "## ðŸŽ‰ Desktop Release Created" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Release Details:**" >> $GITHUB_STEP_SUMMARY
        echo "- **Version:** ${{ needs.version-info.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Tag:** ${{ needs.version-info.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Available Platforms:**" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Installer (.exe)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Windows Portable (ZIP)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Download:** [GitHub Releases](https://github.com/imrightguy/CloudToLocalLLM/releases/tag/${{ needs.version-info.outputs.tag_name }})" >> $GITHUB_STEP_SUMMARY