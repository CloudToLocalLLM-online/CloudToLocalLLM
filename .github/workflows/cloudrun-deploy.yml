name: Cloud Run Deployment

on:
  workflow_dispatch:
    inputs:
      service:
        description: 'Service to deploy (web|api|streaming|all)'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - web
          - api
          - streaming
      environment:
        description: 'Target environment'
        required: false
        default: 'production'
        type: choice
        options:
          - production
          - staging
      cleanup_keep_revisions:
        description: 'Revisions to keep per service before deploy (newest N + any serving)'
        required: false
        default: '3'


permissions:
  contents: read
  id-token: write

concurrency:
  group: cloudrun-deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  PROJECT_ID: ${{ vars.GCP_PROJECT_ID || 'cloudtolocalllm-468303' }}

  REGION: ${{ vars.GCP_REGION || 'us-east4' }}
  REGISTRY: ${{ vars.GCP_REGION || 'us-east4' }}-docker.pkg.dev
  REPOSITORY: cloud-run-source-deploy

jobs:
  pre-clean:
    name: Pre-clean GCP state (Cloud Run revisions, AR images)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Authenticate to Google Cloud (WIF)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.WIF_PROVIDER }}
          service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}
      - name: Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
      - name: Clean old Cloud Run revisions (keep N + serving)
        shell: bash
        run: |
          set -euo pipefail
          KEEP=${{ github.event.inputs.cleanup_keep_revisions || '3' }}
          for SVC in cloudtolocalllm-web cloudtolocalllm-api cloudtolocalllm-streaming; do
            echo "\n=== Service: $SVC ==="
            REVS_JSON=$(gcloud run revisions list --service "$SVC" --region "$REGION" --format=json --sort-by=~createTime || echo '[]')
            NEWEST=$(echo "$REVS_JSON" | jq -r ".[:$KEEP]|.[].name") || true
            SERVING=$(echo "$REVS_JSON" | jq -r '.[] | select((.traffic // []) | any(.percent > 0)) | .name') || true
            mapfile -t ALL < <(echo "$REVS_JSON" | jq -r '.[].name')
            KEEPSET=$(printf '%s\n%s\n' "$NEWEST" "$SERVING" | sort -u)
            mapfile -t DELETE_LIST < <(printf '%s\n' "${ALL[@]}" | grep -v -F -x -f <(printf '%s\n' $KEEPSET) || true)
            echo "Will keep:"; printf '  %s\n' $KEEPSET || true
            echo "Will delete:"; printf '  %s\n' "${DELETE_LIST[@]}" || true
            for REV in "${DELETE_LIST[@]}"; do
              [[ -z "$REV" ]] && continue
              echo "Deleting revision $REV ..."
              gcloud run revisions delete "$REV" --region "$REGION" --quiet || true
            done
          done
      - name: Clean untagged Artifact Registry images (older than 7 days)
        shell: bash
        run: |
          set -euo pipefail
          REPO_PATH="$REGISTRY/$PROJECT_ID/$REPOSITORY"
          echo "Listing images in $REPO_PATH ..."
          IMAGES_JSON=$(gcloud artifacts docker images list "$REPO_PATH" --include-tags --format=json || echo '[]')
          NOW=$(date -u +%s)
          THRESH=$((NOW - 7*24*3600))
          if [[ -z "$IMAGES_JSON" || "$IMAGES_JSON" == "[]" ]]; then
            echo "No images found."
            exit 0
          fi
          echo "$IMAGES_JSON" | jq -r '.[] | @base64' | while read -r row; do
            _jq() { echo "$row" | base64 -d | jq -r "$1"; }
            IMG=$(_jq '.package')
            VER=$(_jq '.version')
            TAGS=$(_jq '.tags | join(",")')
            CT=$(_jq '.createTime')
            if [[ "$CT" != "null" ]]; then
              CTS=$(date -u -d "$CT" +%s 2>/dev/null || date -u -j -f "%Y-%m-%dT%H:%M:%S%z" "$CT" +%s)
            else
              CTS=$NOW
            fi
            if [[ -z "$TAGS" || "$TAGS" == "" ]]; then
              if [[ $CTS -lt $THRESH ]]; then
                FULL="$IMG@$VER"
                echo "Deleting untagged old image: $FULL (created $CT)"
                gcloud artifacts docker images delete "$FULL" --delete-tags --quiet || true
              fi
            fi
          done


  # Build container images for deployment
  build:
    name: Build Container Images
    runs-on: ubuntu-latest
    needs: pre-clean

    strategy:
      matrix:
        service: [web, api, streaming]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud (WIF)
      uses: google-github-actions/auth@v2
      with:
        workload_identity_provider: ${{ vars.WIF_PROVIDER }}
        service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}

    - name: Setup Google Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}

    - name: Configure Docker authentication
      run: |
        gcloud auth configure-docker ${{ env.REGISTRY }}

    - name: Build and push container image
      run: |
        SERVICE="${{ matrix.service }}"
        IMAGE_TAG="${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${SERVICE}:${{ github.sha }}"
        LATEST_TAG="${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/${SERVICE}:latest"

        # Resolve correct Dockerfile path per service
        DOCKERFILE="config/cloudrun/Dockerfile.${SERVICE}-cloudrun"
        if [ "$SERVICE" = "streaming" ]; then
          DOCKERFILE="config/cloudrun/Dockerfile.streaming-proxy-cloudrun"
        fi
        if [ ! -f "$DOCKERFILE" ]; then
          echo "Error: Dockerfile not found for service '$SERVICE' at $DOCKERFILE" >&2
          ls -la config/cloudrun || true
          exit 1
        fi

        echo "Building ${SERVICE} service using $DOCKERFILE..."
        docker build \
          -f "$DOCKERFILE" \
          -t ${IMAGE_TAG} \
          -t ${LATEST_TAG} \
          .

        echo "Pushing ${SERVICE} image..."
        docker push ${IMAGE_TAG}
        docker push ${LATEST_TAG}

        echo "IMAGE_${SERVICE^^}=${IMAGE_TAG}" >> $GITHUB_ENV

  # Setup Cloud SQL PostgreSQL
  setup-database:
    name: Setup Cloud SQL PostgreSQL
    runs-on: ubuntu-latest
    needs: build
    environment: ${{ github.event.inputs.environment || 'production' }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud (WIF)
      uses: google-github-actions/auth@v2
      with:
        workload_identity_provider: ${{ vars.WIF_PROVIDER }}
        service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}

    - name: Setup Google Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}

    - name: Setup Cloud SQL PostgreSQL instance
      if: github.event.inputs.service == 'all' || github.event.inputs.service == '' || github.event.inputs.service == 'api'
      run: |
        INSTANCE_NAME="cloudtolocalllm-db"
        DATABASE_NAME="cloudtolocalllm"
        DB_USER="appuser"

        echo "Checking for existing Cloud SQL instance..."
        if gcloud sql instances describe $INSTANCE_NAME >/dev/null 2>&1; then
          echo "âœ… Cloud SQL instance '$INSTANCE_NAME' already exists"
        else
          echo "ðŸ“¦ Creating Cloud SQL PostgreSQL instance..."

          # Generate secure password and store in Secret Manager
          DB_PASSWORD=$(openssl rand -base64 32)
          echo -n "$DB_PASSWORD" | gcloud secrets create db-password --data-file=- || \
          echo -n "$DB_PASSWORD" | gcloud secrets versions add db-password --data-file=-

          # Create Cloud SQL instance
          gcloud sql instances create $INSTANCE_NAME \
            --database-version=POSTGRES_15 \
            --tier=db-f1-micro \
            --region=${{ env.REGION }} \
            --storage-type=SSD \
            --storage-size=10GB \
            --storage-auto-increase \
            --backup-start-time=03:00 \
            --maintenance-window-day=SUN \
            --maintenance-window-hour=04 \
            --deletion-protection

          echo "â³ Waiting for instance to be ready..."
          gcloud sql instances describe $INSTANCE_NAME --format="value(state)" | grep -q RUNNABLE

          # Create database
          echo "ðŸ—„ï¸ Creating database: $DATABASE_NAME"
          gcloud sql databases create $DATABASE_NAME --instance=$INSTANCE_NAME

          # Create user
          echo "ðŸ‘¤ Creating database user: $DB_USER"
          gcloud sql users create $DB_USER \
            --instance=$INSTANCE_NAME \
            --password="$DB_PASSWORD"

          echo "âœ… Cloud SQL setup complete"
        fi

        # Get connection name for deployment
        CONNECTION_NAME=$(gcloud sql instances describe $INSTANCE_NAME --format="value(connectionName)")
        echo "CONNECTION_NAME=$CONNECTION_NAME" >> $GITHUB_ENV

  # Deploy to Cloud Run
  deploy:
    name: Deploy to Cloud Run
    runs-on: ubuntu-latest
    needs: [build, setup-database]
    environment: ${{ github.event.inputs.environment || 'production' }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud (WIF)
      uses: google-github-actions/auth@v2
      with:
        workload_identity_provider: ${{ vars.WIF_PROVIDER }}
        service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}

    - name: Setup Google Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}

    - name: Get Cloud SQL connection info
      if: github.event.inputs.service == 'all' || github.event.inputs.service == '' || github.event.inputs.service == 'api'
      run: |
        INSTANCE_NAME="cloudtolocalllm-db"
        CONNECTION_NAME=$(gcloud sql instances describe $INSTANCE_NAME --format="value(connectionName)" 2>/dev/null || echo "")
        echo "CONNECTION_NAME=$CONNECTION_NAME" >> $GITHUB_ENV

    - name: Validate GCIP API Key
      run: |
        # Resolve GCIP API key: prefer GitHub secret; fallback to GCP Secret Manager
        GCIP_API_KEY_VAL="${{ secrets.GCIP_API_KEY }}"
        if [ -z "$GCIP_API_KEY_VAL" ]; then
          echo "GCIP_API_KEY not found in GitHub secrets, trying GCP Secret Manager..."
          GCIP_API_KEY_VAL="$(gcloud secrets versions access latest --secret=\"gcip-api-key\" 2>/dev/null || echo \"\")"
        fi

        if [ -z "$GCIP_API_KEY_VAL" ]; then
          echo "ERROR: GCIP_API_KEY not found in GitHub secrets or GCP Secret Manager"
          echo "Please set the GCIP_API_KEY secret in GitHub repository settings or create it in GCP Secret Manager"
          exit 1
        fi

        # Validate key format (should start with AIza for Google API keys)
        if [[ ! "$GCIP_API_KEY_VAL" =~ ^AIza ]]; then
          echo "WARNING: GCIP_API_KEY does not appear to be a valid Google API key (should start with 'AIza')"
        fi

        echo "GCIP_API_KEY_VAL=$GCIP_API_KEY_VAL" >> $GITHUB_ENV
        echo "âœ… GCIP API key validated successfully"

    - name: Deploy Web Service
      if: github.event.inputs.service == 'all' || github.event.inputs.service == '' || github.event.inputs.service == 'web'
      run: |
        gcloud run deploy cloudtolocalllm-web \
          --image=${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/web:${{ github.sha }} \
          --platform=managed \
          --region=${{ env.REGION }} \
          --allow-unauthenticated \
          --port=8080 \
          --memory=1Gi \
          --cpu=1 \
          --min-instances=0 \
          --max-instances=10 \
          --concurrency=80 \
          --timeout=300 \
          --service-account=cloudtolocalllm-runner@${{ env.PROJECT_ID }}.iam.gserviceaccount.com \
          --set-env-vars="NODE_ENV=production,LOG_LEVEL=info,FIREBASE_PROJECT_ID=${{ vars.FIREBASE_PROJECT_ID || 'cloudtolocalllm-468303' }},GCIP_API_KEY=$GCIP_API_KEY_VAL" \
          --quiet

    - name: Deploy API Service
      if: github.event.inputs.service == 'all' || github.event.inputs.service == '' || github.event.inputs.service == 'api'
      run: |
        # Get database password from Secret Manager
        DB_PASSWORD=$(gcloud secrets versions access latest --secret="db-password" 2>/dev/null || echo "")

        # Deploy with PostgreSQL configuration
        gcloud run deploy cloudtolocalllm-api \
          --image=${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/api:${{ github.sha }} \
          --platform=managed \
          --region=${{ env.REGION }} \
          --allow-unauthenticated \
          --port=8080 \
          --memory=2Gi \
          --cpu=2 \
          --min-instances=0 \
          --max-instances=20 \
          --concurrency=100 \
          --timeout=900 \
          --service-account=cloudtolocalllm-runner@${{ env.PROJECT_ID }}.iam.gserviceaccount.com \
          --set-env-vars="NODE_ENV=production,LOG_LEVEL=info,DB_TYPE=postgresql,DB_NAME=cloudtolocalllm,DB_USER=appuser,DB_PASSWORD=$DB_PASSWORD,DB_HOST=/cloudsql/$CONNECTION_NAME,CLOUD_SQL_CONNECTION_NAME=$CONNECTION_NAME,FIREBASE_PROJECT_ID=${{ vars.FIREBASE_PROJECT_ID || 'cloudtolocalllm-468303' }}" \
          --add-cloudsql-instances="$CONNECTION_NAME" \
          --quiet

    - name: Deploy Streaming Service
      if: github.event.inputs.service == 'all' || github.event.inputs.service == '' || github.event.inputs.service == 'streaming'
      run: |
        gcloud run deploy cloudtolocalllm-streaming \
          --image=${{ env.REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY }}/streaming:${{ github.sha }} \
          --platform=managed \
          --region=${{ env.REGION }} \
          --allow-unauthenticated \
          --port=8080 \
          --memory=1Gi \
          --cpu=1 \
          --min-instances=0 \
          --max-instances=15 \
          --concurrency=50 \
          --timeout=3600 \
          --service-account=cloudtolocalllm-runner@${{ env.PROJECT_ID }}.iam.gserviceaccount.com \
          --set-env-vars="NODE_ENV=production,LOG_LEVEL=info,FIREBASE_PROJECT_ID=${{ vars.FIREBASE_PROJECT_ID || 'cloudtolocalllm-468303' }}" \
          --quiet

  # Post-deployment verification
  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: deploy

    steps:
    - name: Authenticate to Google Cloud (WIF)
      uses: google-github-actions/auth@v2
      with:
        workload_identity_provider: ${{ vars.WIF_PROVIDER }}
        service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}

    - name: Setup Google Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}

    - name: Get service URLs
      run: |
        echo "Getting Cloud Run service URLs..."
        WEB_URL=$(gcloud run services describe cloudtolocalllm-web --platform=managed --region=${{ env.REGION }} --format='value(status.url)')
        API_URL=$(gcloud run services describe cloudtolocalllm-api --platform=managed --region=${{ env.REGION }} --format='value(status.url)')
        STREAMING_URL=$(gcloud run services describe cloudtolocalllm-streaming --platform=managed --region=${{ env.REGION }} --format='value(status.url)')

        echo "Web Service URL: $WEB_URL"
        echo "API Service URL: $API_URL"
        echo "Streaming Service URL: $STREAMING_URL"

        echo "WEB_URL=$WEB_URL" >> $GITHUB_ENV
        echo "API_URL=$API_URL" >> $GITHUB_ENV
        echo "STREAMING_URL=$STREAMING_URL" >> $GITHUB_ENV

    - name: Health check
      run: |
        echo "Performing health checks..."

        # Check web service
        if [ -n "$WEB_URL" ]; then
          echo "Checking web service health..."
          curl -f "$WEB_URL/health" || echo "Web service health check failed"
        fi

        # Check API service and database
        if [ -n "$API_URL" ]; then
          echo "Checking API service health..."
          curl -f "$API_URL/health" || echo "API service health check failed"

          echo "Checking database health..."
          DB_HEALTH=$(curl -s "$API_URL/api/db/health" | jq -r '.status' 2>/dev/null || echo "error")
          if [ "$DB_HEALTH" = "healthy" ]; then
            echo "âœ… Database health check passed"
            curl -s "$API_URL/api/db/health" | jq '.'
          else
            echo "âŒ Database health check failed"
            curl -s "$API_URL/api/db/health" || echo "Could not reach database health endpoint"
          fi
        fi

        # Check streaming service
        if [ -n "$STREAMING_URL" ]; then
          echo "Checking streaming service health..."
          curl -f "$STREAMING_URL/health" || echo "Streaming service health check failed"
        fi

        echo "Health checks completed"

    - name: Create deployment summary
      run: |
        echo "## ðŸš€ Cloud Run Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Deployment Details:**" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment:** ${{ github.event.inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Region:** ${{ env.REGION }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Services:** ${{ github.event.inputs.service || 'all' }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Service URLs:**" >> $GITHUB_STEP_SUMMARY
        if [ -n "$WEB_URL" ]; then
          echo "- **Web App:** [$WEB_URL]($WEB_URL)" >> $GITHUB_STEP_SUMMARY
        fi
        if [ -n "$API_URL" ]; then
          echo "- **API Backend:** [$API_URL]($API_URL)" >> $GITHUB_STEP_SUMMARY
        fi
        if [ -n "$STREAMING_URL" ]; then
          echo "- **Streaming Service:** [$STREAMING_URL]($STREAMING_URL)" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
        echo "1. Test the deployed services using the URLs above" >> $GITHUB_STEP_SUMMARY
        echo "2. Monitor performance and costs in Google Cloud Console" >> $GITHUB_STEP_SUMMARY
        echo "3. Configure custom domains if needed" >> $GITHUB_STEP_SUMMARY
