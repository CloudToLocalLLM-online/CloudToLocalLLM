name: "ðŸš€ Build Pipeline"

on:
  repository_dispatch:
    types: [orchestrator-build]
  workflow_dispatch:
    inputs:
      do_desktop:
        description: "Build for Desktop"
        type: boolean
        default: true
      promote:
        description: "Promote to Argo CD (GitOps)"
        type: boolean
        default: true

concurrency:
  group: build-pipeline-${{ github.ref }}-build
  cancel-in-progress: true

env:
  AZURE_RESOURCE_GROUP: cloudtolocalllm-rg
  AZURE_CLUSTER_NAME: cloudtolocalllm-aks
  ACR_NAME: imrightguycloudtolocalllm
  SENTRY_DSN: ${{ secrets.SENTRY_DSN }}

defaults:
  run:
    shell: bash

jobs:
  validate_prerequisites:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Validate Prerequisites
        run: |
          chmod +x scripts/validate-aks-prerequisites.sh
          ./scripts/validate-aks-prerequisites.sh
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEY_VAULT_NAME: ${{ secrets.AZURE_KEY_VAULT_NAME }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          STRIPE_TEST_SECRET_KEY: ${{ secrets.STRIPE_TEST_SECRET_KEY }}
          CLOUDFLARE_DNS_TOKEN: ${{ secrets.CLOUDFLARE_DNS_TOKEN }}
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
          SUPABASE_JWT_SECRET: ${{ secrets.SUPABASE_JWT_SECRET }}

  build_base:
    needs: [validate_prerequisites]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.client_payload.ref || github.ref }}
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: az acr login
        run: az acr login --name ${{ env.ACR_NAME }}
      - name: Build and Push Base
        uses: docker/build-push-action@v5
        with:
          context: .
          file: config/docker/Dockerfile.base
          push: true
          tags: |
            ${{ env.ACR_NAME }}.azurecr.io/base:latest
            ${{ env.ACR_NAME }}.azurecr.io/base:main-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build_api:
    needs: [build_base]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.client_payload.ref || github.ref }}
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: az acr login
        run: az acr login --name ${{ env.ACR_NAME }}
      - name: Build and Push API
        uses: docker/build-push-action@v5
        with:
          context: .
          file: services/api-backend/Dockerfile.prod
          build-args: |
            BASE_REGISTRY=${{ env.ACR_NAME }}.azurecr.io
          push: true
          tags: |
            ${{ env.ACR_NAME }}.azurecr.io/api-backend:latest
            ${{ env.ACR_NAME }}.azurecr.io/api-backend:main-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build_web:
    needs: [build_base]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.client_payload.ref || github.ref }}
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: az acr login
        run: az acr login --name ${{ env.ACR_NAME }}
      - name: Build and Push Web
        uses: docker/build-push-action@v5
        with:
          context: .
          file: config/docker/Dockerfile.web
          push: true
          tags: |
            ${{ env.ACR_NAME }}.azurecr.io/web:latest
            ${{ env.ACR_NAME }}.azurecr.io/web:main-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build_linux:
    needs: [validate_prerequisites]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.client_payload.ref || github.ref }}
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: "3.x"
          channel: stable
          cache: true
      - name: Install Linux dependencies
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: |
            sudo apt-get update
            sudo apt-get install -y clang cmake ninja-build pkg-config libgtk-3-dev liblzma-dev libsecret-1-dev libcurl4-openssl-dev libssl-dev libayatana-appindicator3-dev
      - name: Flutter Pub Get
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: flutter pub get
      - name: Build Linux Desktop
        run: |
          flutter build linux --release
          tar -czf CloudToLocalLLM-Linux-Portable.tar.gz -C build/linux/x64/release/bundle .
      - name: Upload Linux Artifact
        uses: actions/upload-artifact@v4
        with:
          name: desktop-linux
          path: "*.tar.gz"

  build_windows:
    needs: [validate_prerequisites]
    runs-on: windows-latest
    timeout-minutes: 45
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.client_payload.ref || github.ref }}
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: "3.x"
          channel: stable
          cache: true
      - name: Build Windows
        shell: pwsh
        run: |
          flutter config --enable-windows-desktop
          flutter pub get
          flutter build windows --release --no-tree-shake-icons
          Compress-Archive -Path build\windows\x64\runner\Release\* -DestinationPath CloudToLocalLLM-Windows-Portable.zip -Force
      - name: Upload Windows Artifact
        uses: actions/upload-artifact@v4
        with:
          name: desktop-windows
          path: "*.zip"

  deploy_secrets:
    needs: [validate_prerequisites]
    if: ${{ (github.event_name == 'push' || github.event_name == 'repository_dispatch') && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Get AKS Credentials
        run: |
          az aks get-credentials --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_CLUSTER_NAME }} --overwrite-existing
      - name: Deploy Kubernetes Secrets
        env:
          AUTH0_DOMAIN: ${{ secrets.AUTH0_DOMAIN }}
          AUTH0_CLIENT_ID: ${{ secrets.AUTH0_CLIENT_ID }}
          AUTH0_CLIENT_SECRET: ${{ secrets.AUTH0_CLIENT_SECRET }}
          AUTH0_AUDIENCE: ${{ secrets.AUTH0_AUDIENCE }}
          AUTH0_ISSUER_URL: ${{ secrets.AUTH0_ISSUER_URL }}
          POSTGRES_USER: "cloud_admin"
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          STRIPE_TEST_SECRET_KEY: ${{ secrets.STRIPE_TEST_SECRET_KEY }}
          STRIPE_TEST_PUBLISHABLE_KEY: ${{ secrets.STRIPE_TEST_PUBLISHABLE_KEY }}
          STRIPE_TEST_WEBHOOK_SECRET: ${{ secrets.STRIPE_TEST_WEBHOOK_SECRET }}
          STRIPE_LIVE_SECRET_KEY: ${{ secrets.STRIPE_LIVE_SECRET_KEY }}
          STRIPE_LIVE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_LIVE_PUBLISHABLE_KEY }}
          STRIPE_LIVE_WEBHOOK_SECRET: ${{ secrets.STRIPE_LIVE_WEBHOOK_SECRET }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
        run: |
          # Use jq to construct a valid Kubernetes Secret JSON to ensure proper character escaping
          # This resolves "found unknown escape character" errors common with envsubst
          jq -n \
            --arg postgres_user "$POSTGRES_USER" \
            --arg postgres_password "$POSTGRES_PASSWORD" \
            --arg jwt_secret "$JWT_SECRET" \
            --arg auth0_domain "$AUTH0_DOMAIN" \
            --arg auth0_audience "$AUTH0_AUDIENCE" \
            --arg auth0_client_id "$AUTH0_CLIENT_ID" \
            --arg auth0_client_secret "$AUTH0_CLIENT_SECRET" \
            --arg stripe_test_secret_key "$STRIPE_TEST_SECRET_KEY" \
            --arg stripe_test_publishable_key "$STRIPE_TEST_PUBLISHABLE_KEY" \
            --arg stripe_test_webhook_secret "$STRIPE_TEST_WEBHOOK_SECRET" \
            --arg stripe_live_secret_key "$STRIPE_LIVE_SECRET_KEY" \
            --arg stripe_live_publishable_key "$STRIPE_LIVE_PUBLISHABLE_KEY" \
            --arg stripe_live_webhook_secret "$STRIPE_LIVE_WEBHOOK_SECRET" \
            --arg sentry_dsn "$SENTRY_DSN" \
            '{
              apiVersion: "v1",
              kind: "Secret",
              metadata: {
                name: "cloudtolocalllm-secrets",
                namespace: "cloudtolocalllm"
              },
              type: "Opaque",
              stringData: {
                "postgres-user": $postgres_user,
                "postgres-password": $postgres_password,
                "jwt-secret": $jwt_secret,
                "auth0-domain": $auth0_domain,
                "auth0-audience": $auth0_audience,
                "auth0-client-id": $auth0_client_id,
                "auth0-client-secret": $auth0_client_secret,
                "stripe-test-secret-key": $stripe_test_secret_key,
                "stripe-test-publishable-key": $stripe_test_publishable_key,
                "stripe-test-webhook-secret": $stripe_test_webhook_secret,
                "stripe-live-secret-key": $stripe_live_secret_key,
                "stripe-live-publishable-key": $stripe_live_publishable_key,
                "stripe-live-webhook-secret": $stripe_live_webhook_secret,
                "sentry-dsn": $sentry_dsn
              }
            }' | kubectl apply -f -

      - name: Deploy Optimized Cloudflare Tunnel
        run: |
          # Calculate SHA of ConfigMap to trigger rolling restart if config changed
          # Use -- to terminate option processing for grep and avoid "unrecognized option '---'"
          CONFIG_MAP_YAML=$(sed -n '/kind: ConfigMap/,/---/p' k8s/deployments/overlays/managed/cloudflared-tunnel.yaml | grep -v -- "---")
          export CLOUDFLARED_CONFIG_SHA=$(echo "$CONFIG_MAP_YAML" | sha256sum | cut -d' ' -f1)
          
          # Use envsubst to inject the SHA into the Deployment and apply
          envsubst '$CLOUDFLARED_CONFIG_SHA' < k8s/deployments/overlays/managed/cloudflared-tunnel.yaml | kubectl apply -f -

      - name: Deploy Monitoring Configuration
        run: |
          # Ensure monitoring configurations (Prometheus/Alertmanager) are up to date
          kubectl apply -f k8s/deployments/base/prometheus-config.yaml
          kubectl apply -f k8s/deployments/base/alertmanager-config.yaml

  promote_to_gitops:
    needs: [build_api, build_web, deploy_secrets]
    if: ${{ (github.event_name == 'push' || github.event_name == 'repository_dispatch') && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main
          fetch-depth: 0
      - name: Promote to Argo CD
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 5
          retry_on: error
          command: |
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            SHA="${{ github.sha }}"
            TAG="main-${SHA}"
            sed -i "s|newTag: .*|newTag: $TAG-api-backend|g" k8s/apps/managed/api-backend/kustomization.yaml
            sed -i "s|newTag: .*|newTag: $TAG|g" k8s/apps/managed/web-frontend/kustomization.yaml
            if grep -r "streaming-proxy" k8s/apps/managed/ > /dev/null; then
               sed -i "s|newTag: .*streaming-proxy.*|newTag: $TAG-streaming-proxy|g" $(grep -r "streaming-proxy" k8s/apps/managed/ -l)
            fi
            git add k8s/apps/managed/
            if ! git diff --cached --quiet; then
              git commit -m "chore(deploy): promote version $TAG [skip ci]"
              git pull --rebase origin main
              git push origin main
            fi

  create_release:
    needs: [build_linux, build_windows, promote_to_gitops]
    if: ${{ always() && (startsWith(github.ref, 'refs/tags/v') || contains(github.event.head_commit.message, 'version')) }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.client_payload.ref || github.ref }}
      - name: Get Version
        id: get_version
        run: |
          VERSION=$(cat assets/version.json | jq -r '.version')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      - name: Download Artifacts
        uses: actions/download-artifact@v4
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.get_version.outputs.version }}
          name: Release v${{ steps.get_version.outputs.version }}
          files: |
            desktop-windows/*.zip
            desktop-linux/*.tar.gz
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
