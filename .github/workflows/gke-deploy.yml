name: Deploy to GKE

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: gke-deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy-web:
    name: Deploy Web to GKE
    runs-on: ubuntu-latest
    permissions:
      contents: 'read'
      id-token: 'write'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4


      - name: Google Auth
        id: auth
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: '${{ vars.WIF_PROVIDER }}'
          service_account: '${{ vars.WIF_SERVICE_ACCOUNT }}'

      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v2'

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v1
        with:
          cluster_name: 'cloudtolocalllm-us-central1'
          location: 'us-central1'

      - name: 'Build and Push Container (Cloud Build)'
        id: cb_web
        run: |
          set -euo pipefail
          OUT=$(gcloud builds submit --async --tag "gcr.io/${{ vars.GCP_PROJECT_ID }}/web:${{ github.sha }}" web 2>&1 | tee /tmp/cb_web.out)
          BUILD_ID=$(echo "$OUT" | grep -oE 'builds/[a-f0-9-]+' | head -n1 | cut -d/ -f2 || true)
          if [ -z "$BUILD_ID" ]; then
            echo "Failed to parse Cloud Build ID"; exit 1
          fi
          echo "build_id=$BUILD_ID" >> $GITHUB_OUTPUT

      - name: 'Wait for Cloud Build (web)'
        if: steps.cb_web.outputs.build_id != ''
        run: |
          set -euo pipefail
          BUILD_ID="${{ steps.cb_web.outputs.build_id }}"
          echo "Waiting for Cloud Build $BUILD_ID..."
          for i in $(seq 1 240); do
            STATUS=$(gcloud builds describe "$BUILD_ID" --format='value(status)' || echo "UNKNOWN")
            echo "Status: $STATUS"
            case "$STATUS" in
              SUCCESS) exit 0;;
              FAILURE|CANCELLED|INTERNAL_ERROR|TIMEOUT) echo "Build failed: $STATUS"; exit 1;;
              *) sleep 5;;
            esac
          done
          echo "Timeout waiting for Cloud Build"; exit 1

      - name: 'Resolve image digest'
        id: digest_web
        run: |
          # Use gcloud builds describe to get the image digest from the build result
          BUILD_ID="${{ steps.cb_web.outputs.build_id }}"
          DIGEST=$(gcloud builds describe "$BUILD_ID" --format='value(results.images[0].digest)')
          if [ -z "$DIGEST" ]; then
            echo "Failed to get digest from build result, falling back to list-tags"
            DIGEST=$(gcloud container images list-tags gcr.io/${{ vars.GCP_PROJECT_ID }}/web --filter="tags:${{ github.sha }}" --format='get(digest)' --limit=1)
          fi
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: 'Deploy to GKE'
        run: |
          # Ensure namespace and managed certificate
          kubectl apply -f config/kubernetes/base/namespace.yaml
          kubectl -n cloudtolocalllm apply -f gke/managed-certificate.yaml

          # Ensure Web ConfigMap and Secret exist
          kubectl -n cloudtolocalllm apply -f web/k8s/configmap.yaml
          kubectl -n cloudtolocalllm create secret generic web-secrets \
            --from-literal=gcip-api-key='${{ secrets.GCIP_API_KEY }}' \
            --dry-run=client -o yaml | kubectl apply -f -

          # Apply web resources and update image to built digest
          kubectl -n cloudtolocalllm apply -f web/k8s/deployment.yaml
          kubectl -n cloudtolocalllm apply -f web/k8s/service.yaml
          kubectl -n cloudtolocalllm apply -f web/k8s/ingress.yaml
          kubectl -n cloudtolocalllm set image deployment/web web=gcr.io/${{ vars.GCP_PROJECT_ID }}/web@${{ steps.digest_web.outputs.digest }}

  deploy-api:
    name: Deploy API Backend to GKE
    runs-on: ubuntu-latest
    permissions:
      contents: 'read'
      id-token: 'write'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Google Auth
        id: auth
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: '${{ vars.WIF_PROVIDER }}'
          service_account: '${{ vars.WIF_SERVICE_ACCOUNT }}'

      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v2'

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v1
        with:
          cluster_name: 'cloudtolocalllm-us-central1'
          location: 'us-central1'

      - name: 'Build and Push Container (Cloud Build)'
        id: cb_api
        run: |
          set -euo pipefail
          OUT=$(gcloud builds submit --async --tag "gcr.io/${{ vars.GCP_PROJECT_ID }}/api-backend:${{ github.sha }}" services/api-backend 2>&1 | tee /tmp/cb_api.out)
          BUILD_ID=$(echo "$OUT" | grep -oE 'builds/[a-f0-9-]+' | head -n1 | cut -d/ -f2 || true)
          if [ -z "$BUILD_ID" ]; then
            echo "Failed to parse Cloud Build ID"; exit 1
          fi
          echo "build_id=$BUILD_ID" >> $GITHUB_OUTPUT

      - name: 'Wait for Cloud Build (API)'
        if: steps.cb_api.outputs.build_id != ''
        run: |
          set -euo pipefail
          BUILD_ID="${{ steps.cb_api.outputs.build_id }}"
          echo "Waiting for Cloud Build $BUILD_ID..."
          for i in $(seq 1 240); do
            STATUS=$(gcloud builds describe "$BUILD_ID" --format='value(status)' || echo "UNKNOWN")
            echo "Status: $STATUS"
            case "$STATUS" in
              SUCCESS) exit 0;;
              FAILURE|CANCELLED|INTERNAL_ERROR|TIMEOUT) echo "Build failed: $STATUS"; exit 1;;
              *) sleep 5;;
            esac
          done
          echo "Timeout waiting for Cloud Build"; exit 1


      - name: 'Resolve image digest'
        id: digest_api
        run: |
          # Use gcloud builds describe to get the image digest from the build result
          BUILD_ID="${{ steps.cb_api.outputs.build_id }}"
          DIGEST=$(gcloud builds describe "$BUILD_ID" --format='value(results.images[0].digest)')
          if [ -z "$DIGEST" ]; then
            echo "Failed to get digest from build result, falling back to list-tags"
            DIGEST=$(gcloud container images list-tags gcr.io/${{ vars.GCP_PROJECT_ID }}/api-backend --filter="tags:${{ github.sha }}" --format='get(digest)' --limit=1)
          fi
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: 'Resolve DB password'
        id: dbpw
        shell: bash
        run: |
          if [ -n "${{ secrets.DB_PASSWORD }}" ]; then
            echo "value=${{ secrets.DB_PASSWORD }}" >> $GITHUB_OUTPUT
          else
            echo "DB_PASSWORD not set in GitHub Secrets; trying to read from Helm release secret..."
            PW=$(kubectl -n cloudtolocalllm get secret postgresql -o jsonpath='{.data.postgresql-password}' 2>/dev/null | base64 -d || true)
            if [ -z "$PW" ]; then
              echo "Postgres secret not found; generating a strong random password"
              PW=$(openssl rand -base64 32)
            fi
            echo "value=$PW" >> $GITHUB_OUTPUT
          fi

      - name: 'Ensure API secrets exist'
        shell: bash
        run: |
          kubectl create namespace cloudtolocalllm --dry-run=client -o yaml | kubectl apply -f -
          JWT=${{ secrets.JWT_SECRET }}
          if [ -z "$JWT" ]; then JWT=$(openssl rand -base64 48); fi
          kubectl -n cloudtolocalllm create secret generic api-secrets \
            --from-literal=db-password="${{ steps.dbpw.outputs.value }}" \
            --from-literal=jwt-secret="$JWT" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: 'Deploy to GKE'
        run: |
          kubectl apply -f services/api-backend/k8s/deployment.yaml
          kubectl apply -f services/api-backend/k8s/service.yaml
          kubectl apply -f services/api-backend/k8s/ingress.yaml
          kubectl -n cloudtolocalllm set image deployment/api-backend api-backend=gcr.io/${{ vars.GCP_PROJECT_ID }}/api-backend@${{ steps.digest_api.outputs.digest }}

  deploy-streaming:
    name: Deploy Streaming Proxy to GKE
    runs-on: ubuntu-latest
    permissions:
      contents: 'read'
      id-token: 'write'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Google Auth
        id: auth
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: '${{ vars.WIF_PROVIDER }}'
          service_account: '${{ vars.WIF_SERVICE_ACCOUNT }}'

      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v2'

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v1
        with:
          cluster_name: 'cloudtolocalllm-us-central1'
          location: 'us-central1'

      - name: 'Build and Push Container (Cloud Build)'
        id: cb_stream
        run: |
          set -euo pipefail
          OUT=$(gcloud builds submit --async --tag "gcr.io/${{ vars.GCP_PROJECT_ID }}/streaming-proxy:${{ github.sha }}" services/streaming-proxy 2>&1 | tee /tmp/cb_stream.out)
          BUILD_ID=$(echo "$OUT" | grep -oE 'builds/[a-f0-9-]+' | head -n1 | cut -d/ -f2 || true)
          if [ -z "$BUILD_ID" ]; then
            echo "Failed to parse Cloud Build ID"; exit 1
          fi
          echo "build_id=$BUILD_ID" >> $GITHUB_OUTPUT

      - name: 'Wait for Cloud Build (streaming)'
        if: steps.cb_stream.outputs.build_id != ''
        run: |
          set -euo pipefail
          BUILD_ID="${{ steps.cb_stream.outputs.build_id }}"
          echo "Waiting for Cloud Build $BUILD_ID..."
          for i in $(seq 1 240); do
            STATUS=$(gcloud builds describe "$BUILD_ID" --format='value(status)' || echo "UNKNOWN")
            echo "Status: $STATUS"
            case "$STATUS" in
              SUCCESS) exit 0;;
              FAILURE|CANCELLED|INTERNAL_ERROR|TIMEOUT) echo "Build failed: $STATUS"; exit 1;;
              *) sleep 5;;
            esac
          done
          echo "Timeout waiting for Cloud Build"; exit 1

      - name: 'Resolve image digest'
        id: digest_stream
        run: |
          # Use gcloud builds describe to get the image digest from the build result
          BUILD_ID="${{ steps.cb_stream.outputs.build_id }}"
          DIGEST=$(gcloud builds describe "$BUILD_ID" --format='value(results.images[0].digest)')
          if [ -z "$DIGEST" ]; then
            echo "Failed to get digest from build result, falling back to list-tags"
            DIGEST=$(gcloud container images list-tags gcr.io/${{ vars.GCP_PROJECT_ID }}/streaming-proxy --filter="tags:${{ github.sha }}" --format='get(digest)' --limit=1)
          fi
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT

      - name: 'Deploy to GKE'
        run: |
          # Ensure namespace exists
          kubectl apply -f config/kubernetes/base/namespace.yaml

          # Apply streaming resources and update image
          kubectl -n cloudtolocalllm apply -f services/streaming-proxy/k8s/deployment.yaml
          kubectl -n cloudtolocalllm apply -f services/streaming-proxy/k8s/service.yaml
          kubectl -n cloudtolocalllm apply -f services/streaming-proxy/k8s/ingress.yaml
          kubectl -n cloudtolocalllm set image deployment/streaming-proxy streaming-proxy=gcr.io/${{ vars.GCP_PROJECT_ID }}/streaming-proxy@${{ steps.digest_stream.outputs.digest }}

  validate-deployment:
    name: Validate Deployment
    runs-on: ubuntu-latest
    needs: [deploy-web, deploy-api, deploy-streaming]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '24'

      - name: Install dependencies for validation
        run: |
          npm install -g wscat
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Run deployment validation
        env:
          APP_BASE_URL: https://app.cloudtolocalllm.online
          API_BASE_URL: https://api.cloudtolocalllm.online
          STREAMING_BASE_URL: https://streaming.cloudtolocalllm.online
          TEST_JWT_TOKEN: ${{ secrets.TEST_JWT_TOKEN }}
          TEST_USER_ID: ${{ secrets.TEST_USER_ID }}
        run: |
          chmod +x ./scripts/deploy/verify_deployment.sh
          ./scripts/deploy/verify_deployment.sh

      - name: Upload validation results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: validation-results
          path: /tmp/tunnel-validation-*/

  k6-smoke-test:
    name: k6 Smoke Test
    runs-on: ubuntu-latest
    needs: [validate-deployment]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run k6 smoke test
        run: |
          export K6_CLOUD_TOKEN=${{ secrets.K6_CLOUD_TOKEN }}
          k6 run --env API_BASE_URL: https://api.cloudtolocalllm.online test/k6/smoke-test.js

  rollback-on-failure:
    name: Rollback on Validation Failure
    runs-on: ubuntu-latest
    needs: [validate-deployment]
    if: failure() && github.event_name == 'push' # Only rollback on push failures
    permissions:
      contents: 'read'
      id-token: 'write'
    steps:
      - name: Google Auth
        id: auth
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: '${{ vars.WIF_PROVIDER }}'
          service_account: '${{ vars.WIF_SERVICE_ACCOUNT }}'

      - name: 'Set up Cloud SDK'
        uses: 'google-github-actions/setup-gcloud@v2'

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v1
        with:
          cluster_name: 'cloudtolocalllm-us-central1'
          location: 'us-central1'

      - name: Rollback Web Service
        run: kubectl rollout undo deployment/web

      - name: Rollback API Service
        run: kubectl rollout undo deployment/api-backend

      - name: Rollback Streaming Service
        run: kubectl rollout undo deployment/streaming-proxy

      - name: Notify Rollback
        run: |
          echo "## ðŸš¨ Automated Rollback Initiated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Deployment validation failed. An automated rollback to the previous stable version has been performed." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Failed Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY