name: "ðŸ”€ KiloCode Dispatch"

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, reopened, synchronize]
  issues:
    types: [opened, reopened]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      do_managed:
        description: "Deploy to Cloud (Managed)"
        type: boolean
        default: false
      do_local:
        description: "Deploy to Local (Ollama)"
        type: boolean
        default: false
      do_desktop:
        description: "Build for Desktop"
        type: boolean
        default: false
      do_mobile:
        description: "Build for Mobile"
        type: boolean
        default: false
      version_override:
        description: "Override version (e.g. 1.2.3). Leave empty for auto."
        type: string
        required: false

concurrency:
  group: ${{ github.workflow }}-${{ github.sha }}
  cancel-in-progress: true

env:
  AZURE_RESOURCE_GROUP: cloudtolocalllm-rg
  AZURE_CLUSTER_NAME: cloudtolocalllm-aks
  ACR_NAME: imrightguycloudtolocalllm

defaults:
  run:
    shell: "bash"

jobs:
  dispatch:
    if: false
    runs-on: "ubuntu-latest"
    permissions:
      contents: "read"
      issues: "write"
      pull-requests: "write"
    outputs:
      command: "${{ steps.extract_command.outputs.command }}"
      additional_context: "${{ steps.extract_command.outputs.additional_context }}"
    steps:
      - name: "Extract command"
        id: "extract_command"
        uses: "actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea"
        env:
          EVENT_TYPE: "${{ github.event_name }}.${{ github.event.action }}"
          REQUEST: "${{ github.event.comment.body || github.event.review.body || github.event.issue.body || '' }}"
        with:
          script: |
            const eventType = process.env.EVENT_TYPE;
            const request = (process.env.REQUEST || '').trim();
            const eventName = context.eventName;

            if (eventName === 'push' || eventName === 'workflow_dispatch') {
              core.setOutput('command', 'deploy');
            } else if (eventType === 'pull_request.opened') {
              core.setOutput('command', 'review');
            } else if (['issues.opened', 'issues.reopened'].includes(eventType)) {
              core.setOutput('command', 'triage');
            } else if (request.startsWith("@kilocode-cli /review")) {
              core.setOutput('command', 'review');
              core.setOutput('additional_context', request.replace(/^@kilocode-cli \/review/, '').trim());
            } else if (request.startsWith("@kilocode-cli /triage")) {
              core.setOutput('command', 'triage');
            } else if (request.startsWith("@kilocode-cli /deploy")) {
              core.setOutput('command', 'deploy');
              core.setOutput('additional_context', request.replace(/^@kilocode-cli \/deploy/, '').trim());
            } else if (request.startsWith("@kilocode-cli")) {
              core.setOutput('command', 'invoke');
              core.setOutput('additional_context', request.replace(/^@kilocode-cli/, '').trim());
            } else {
              core.setOutput('command', 'fallthrough');
            }

  # Sub-Dispatch Tasks
  review:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'review'
    uses: "./.github/workflows/kilocode-review.yml"
    permissions:
      contents: "read"
      id-token: "write"
      issues: "write"
      pull-requests: "write"
    with:
      additional_context: "${{ needs.dispatch.outputs.additional_context }}"
    secrets: inherit

  triage:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'triage'
    uses: "./.github/workflows/kilocode-triage.yml"
    permissions:
      contents: "read"
      id-token: "write"
      issues: "write"
      pull-requests: "write"
    with:
      additional_context: "${{ needs.dispatch.outputs.additional_context }}"
    secrets: inherit

  invoke:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'invoke'
    uses: "./.github/workflows/kilocode-invoke.yml"
    permissions:
      contents: "write"
      id-token: "write"
      issues: "write"
      pull-requests: "write"
    with:
      additional_context: "${{ needs.dispatch.outputs.additional_context }}"
    secrets: inherit

  orchestrator:
    needs: [dispatch]
    if: needs.dispatch.outputs.command == 'deploy'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    outputs:
      new_version: ${{ steps.exec.outputs.new_version }}
      docker_version: ${{ steps.exec.outputs.docker_version }}
      do_managed: ${{ steps.exec.outputs.do_managed }}
      do_local: ${{ steps.exec.outputs.do_local }}
      do_desktop: ${{ steps.exec.outputs.do_desktop }}
      do_mobile: ${{ steps.exec.outputs.do_mobile }}
      should_deploy: ${{ steps.exec.outputs.should_deploy }}
      reasoning: ${{ steps.exec.outputs.reasoning }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 50
          fetch-tags: true

      - name: "Run Analysis"
        id: "analysis"
        env:
          KILOCODE_API_KEY: "${{ secrets.KILOCODE_API_KEY }}"
        run: |
          # Use kilocode-cli to run analysis
          chmod +x scripts/kilocode-cli.cjs
          if ! ./scripts/kilocode-cli.cjs "Analyze the following project state and determine the release strategy. Return ONLY a valid JSON object with fields: new_version, docker_version, do_managed, do_local, do_desktop, do_mobile, should_deploy, reasoning, version_bump_needed. Context: Version=$(cat assets/version.json), Changes=$(git diff --name-only HEAD~1), Log=$(git log -n 5 --oneline)" --output-format json > raw_output.json 2> kilocode_error.log; then
            echo "::error::KiloCode CLI failed"
            cat kilocode_error.log
            exit 1
          fi
          # Extract response and clean JSON
          CLEAN_JSON=$(cat raw_output.json | jq -r '.response' | sed -n '/{/,/}/p')
          echo "kilocode_output<<EOF" >> $GITHUB_OUTPUT
          echo "$CLEAN_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: "Execute Logic"
        id: "exec"
        env:
          KILOCODE_OUTPUT: "${{ steps.analysis.outputs.kilocode_output }}"
          KILOCODE_API_KEY: "${{ secrets.KILOCODE_API_KEY }}"
        run: |
          set -e
          echo "new_version=$(echo "$KILOCODE_OUTPUT" | jq -r '.new_version')" >> $GITHUB_OUTPUT
          echo "docker_version=$(echo "$KILOCODE_OUTPUT" | jq -r '.docker_version')" >> $GITHUB_OUTPUT
          echo "do_managed=$(echo "$KILOCODE_OUTPUT" | jq -r '.do_managed')" >> $GITHUB_OUTPUT
          echo "do_local=$(echo "$KILOCODE_OUTPUT" | jq -r '.do_local')" >> $GITHUB_OUTPUT
          echo "do_desktop=$(echo "$KILOCODE_OUTPUT" | jq -r '.do_desktop')" >> $GITHUB_OUTPUT
          echo "do_mobile=$(echo "$KILOCODE_OUTPUT" | jq -r '.do_mobile')" >> $GITHUB_OUTPUT
          echo "should_deploy=$(echo "$KILOCODE_OUTPUT" | jq -r '.should_deploy')" >> $GITHUB_OUTPUT
          echo "reasoning=$(echo "$KILOCODE_OUTPUT" | jq -r '.reasoning')" >> $GITHUB_OUTPUT

          if [ "$(echo "$KILOCODE_OUTPUT" | jq -r '.version_bump_needed')" == "true" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            chmod +x scripts/update-all-versions.sh
            ./scripts/update-all-versions.sh "$(echo "$KILOCODE_OUTPUT" | jq -r '.new_version')" "${{ github.sha }}"
            git add -A
            git commit -m "chore: bump version to $(echo "$KILOCODE_OUTPUT" | jq -r '.new_version') [skip ci]"
            git push origin main
          fi

  detect_changes:
    needs: [orchestrator]
    if: needs.orchestrator.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    outputs:
      base: ${{ steps.detect.outputs.base }}
      changes: ${{ steps.detect.outputs.changes }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Detect Service Changes
        id: detect
        run: |
          set -e
          set -x
          PREV_TAG=$(git tag -l "*-cloud-*" --sort=-version:refname | head -n 1 || echo "")

          # Initialize JSON array for changes
          CHANGES="[]"

          # Helper to add service to changes array
          add_change() {
            CHANGES=$(echo "$CHANGES" | jq --arg s "$1" '. + [$s]')
          }

          if [ -z "$PREV_TAG" ]; then
            echo "No previous tag found. Deploying all."
            echo "base=true" >> $GITHUB_OUTPUT
            CHANGES='["postgres", "web", "api", "proxy"]'
            echo "changes=$CHANGES" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Comparing HEAD against $PREV_TAG"

          # Capture changes in a variable to avoid pipe exit code issues
          DIFF_FILES=$(git diff --name-only $PREV_TAG HEAD)
          echo "Diff:"
          echo "$DIFF_FILES"

          if echo "$DIFF_FILES" | grep -qE '^config/docker/Dockerfile\.base'; then
             echo "base=true" >> $GITHUB_OUTPUT
          else
             echo "base=false" >> $GITHUB_OUTPUT
          fi

          if echo "$DIFF_FILES" | grep -qE '^config/docker/Dockerfile\.postgres'; then
            add_change "postgres"
          fi

          if echo "$DIFF_FILES" | grep -qE '^(web|lib|pubspec\.)'; then
            add_change "web"
          fi

          if echo "$DIFF_FILES" | grep -qE '^services/api-backend'; then
            add_change "api"
          fi

          if echo "$DIFF_FILES" | grep -qE '^services/streaming-proxy'; then
            add_change "proxy"
          fi

          echo "changes=$CHANGES" >> $GITHUB_OUTPUT

  infrastructure:
    needs: [orchestrator, detect_changes]
    if: needs.orchestrator.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

  build_base:
    needs: [orchestrator, detect_changes, infrastructure]
    if: needs.detect_changes.outputs.base == 'true'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Build and Push Base
        run: |
          az acr login --name ${{ env.ACR_NAME }}
          docker build -f config/docker/Dockerfile.base -t ${{ env.ACR_NAME }}.azurecr.io/base:latest -t ${{ env.ACR_NAME }}.azurecr.io/base:main-${{ github.sha }} .
          docker push ${{ env.ACR_NAME }}.azurecr.io/base:latest
          docker push ${{ env.ACR_NAME }}.azurecr.io/base:main-${{ github.sha }}

  build_postgres:
    needs: [orchestrator, detect_changes, infrastructure, build_base]
    if: (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') && contains(needs.detect_changes.outputs.changes, 'postgres')
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Build and Push Postgres
        run: |
          az acr login --name ${{ env.ACR_NAME }}
          docker build -f config/docker/Dockerfile.postgres --build-arg BASE_REGISTRY=${{ env.ACR_NAME }}.azurecr.io -t ${{ env.ACR_NAME }}.azurecr.io/postgres:latest -t ${{ env.ACR_NAME }}.azurecr.io/postgres:main-${{ github.sha }} .
          docker push ${{ env.ACR_NAME }}.azurecr.io/postgres:latest
          docker push ${{ env.ACR_NAME }}.azurecr.io/postgres:main-${{ github.sha }}

  build_web:
    needs: [orchestrator, detect_changes, infrastructure, build_base]
    if: (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') && contains(needs.detect_changes.outputs.changes, 'web')
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Build and Push Web
        run: |
          az acr login --name ${{ env.ACR_NAME }}
          docker build -f config/docker/Dockerfile.web -t ${{ env.ACR_NAME }}.azurecr.io/web:latest -t ${{ env.ACR_NAME }}.azurecr.io/web:main-${{ github.sha }} .
          docker push ${{ env.ACR_NAME }}.azurecr.io/web:latest
          docker push ${{ env.ACR_NAME }}.azurecr.io/web:main-${{ github.sha }}

  build_api:
    needs: [orchestrator, detect_changes, infrastructure, build_base]
    if: (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') && contains(needs.detect_changes.outputs.changes, 'api')
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Build and Push API
        run: |
          az acr login --name ${{ env.ACR_NAME }}
          docker build -f config/docker/Dockerfile.api-backend -t ${{ env.ACR_NAME }}.azurecr.io/api-backend:latest -t ${{ env.ACR_NAME }}.azurecr.io/api-backend:main-${{ github.sha }} .
          docker push ${{ env.ACR_NAME }}.azurecr.io/api-backend:latest
          docker push ${{ env.ACR_NAME }}.azurecr.io/api-backend:main-${{ github.sha }}

  build_proxy:
    needs: [orchestrator, detect_changes, infrastructure, build_base]
    if: (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') && contains(needs.detect_changes.outputs.changes, 'proxy')
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Build and Push Proxy
        run: |
          az acr login --name ${{ env.ACR_NAME }}
          docker build -f config/docker/Dockerfile.streaming-proxy -t ${{ env.ACR_NAME }}.azurecr.io/streaming-proxy:latest -t ${{ env.ACR_NAME }}.azurecr.io/streaming-proxy:main-${{ github.sha }} .
          docker push ${{ env.ACR_NAME }}.azurecr.io/streaming-proxy:latest
          docker push ${{ env.ACR_NAME }}.azurecr.io/streaming-proxy:main-${{ github.sha }}

  promote:
    needs:
      [
        orchestrator,
        detect_changes,
        infrastructure,
        build_postgres,
        build_web,
        build_api,
        build_proxy,
      ]
    if: always() && needs.orchestrator.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Set up kubelogin for non-interactive login
        uses: azure/use-kubelogin@v1
        with:
          kubelogin-version: "v0.0.25"

      - name: Get AKS Credentials
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.AZURE_RESOURCE_GROUP }}
          cluster-name: ${{ env.AZURE_CLUSTER_NAME }}
          admin: "false"
          use-kubelogin: "true"

      - name: Update Deployments
        run: |
          CHANGES='${{ needs.detect_changes.outputs.changes }}'

          # API Backend
          if echo "$CHANGES" | grep -q "api"; then
            kubectl set image deployment/api-backend api-backend=${{ env.ACR_NAME }}.azurecr.io/api-backend:main-${{ github.sha }} -n cloudtolocalllm
            kubectl set image deployment/api-backend db-migrate=${{ env.ACR_NAME }}.azurecr.io/api-backend:main-${{ github.sha }} -n cloudtolocalllm
          fi

          # Web
          if echo "$CHANGES" | grep -q "web"; then
            kubectl set image deployment/web web=${{ env.ACR_NAME }}.azurecr.io/web:main-${{ github.sha }} -n cloudtolocalllm
          fi

          # Streaming Proxy
          if echo "$CHANGES" | grep -q "proxy"; then
             kubectl set image deployment/streaming-proxy streaming-proxy=${{ env.ACR_NAME }}.azurecr.io/streaming-proxy:main-${{ github.sha }} -n cloudtolocalllm
          fi

          # Postgres (Optional - commented out for safety)
          # if echo "$CHANGES" | grep -q "postgres"; then
          #   kubectl set image statefulset/postgres postgres=${{ env.ACR_NAME }}.azurecr.io/postgres:main-${{ github.sha }} -n cloudtolocalllm
          # fi

          kubectl rollout status deployment/api-backend -n cloudtolocalllm --timeout=300s || echo "API rollout failed or timed out"
          kubectl rollout status deployment/web -n cloudtolocalllm --timeout=300s || echo "Web rollout failed or timed out"
