name: "ðŸ”€ KiloCode Dispatch"

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, reopened, synchronize]
  issues:
    types: [opened, reopened]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      do_managed:
        description: "Deploy to Cloud (Managed)"
        type: boolean
        default: false
      do_local:
        description: "Deploy to Local (Ollama)"
        type: boolean
        default: false
      do_desktop:
        description: "Build for Desktop"
        type: boolean
        default: true
      do_mobile:
        description: "Build for Mobile"
        type: boolean
        default: true
      version_override:
        description: "Override version (e.g. 1.2.3). Leave empty for auto."
        type: string
        required: false

concurrency:
  group: ${{ github.workflow }}-${{ github.sha }}
  cancel-in-progress: true

env:
  AZURE_RESOURCE_GROUP: cloudtolocalllm-rg
  AZURE_CLUSTER_NAME: cloudtolocalllm-aks
  ACR_NAME: imrightguycloudtolocalllm
  SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
  DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}

defaults:
  run:
    shell: "bash"

jobs:
  dispatch:
    runs-on: "ubuntu-latest"
    permissions:
      contents: "read"
      issues: "write"
      pull-requests: "write"
    outputs:
      command: "${{ steps.extract_command.outputs.command }}"
      additional_context: "${{ steps.extract_command.outputs.additional_context }}"
      start_time: "${{ steps.extract_command.outputs.start_time }}"
      do_desktop: "${{ github.event.inputs.do_desktop || 'true' }}"
      do_mobile: "${{ github.event.inputs.do_mobile || 'true' }}"
    steps:
      - name: "Extract command"
        id: "extract_command"
        uses: "actions/github-script@v6"
        env:
          EVENT_TYPE: "${{ github.event_name }}.${{ github.event.action }}"
          REQUEST: "${{ github.event.comment.body || github.event.review.body || github.event.issue.body || '' }}"
        with:
          script: |
            const eventType = process.env.EVENT_TYPE;
            const request = (process.env.REQUEST || '').trim();
            const eventName = context.eventName;

            core.setOutput('start_time', new Date().toISOString());

            if (eventName === 'push' || eventName === 'workflow_dispatch') {
              core.setOutput('command', 'deploy');
            } else if (eventType === 'pull_request.opened') {
              core.setOutput('command', 'review');
            } else if (['issues.opened', 'issues.reopened'].includes(eventType)) {
              core.setOutput('command', 'triage');
            } else if (request.startsWith("@kilocode-cli /review")) {
              core.setOutput('command', 'review');
              core.setOutput('additional_context', request.replace(/^@kilocode-cli \/review/, '').trim());
            } else if (request.startsWith("@kilocode-cli /triage")) {
              core.setOutput('command', 'triage');
            } else if (request.startsWith("@kilocode-cli /deploy")) {
              core.setOutput('command', 'deploy');
              core.setOutput('additional_context', request.replace(/^@kilocode-cli \/deploy/, '').trim());
            } else if (request.startsWith("@kilocode-cli")) {
              core.setOutput('command', 'invoke');
              core.setOutput('additional_context', request.replace(/^@kilocode-cli/, '').trim());
            } else {
              core.setOutput('command', 'fallthrough');
            }

  orchestrator:
    needs: [dispatch]
    if: needs.dispatch.outputs.command == 'deploy'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    outputs:
      should_deploy: ${{ steps.exec.outputs.should_deploy }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}
          fetch-depth: 50
      - name: "Simple Orchestration"
        id: "exec"
        run: echo "should_deploy=true" >> $GITHUB_OUTPUT

  detect_changes:
    needs: [orchestrator]
    if: needs.orchestrator.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    outputs:
      changes: ${{ steps.detect.outputs.changes }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Detect Service Changes
        id: detect
        run: |
          CHANGES="web,api,proxy,postgres" 
          echo "changes=$CHANGES" >> $GITHUB_OUTPUT

  build_postgres:
    needs: [orchestrator, detect_changes]
    if: contains(needs.detect_changes.outputs.changes, 'postgres')
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Build and Push Postgres
        run: |
          az acr login --name ${{ env.ACR_NAME }}
          docker build -f config/docker/Dockerfile.postgres --build-arg BASE_REGISTRY=${{ env.ACR_NAME }}.azurecr.io -t ${{ env.ACR_NAME }}.azurecr.io/postgres:latest -t ${{ env.ACR_NAME }}.azurecr.io/postgres:main-${{ github.sha }} .
          docker push ${{ env.ACR_NAME }}.azurecr.io/postgres:latest
          docker push ${{ env.ACR_NAME }}.azurecr.io/postgres:main-${{ github.sha }}

  build_web:
    needs: [orchestrator, detect_changes]
    if: contains(needs.detect_changes.outputs.changes, 'web')
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Build and Push Web
        run: |
          az acr login --name ${{ env.ACR_NAME }}
          docker build -f config/docker/Dockerfile.web -t ${{ env.ACR_NAME }}.azurecr.io/web:latest -t ${{ env.ACR_NAME }}.azurecr.io/web:main-${{ github.sha }} .
          docker push ${{ env.ACR_NAME }}.azurecr.io/web:latest
          docker push ${{ env.ACR_NAME }}.azurecr.io/web:main-${{ github.sha }}

  build_api:
    needs: [orchestrator, detect_changes]
    if: contains(needs.detect_changes.outputs.changes, 'api')
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Build and Push API
        run: |
          az acr login --name ${{ env.ACR_NAME }}
          docker build -f config/docker/Dockerfile.api-backend -t ${{ env.ACR_NAME }}.azurecr.io/api-backend:latest -t ${{ env.ACR_NAME }}.azurecr.io/api-backend:main-${{ github.sha }} .
          docker push ${{ env.ACR_NAME }}.azurecr.io/api-backend:latest
          docker push ${{ env.ACR_NAME }}.azurecr.io/api-backend:main-${{ github.sha }}

  build_proxy:
    needs: [orchestrator, detect_changes]
    if: contains(needs.detect_changes.outputs.changes, 'proxy')
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Build and Push Proxy
        run: |
          az acr login --name ${{ env.ACR_NAME }}
          docker build -f config/docker/Dockerfile.streaming-proxy -t ${{ env.ACR_NAME }}.azurecr.io/streaming-proxy:latest -t ${{ env.ACR_NAME }}.azurecr.io/streaming-proxy:main-${{ github.sha }} .
          docker push ${{ env.ACR_NAME }}.azurecr.io/streaming-proxy:latest
          docker push ${{ env.ACR_NAME }}.azurecr.io/streaming-proxy:main-${{ github.sha }}

  build_desktop:
    needs: [dispatch, orchestrator]
    if: needs.orchestrator.outputs.should_deploy == 'true' && needs.dispatch.outputs.do_desktop == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.x'
          channel: 'stable'
      - name: Install Linux dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y clang cmake ninja-build pkg-config libgtk-3-dev liblzma-dev libsecret-1-dev
      - name: Build Linux Desktop
        run: |
          flutter pub get
          flutter build linux --release
      - name: Upload Linux Artifact
        uses: actions/upload-artifact@v4
        with:
          name: desktop-linux
          path: build/linux/x64/release/bundle/

  build_mobile:
    needs: [dispatch, orchestrator]
    if: needs.orchestrator.outputs.should_deploy == 'true' && needs.dispatch.outputs.do_mobile == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.x'
          channel: 'stable'
      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'
      - name: Build Android App Bundle
        run: |
          flutter pub get
          flutter build appbundle --release
      - name: Upload Android Artifact
        uses: actions/upload-artifact@v4
        with:
          name: mobile-android
          path: build/app/outputs/bundle/release/app-release.aab

  promote:
    needs: [build_web, build_api, build_proxy, build_postgres]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}
      
      - name: Promote to Argo CD (GitOps)
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          TAG="main-${{ github.sha }}"
          
          # Update Kustomize image tags
          sed -i "s|newTag: .*|newTag: $TAG-api-backend|g" k8s/apps/managed/api-backend/kustomization.yaml
          sed -i "s|newTag: .*|newTag: $TAG|g" k8s/apps/managed/web-frontend/kustomization.yaml
          
          # Attempt to update streaming proxy if present (best effort)
          grep -r "streaming-proxy" k8s/apps/managed/ && sed -i "s|newTag: .*streaming-proxy.*|newTag: $TAG-streaming-proxy|g" $(grep -r "streaming-proxy" k8s/apps/managed/ -l)

          git add k8s/apps/managed/
          if ! git diff --cached --quiet; then
            git commit -m "chore(deploy): promote version $TAG [skip ci]"
            git pull --rebase origin main
            git push origin main
            echo "âœ… Successfully promoted version $TAG to Argo CD"
          else
            echo "No changes to promote"
          fi

  notify:
    needs: [promote, build_desktop, build_mobile]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Determine Status
        id: status
        run: |
          if [ "${{ needs.promote.result }}" == "success" ]; then
             echo "emoji=âœ…" >> $GITHUB_OUTPUT
             echo "status=Success" >> $GITHUB_OUTPUT
          else
             echo "emoji=âŒ" >> $GITHUB_OUTPUT
             echo "status=Failure" >> $GITHUB_OUTPUT
          fi
      - name: Send Slack notification
        if: env.SLACK_WEBHOOK_URL != ''
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ env.SLACK_WEBHOOK_URL }}
          SLACK_TITLE: "${{ steps.status.outputs.emoji }} Deployment Status"
          SLACK_MESSAGE: "Deploy ${{ steps.status.outputs.status }} - SHA: ${{ github.sha }}"