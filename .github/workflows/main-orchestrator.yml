name: "ðŸ”€ Main Orchestrator"

on:
  push:
    branches: [main, "fix/*", "feat/*"]
    paths-ignore:
      - "assets/version.json"
      - "pubspec.yaml"
      - "package.json"
  pull_request:
    types: [opened, reopened, synchronize]
  issues:
    types: [opened, reopened]
  issue_comment:
    types: [created]

concurrency:
  group: ${{ github.workflow }}-${{ github.sha }}
  cancel-in-progress: true

env:
  SENTRY_DSN: ${{ secrets.SENTRY_DSN }}

defaults:
  run:
    shell: bash

jobs:
  dispatch:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: "${{ github.actor != 'github-actions[bot]' && !startsWith(github.event.head_commit.message, 'chore: bump version') && !startsWith(github.event.head_commit.message, 'chore(deploy): promote') }}"
    permissions:
      contents: read
      issues: write
      pull-requests: write
    outputs:
      command: ${{ steps.extract_command.outputs.command }}
      additional_context: ${{ steps.extract_command.outputs.additional_context }}
    steps:
      - name: Extract command
        id: extract_command
        uses: actions/github-script@v7
        env:
          EVENT_TYPE: "${{ github.event_name }}.${{ github.event.action }}"
          COMMENT_BODY: "${{ github.event.comment.body }}"
          REVIEW_BODY: "${{ github.event.review.body }}"
          ISSUE_BODY: "${{ github.event.issue.body }}"
        with:
          script: |
            const eventType = process.env.EVENT_TYPE;
            const commentBody = process.env.COMMENT_BODY;
            const reviewBody = process.env.REVIEW_BODY;
            const issueBody = process.env.ISSUE_BODY;
            const request = (commentBody || reviewBody || issueBody || '').trim();
            const eventName = context.eventName;

            if (eventName === 'push') {
              core.setOutput('command', 'orchestrate');
            } else if (eventType === 'pull_request.opened') {
              core.setOutput('command', 'review');
            } else if (['issues.opened', 'issues.reopened'].includes(eventType)) {
              core.setOutput('command', 'triage');
            } else if (request.startsWith("@ai-agent /review")) {
              core.setOutput('command', 'review');
              core.setOutput('additional_context', request.replace(/^@ai-agent \/review/, '').trim());
            } else if (request.startsWith("@ai-agent /triage")) {
              core.setOutput('command', 'triage');
            } else if (request.startsWith("@ai-agent /deploy")) {
              core.setOutput('command', 'orchestrate');
              core.setOutput('additional_context', request.replace(/^@ai-agent \/deploy/, '').trim());
            } else if (request.startsWith("@ai-agent")) {
              core.setOutput('command', 'invoke');
              core.setOutput('additional_context', request.replace(/^@ai-agent/, '').trim());
            } else {
              core.setOutput('command', 'fallthrough');
            }

  review:
    needs: dispatch
    if: ${{ needs.dispatch.outputs.command == 'review' }}
    uses: ./.github/workflows/ai-review.yml
    with:
      additional_context: ${{ needs.dispatch.outputs.additional_context }}
    secrets: inherit

  triage:
    needs: dispatch
    if: ${{ needs.dispatch.outputs.command == 'triage' }}
    uses: ./.github/workflows/ai-triage.yml
    with:
      additional_context: ${{ needs.dispatch.outputs.additional_context }}
    secrets: inherit

  invoke:
    needs: dispatch
    if: ${{ needs.dispatch.outputs.command == 'invoke' }}
    uses: ./.github/workflows/ai-task.yml
    with:
      additional_context: ${{ needs.dispatch.outputs.additional_context }}
    secrets: inherit

  orchestrate:
    needs: dispatch
    if: ${{ needs.dispatch.outputs.command == 'orchestrate' }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}
          fetch-depth: 50
          fetch-tags: true

      - name: Orchestration Logic
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          set -e
          
          # Ensure local gemini CLI is usable
          if [ -f scripts/gemini-cli.cjs ]; then
            chmod +x scripts/gemini-cli.cjs
            sudo ln -sf "$(pwd)/scripts/gemini-cli.cjs" /usr/local/bin/gemini
          fi

          VERSION=$(cat assets/version.json | jq -r '.version' || echo "7.0.0")
          COMMIT_MSG=$(git log -1 --pretty=%B)
          
          BUMP_NEEDED="false"
          NEW_VERSION="$VERSION"

          if ! command -v gemini &> /dev/null; then
              echo "âŒ ERROR: gemini command not found. Strict orchestration requires Gemini."
              exit 1
          fi

          echo "Running Gemini analysis..."
          # FAIL FAST: Removed fallback logic. If Gemini fails, script fails.
          gemini "Analyze the latest changes and decide if a release is needed. Version=$VERSION. Commit message: $COMMIT_MSG. Respond ONLY with a JSON object like {\"version_bump_needed\": boolean, \"new_version\": \"string\"}." > raw_output.json

          # Debug: show raw output
          cat raw_output.json

          # Output is now cleaned by the CLI script
          CLEAN_RESPONSE=$(cat raw_output.json)
          
          # Fallback: if empty, try just reading the file (if it was pure JSON)
          if [ -z "$CLEAN_RESPONSE" ]; then
             CLEAN_RESPONSE=$(cat raw_output.json)
          fi

          echo "Cleaned response: $CLEAN_RESPONSE"

          BUMP_NEEDED=$(echo "$CLEAN_RESPONSE" | jq -r '.version_bump_needed' | xargs)
          NEW_VERSION=$(echo "$CLEAN_RESPONSE" | jq -r '.new_version' | xargs)

          if [ "$BUMP_NEEDED" == "null" ] || [ "$NEW_VERSION" == "null" ]; then
              echo "âŒ ERROR: Gemini returned null values or invalid JSON. Strict orchestration failed."
              exit 1
          fi

          if [ "$BUMP_NEEDED" == "true" ]; then
            echo "Bumping version to $NEW_VERSION"
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            tmp=$(mktemp)
            jq --arg v "$NEW_VERSION" '.version = $v' assets/version.json > "$tmp" && mv "$tmp" assets/version.json
            
            if [ -f scripts/update-all-versions.sh ]; then
                chmod +x scripts/update-all-versions.sh
                ./scripts/update-all-versions.sh "$NEW_VERSION" "${{ github.sha }}"
            fi
            
            git add -A
            git commit -m "chore: bump version to $NEW_VERSION"
            
            # Robust push with retry
            MAX_RETRIES=5
            COUNT=0
            while [ $COUNT -lt $MAX_RETRIES ]; do
              if git push origin main; then
                break
              fi
              COUNT=$((COUNT + 1))
              echo "Push failed, retrying ($COUNT/$MAX_RETRIES)..."
              git pull --rebase origin main
              sleep 5
            done
            if [ $COUNT -eq $MAX_RETRIES ]; then
              echo "âŒ ERROR: Failed to push version bump after $MAX_RETRIES attempts."
              exit 1
            fi

            echo "Triggering build for bumped version on main..."
            # Construct full payload with client_payload wrapper
            jq -n \
              --arg event "orchestrator-build" \
              --arg ref "refs/heads/main" \
              '{event_type: $event, client_payload: {ref: $ref}}' > payload.json
              
            gh api repos/${{ github.repository }}/dispatches --input payload.json
          else
            echo "Triggering build for current ref..."
            # Construct full payload with client_payload wrapper
            jq -n \
              --arg event "orchestrator-build" \
              --arg ref "${{ github.ref }}" \
              '{event_type: $event, client_payload: {ref: $ref}}' > payload.json
              
            gh api repos/${{ github.repository }}/dispatches --input payload.json
          fi
