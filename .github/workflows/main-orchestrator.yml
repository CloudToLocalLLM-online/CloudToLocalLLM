name: "ðŸ”€ Main Orchestrator"

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, reopened, synchronize]
  issues:
    types: [opened, reopened]
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      do_managed:
        description: "Deploy to Cloud (Managed)"
        type: boolean
        default: false
      do_local:
        description: "Deploy to Local (Ollama)"
        type: boolean
        default: false
      do_desktop:
        description: "Build for Desktop"
        type: boolean
        default: true
      do_mobile:
        description: "Build for Mobile"
        type: boolean
        default: true
      version_override:
        description: "Override version (e.g. 1.2.3). Leave empty for auto."
        type: string
        required: false

concurrency:
  group: ${{ github.workflow }}-${{ github.sha }}
  cancel-in-progress: true

env:
  SENTRY_DSN: ${{ secrets.SENTRY_DSN }}

defaults:
  run:
    shell: "bash"

jobs:
  dispatch:
    runs-on: "ubuntu-latest"
    permissions:
      contents: "read"
      issues: "write"
      pull-requests: "write"
    outputs:
      command: "${{ steps.extract_command.outputs.command }}"
      additional_context: "${{ steps.extract_command.outputs.additional_context }}"
      do_desktop: "${{ github.event.inputs.do_desktop || 'true' }}"
      do_mobile: "${{ github.event.inputs.do_mobile || 'true' }}"
    steps:
      - name: "Extract command"
        id: "extract_command"
        uses: "actions/github-script@v7"
        env:
          EVENT_TYPE: "${{ github.event_name }}.${{ github.event.action }}"
          REQUEST: "${{ github.event.comment.body || github.event.review.body || github.event.issue.body || '' }}"
        with:
          script: |
            const eventType = process.env.EVENT_TYPE;
            const request = (process.env.REQUEST || '').trim();
            const eventName = context.eventName;

            if (eventName === 'push' || eventName === 'workflow_dispatch') {
              core.setOutput('command', 'deploy');
            } else if (eventType === 'pull_request.opened') {
              core.setOutput('command', 'review');
            } else if (['issues.opened', 'issues.reopened'].includes(eventType)) {
              core.setOutput('command', 'triage');
            } else if (request.startsWith("@ai-agent /review")) {
              core.setOutput('command', 'review');
              core.setOutput('additional_context', request.replace(/^@ai-agent \/review/, '').trim());
            } else if (request.startsWith("@ai-agent /triage")) {
              core.setOutput('command', 'triage');
            } else if (request.startsWith("@ai-agent /deploy")) {
              core.setOutput('command', 'deploy');
              core.setOutput('additional_context', request.replace(/^@ai-agent \/deploy/, '').trim());
            } else if (request.startsWith("@ai-agent")) {
              core.setOutput('command', 'invoke');
              core.setOutput('additional_context', request.replace(/^@ai-agent/, '').trim());
            } else {
              core.setOutput('command', 'fallthrough');
            }

  # Sub-Dispatch Tasks
  review:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'review'
    uses: "./.github/workflows/ai-review.yml"
    with:
      additional_context: "${{ needs.dispatch.outputs.additional_context }}"
    secrets: inherit

  triage:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'triage'
    uses: "./.github/workflows/ai-triage.yml"
    with:
      additional_context: "${{ needs.dispatch.outputs.additional_context }}"
    secrets: inherit

  invoke:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'invoke'
    uses: "./.github/workflows/ai-task.yml"
    with:
      additional_context: "${{ needs.dispatch.outputs.additional_context }}"
    secrets: inherit

  # Orchestrator Job: Analyzes project state and decides on release strategy
  orchestrator:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'deploy'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    outputs:
      should_deploy: ${{ steps.exec.outputs.should_deploy }}
      new_version: ${{ steps.exec.outputs.new_version }}
      do_desktop: ${{ steps.exec.outputs.do_desktop }}
      do_mobile: ${{ steps.exec.outputs.do_mobile }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}
          fetch-depth: 50
          fetch-tags: true

      - name: "Run AI Analysis"
        id: "analysis"
        env:
          KILOCODE_API_KEY: "${{ secrets.KILOCODE_API_KEY }}"
        run: |
          chmod +x scripts/ai-agent.cjs

          # Gather context
          VERSION=$(cat assets/version.json | jq -r '.version' || echo "7.0.0")
          COMMIT_MSG=$(git log -1 --pretty=%B)

          if [[ "$COMMIT_MSG" == *"chore: bump version"* ]]; then
            echo "::notice::Detected version bump commit. Skipping analysis and enforcing deployment."
            # Create a synthetic JSON response that triggers deployment but NO bump
            # We assume if we just bumped, we want to deploy the current version
            echo '{"response": "{\"should_deploy\": true, \"version_bump_needed\": false, \"new_version\": \"'$VERSION'\", \"do_desktop\": true, \"do_mobile\": true, \"reasoning\": \"Version bump commit detected. Proceeding to deploy.\"}"}' > raw_output.json
          else
            CHANGES=$(git diff --name-only HEAD~1 | tr '\n' ',' || echo "none")
            LOG=$(git log -n 5 --oneline | tr '\n' ';')
            
            PROMPT="Analyze the following project state and determine the release strategy. Return ONLY a valid JSON object with fields: new_version, docker_version, do_managed, do_local, do_desktop, do_mobile, should_deploy, reasoning, version_bump_needed. Context: Version=$VERSION, Changes=$CHANGES, Log=$LOG"
            
            # Run CLI
            if ! ./scripts/ai-agent.cjs "$PROMPT" --output-format json > raw_output.json 2> ai_error.log; then
              echo "::warning::AI Agent failed, falling back to basic deployment"
              cat ai_error.log
              # Fallback JSON
              echo '{"response": "{\"should_deploy\": true, \"version_bump_needed\": false, \"new_version\": \"'$VERSION'\", \"do_desktop\": true, \"do_mobile\": true}"}' > raw_output.json
            fi
          fi

          # Extract response and ensure it's a single-line clean JSON
          jq -c '.response | fromjson' raw_output.json > clean_response.json
          echo "ai_output=$(cat clean_response.json)" >> $GITHUB_OUTPUT

      - name: "Execute Logic & Version Bump"
        id: "exec"
        env:
          AI_OUTPUT: "${{ steps.analysis.outputs.ai_output }}"
        run: |
          set -e

          # Parse outputs
          SHOULD_DEPLOY=$(echo "$AI_OUTPUT" | jq -r '.should_deploy')
          NEW_VERSION=$(echo "$AI_OUTPUT" | jq -r '.new_version')
          BUMP_NEEDED=$(echo "$AI_OUTPUT" | jq -r '.version_bump_needed')
          DO_DESKTOP=$(echo "$AI_OUTPUT" | jq -r '.do_desktop // true')
          DO_MOBILE=$(echo "$AI_OUTPUT" | jq -r '.do_mobile // true')

          echo "should_deploy=$(echo $SHOULD_DEPLOY | xargs)" >> $GITHUB_OUTPUT
          echo "new_version=$(echo $NEW_VERSION | xargs)" >> $GITHUB_OUTPUT

          # Override inputs if provided manually via workflow_dispatch
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
             echo "do_desktop=${{ github.event.inputs.do_desktop || 'true' }}" >> $GITHUB_OUTPUT
             echo "do_mobile=${{ github.event.inputs.do_mobile || 'true' }}" >> $GITHUB_OUTPUT
          else
             # Use portable xargs for trimming
             FINAL_DESKTOP=$(echo "$DO_DESKTOP" | xargs)
             FINAL_MOBILE=$(echo "$DO_MOBILE" | xargs)
             echo "do_desktop=$FINAL_DESKTOP" >> $GITHUB_OUTPUT
             echo "do_mobile=$FINAL_MOBILE" >> $GITHUB_OUTPUT
          fi

          if [ "$BUMP_NEEDED" == "true" ]; then
            echo "Bumping version to $NEW_VERSION"
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            # Proper JSON update using jq
            tmp=$(mktemp)
            jq --arg v "$NEW_VERSION" '.version = $v' assets/version.json > "$tmp" && mv "$tmp" assets/version.json
            
            # Use script if available
            if [ -f scripts/update-all-versions.sh ]; then
                chmod +x scripts/update-all-versions.sh
                ./scripts/update-all-versions.sh "$NEW_VERSION" "${{ github.sha }}"
            fi
            
            git add -A
            # Remove skip ci to trigger "every push" as requested, but we'll use GitOps SHA for building
            git commit -m "chore: bump version to $NEW_VERSION"
            git push origin main
          fi

      - name: "Debug GITHUB_OUTPUT"
        if: always()
        run: |
          echo "=== CONTENT OF GITHUB_OUTPUT ==="
          cat "$GITHUB_OUTPUT" || echo "File not found or empty"
          echo "=== END CONTENT ==="
          echo "=== JOB CONTEXT OUTPUTS ==="
          echo '${{ toJSON(steps.exec.outputs) }}'
          echo "=== END JOB CONTEXT ==="

      - name: "Debug Outputs"
        run: |
          echo "Should Deploy: ${{ steps.exec.outputs.should_deploy }}"
          echo "New Version: ${{ steps.exec.outputs.new_version }}"
          echo "Do Desktop: ${{ steps.exec.outputs.do_desktop }}"
          echo "Do Mobile: ${{ steps.exec.outputs.do_mobile }}"

  build_and_push:
    needs: orchestrator
    if: needs.orchestrator.outputs.should_deploy == 'true'
    uses: ./.github/workflows/build-pipeline.yml
    with:
      do_desktop: ${{ needs.orchestrator.outputs.do_desktop == 'true' }}
      do_mobile: ${{ needs.orchestrator.outputs.do_mobile == 'true' }}
      sha: ${{ github.sha }}
    secrets: inherit

  promote_to_gitops:
    needs: [orchestrator, build_and_push]
    if: always() && needs.orchestrator.outputs.should_deploy == 'true' && (needs.build_and_push.result == 'success' || needs.build_and_push.result == 'skipped')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN }}
          ref: main # Always promote on main

      - name: Promote to Argo CD (GitOps)
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          SHA="${{ github.sha }}"
          TAG="main-${SHA}"

          # Update Kustomize image tags
          sed -i "s|newTag: .*|newTag: $TAG-api-backend|g" k8s/apps/managed/api-backend/kustomization.yaml
          sed -i "s|newTag: .*|newTag: $TAG|g" k8s/apps/managed/web-frontend/kustomization.yaml

          # Attempt to update streaming proxy if present
          grep -r "streaming-proxy" k8s/apps/managed/ && sed -i "s|newTag: .*streaming-proxy.*|newTag: $TAG-streaming-proxy|g" $(grep -r "streaming-proxy" k8s/apps/managed/ -l) || echo "Streaming proxy tag not found in kustomization"

          git add k8s/apps/managed/
          if ! git diff --cached --quiet; then
            git commit -m "chore(deploy): promote version $TAG [skip ci]"
            git pull --rebase origin main
            git push origin main
            echo "âœ… Successfully promoted version $TAG to Argo CD"
          else
            echo "No changes to promote"
          fi
