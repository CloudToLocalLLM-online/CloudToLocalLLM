name: Deploy to AWS EKS

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches: [main]
    paths:
      - "lib/**"
      - "services/**"
      - "k8s/**"
      - "web/**"
      - "scripts/**"
      - ".github/workflows/deploy-aws-eks.yml"
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - development
          - staging
          - production

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: cloudtolocalllm-eks
  DOCKER_REGISTRY: cloudtolocalllm

jobs:
  build_builder:
    name: Build Universal Builder
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and push Builder image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./config/docker/Dockerfile.builder
          push: true
          tags: ${{ env.DOCKER_REGISTRY }}/builder:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/builder:latest
          cache-to: type=inline

  build_images:
    name: Build Runtime Images
    needs: build_builder
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and push web app image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./web/Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/web:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/web:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/web:latest
          cache-to: type=inline

      - name: Build and push API backend image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./services/api-backend/Dockerfile.prod
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/api-backend:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/api-backend:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/api-backend:latest
          cache-to: type=inline

      - name: Build and push Streaming Proxy image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./services/streaming-proxy/Dockerfile.prod
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/streaming-proxy:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/streaming-proxy:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/streaming-proxy:latest
          cache-to: type=inline

  deploy:
    name: Deploy to EKS
    needs: build_images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write # Required for OIDC token exchange

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::422017356244:role/github-actions-role
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: github-actions-eks-deployment-${{ github.run_id }}
          role-duration-seconds: 3600

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name ${{ env.EKS_CLUSTER_NAME }} \
            --region ${{ env.AWS_REGION }}

      - name: Determine environment and namespace
        run: |
          # Determine environment from workflow input or default to production
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          if [ -z "$ENVIRONMENT" ]; then
            ENVIRONMENT="production"
          fi

          echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_ENV

          # Set namespace based on environment
          case $ENVIRONMENT in
            development)
              NAMESPACE="cloudtolocalllm-dev"
              ;;
            staging)
              NAMESPACE="cloudtolocalllm-staging"
              ;;
            production)
              NAMESPACE="cloudtolocalllm"
              ;;
            *)
              echo "Invalid environment: $ENVIRONMENT"
              exit 1
              ;;
          esac

          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV
          echo "Deploying to environment: $ENVIRONMENT"
          echo "Using namespace: $NAMESPACE"

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply base Kubernetes manifests
        run: |
          echo "Applying base Kubernetes manifests..."

          # Apply base manifests in order
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/configmap.yaml -n ${{ env.NAMESPACE }}
          kubectl apply -f k8s/secrets.yaml -n ${{ env.NAMESPACE }} || true
          kubectl apply -f k8s/rbac.yaml -n ${{ env.NAMESPACE }}
          kubectl apply -f k8s/network-policies.yaml -n ${{ env.NAMESPACE }}

          echo "Base manifests applied successfully"

      - name: Install Kustomize
        run: |
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/

      - name: Apply Kustomize overlays for environment
        run: |
          echo "Applying Kustomize overlay for ${{ env.ENVIRONMENT }} environment..."

          # Apply the environment-specific kustomization
          kustomize build --load-restrictor LoadRestrictionsNone k8s/overlays/${{ env.ENVIRONMENT }} | \
            sed "s|cloudtolocalllm/cloudtolocalllm-web:latest|${{ env.DOCKER_REGISTRY }}/cloudtolocalllm-web:${{ github.sha }}|g" | \
            sed "s|cloudtolocalllm/cloudtolocalllm-api:latest|${{ env.DOCKER_REGISTRY }}/cloudtolocalllm-api:${{ github.sha }}|g" | \
            sed "s|cloudtolocalllm/cloudtolocalllm-streaming:latest|${{ env.DOCKER_REGISTRY }}/cloudtolocalllm-streaming:${{ github.sha }}|g" | \
            kubectl apply -f - -n ${{ env.NAMESPACE }}

          echo "Kustomize overlay applied successfully"

      - name: Update Kubernetes manifests with new image tags
        run: |
          # Update web app deployment
          kubectl set image deployment/web \
            web=${{ env.DOCKER_REGISTRY }}/cloudtolocalllm-web:${{ github.sha }} \
            -n ${{ env.NAMESPACE }} \
            --record || echo "Web deployment update skipped (may not exist yet)"

          # Update API backend deployment
          kubectl set image deployment/api-backend \
            api-backend=${{ env.DOCKER_REGISTRY }}/cloudtolocalllm-api:${{ github.sha }} \
            -n ${{ env.NAMESPACE }} \
            --record || echo "API backend deployment update skipped (may not exist yet)"

          # Update Streaming Proxy deployment
          kubectl set image deployment/streaming-proxy \
            streaming-proxy=${{ env.DOCKER_REGISTRY }}/cloudtolocalllm-streaming:${{ github.sha }} \
            -n ${{ env.NAMESPACE }} \
            --record || echo "Streaming proxy deployment update skipped (may not exist yet)"

      - name: Wait for rollout to complete
        run: |
          # Start background pod status monitoring
          (
            echo "Starting pod status monitor..."
            end=$((SECONDS+300))
            while [ $SECONDS -lt $end ]; do
              echo "--- Pod Status ($(date +%T)) ---"
              kubectl get pods -n ${{ env.NAMESPACE }} -o wide
              sleep 10
            done
          ) &
          MONITOR_PID=$!

          echo "Waiting for web deployment..."
          kubectl rollout status deployment/web -n ${{ env.NAMESPACE }} --timeout=5m

          echo "Waiting for API backend deployment..."
          kubectl rollout status deployment/api-backend -n ${{ env.NAMESPACE }} --timeout=5m

          echo "Waiting for Streaming Proxy deployment..."
          kubectl rollout status deployment/streaming-proxy -n ${{ env.NAMESPACE }} --timeout=5m

          # Kill monitor if it's still running
          kill $MONITOR_PID 2>/dev/null || true

  validation:
    name: Validate Deployment
    needs: deploy
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write # Required for OIDC token exchange

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::422017356244:role/github-actions-role
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: github-actions-eks-validation-${{ github.run_id }}
          role-duration-seconds: 3600

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name ${{ env.EKS_CLUSTER_NAME }} \
            --region ${{ env.AWS_REGION }}

      - name: Determine environment and namespace
        run: |
          # Determine environment from workflow input or default to production
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          if [ -z "$ENVIRONMENT" ]; then
            ENVIRONMENT="production"
          fi

          # Set namespace based on environment
          case $ENVIRONMENT in
            development)
              NAMESPACE="cloudtolocalllm-dev"
              ;;
            staging)
              NAMESPACE="cloudtolocalllm-staging"
              ;;
            production)
              NAMESPACE="cloudtolocalllm"
              ;;
          esac

          echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_ENV
          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV

      - name: Verify deployment health
        run: |
          echo "Checking pod status..."
          kubectl get pods -n ${{ env.NAMESPACE }}

          echo ""
          echo "Checking service status..."
          kubectl get svc -n ${{ env.NAMESPACE }}

          echo ""
          echo "Checking ingress status..."
          kubectl get ingress -n ${{ env.NAMESPACE }}

      - name: Get load balancer endpoint
        run: |
          echo "Load Balancer Endpoint:"
          kubectl get svc -n ${{ env.NAMESPACE }} -o wide

      - name: Verify application accessibility
        run: |
          # Get the load balancer IP/hostname
          LB_ENDPOINT=$(kubectl get svc web -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')

          if [ -z "$LB_ENDPOINT" ]; then
            LB_ENDPOINT=$(kubectl get svc web -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          fi

          echo "Load Balancer Endpoint: $LB_ENDPOINT"

          # Wait for endpoint to be ready
          for i in {1..30}; do
            if curl -f -s "http://$LB_ENDPOINT/health" > /dev/null 2>&1; then
              echo "✓ Application is accessible"
              exit 0
            fi
            echo "Attempt $i/30: Waiting for application to be ready..."
            sleep 10
          done

          echo "✗ Application did not become accessible within timeout"
          exit 1

      - name: Track deployment history
        run: |
          echo "Recording deployment history..."

          # Get deployment revisions
          echo ""
          echo "Web Deployment History:"
          kubectl rollout history deployment/web -n ${{ env.NAMESPACE }}

          echo ""
          echo "API Backend Deployment History:"
          kubectl rollout history deployment/api-backend -n ${{ env.NAMESPACE }}

          echo ""
          echo "Streaming Proxy Deployment History:"
          kubectl rollout history deployment/streaming-proxy -n ${{ env.NAMESPACE }}

      - name: Setup Cloudflare DNS Integration
        if: env.ENVIRONMENT == 'production'
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          echo "Setting up Cloudflare DNS integration..."

          # Get NLB endpoint
          NLB_ENDPOINT=$(kubectl get ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}')

          if [ -z "$NLB_ENDPOINT" ]; then
            NLB_ENDPOINT=$(kubectl get ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}')
          fi

          echo "NLB Endpoint: $NLB_ENDPOINT"

          # Get Cloudflare Zone ID
          ZONE_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=cloudtolocalllm.online" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")

          ZONE_ID=$(echo "$ZONE_RESPONSE" | jq -r '.result[0].id')
          echo "Cloudflare Zone ID: $ZONE_ID"

          # Update DNS records for each domain
          for DOMAIN in "cloudtolocalllm.online" "app.cloudtolocalllm.online" "api.cloudtolocalllm.online" "auth.cloudtolocalllm.online"; do
            echo "Updating DNS record for: $DOMAIN"
            
            # Get existing record
            RECORD_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?name=$DOMAIN" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json")
            
            RECORD_COUNT=$(echo "$RECORD_RESPONSE" | jq '.result | length')
            
            if [ "$RECORD_COUNT" -gt 0 ]; then
              RECORD_ID=$(echo "$RECORD_RESPONSE" | jq -r '.result[0].id')
              RECORD_TYPE=$(echo "$RECORD_RESPONSE" | jq -r '.result[0].type')
              
              # Update existing record
              curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$RECORD_ID" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{
                  \"type\": \"$RECORD_TYPE\",
                  \"name\": \"$DOMAIN\",
                  \"content\": \"$NLB_ENDPOINT\",
                  \"ttl\": 300,
                  \"proxied\": true
                }" > /dev/null
              
              echo "  ✓ Updated DNS record for $DOMAIN"
            else
              # Create new A record
              curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{
                  \"type\": \"A\",
                  \"name\": \"$DOMAIN\",
                  \"content\": \"$NLB_ENDPOINT\",
                  \"ttl\": 300,
                  \"proxied\": true
                }" > /dev/null
              
              echo "  ✓ Created DNS record for $DOMAIN"
            fi
          done

          # Configure SSL/TLS settings
          echo "Configuring SSL/TLS settings..."

          # Set SSL mode to "Full"
          curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/settings/ssl" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"value": "full"}' > /dev/null

          # Enable "Always Use HTTPS"
          curl -s -X PATCH "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/settings/always_use_https" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"value": "on"}' > /dev/null

          # Purge cache
          echo "Purging Cloudflare cache..."
          curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/purge_cache" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"purge_everything": true}' > /dev/null

          echo "✓ Cloudflare DNS integration complete"

      - name: Deployment successful
        run: |
          echo "✓ Deployment to AWS EKS completed successfully"
          echo ""
          echo "Deployment Summary:"
          echo "- Environment: ${{ env.ENVIRONMENT }}"
          echo "- Cluster: ${{ env.EKS_CLUSTER_NAME }}"
          echo "- Region: ${{ env.AWS_REGION }}"
          echo "- Namespace: ${{ env.NAMESPACE }}"
          echo "- Web Image: ${{ env.DOCKER_REGISTRY }}/cloudtolocalllm-web:${{ github.sha }}"
          echo "- API Backend Image: ${{ env.DOCKER_REGISTRY }}/cloudtolocalllm-api:${{ github.sha }}"
          echo "- Streaming Proxy Image: ${{ env.DOCKER_REGISTRY }}/cloudtolocalllm-streaming:${{ github.sha }}"
          echo "- Commit: ${{ github.sha }}"
          echo "- Branch: ${{ github.ref }}"
