name: "üîÄ Gemini Dispatch"

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, reopened, synchronize]
  issues:
    types: [opened, reopened]
  issue_comment:
    types: [created]
  pull_request_review:
    types: [submitted]
  pull_request_review_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      do_managed:
        description: "Deploy to Cloud (Managed)"
        type: boolean
        default: false
      do_local:
        description: "Deploy to Local (Ollama)"
        type: boolean
        default: false
      do_desktop:
        description: "Build for Desktop"
        type: boolean
        default: false
      do_mobile:
        description: "Build for Mobile"
        type: boolean
        default: false
      version_override:
        description: "Override version (e.g. 1.2.3). Leave empty for auto."
        type: string
        required: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AZURE_RESOURCE_GROUP: cloudtolocalllm-rg
  AZURE_CLUSTER_NAME: cloudtolocalllm-aks
  ACR_NAME: imrightguycloudtolocalllm
  # DOCKER_REGISTRY will be set dynamically in setup job if needed

defaults:
  run:
    shell: "bash"

jobs:
  # ==================================================================================
  # 1. CORE DISPATCHER (Issues, PR Comments, Reviews)
  # ==================================================================================
  dispatch:
    if: |-
      !contains(github.event.head_commit.message, '[skip ci]')
    runs-on: "ubuntu-latest"
    permissions:
      contents: "read"
      issues: "write"
      pull-requests: "write"
    outputs:
      command: "${{ steps.extract_command.outputs.command }}"
      additional_context: "${{ steps.extract_command.outputs.additional_context }}"
    steps:
      - name: "Extract command"
        id: "extract_command"
        uses: "actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea"
        env:
          EVENT_TYPE: "${{ github.event_name }}.${{ github.event.action }}"
          REQUEST: "${{ github.event.comment.body || github.event.review.body || github.event.issue.body }}"
        with:
          script: |
            const eventType = process.env.EVENT_TYPE;
            const request = process.env.REQUEST || '';
            const eventName = context.eventName;

            if (eventName === 'push' || eventName === 'workflow_dispatch') {
              core.setOutput('command', 'deploy');
            } else if (eventType === 'pull_request.opened') {
              core.setOutput('command', 'review');
            } else if (['issues.opened', 'issues.reopened'].includes(eventType)) {
              core.setOutput('command', 'triage');
            } else if (request.startsWith("@gemini-cli /review")) {
              core.setOutput('command', 'review');
              core.setOutput('additional_context', request.replace(/^@gemini-cli \/review/, '').trim());
            } else if (request.startsWith("@gemini-cli /triage")) {
              core.setOutput('command', 'triage');
            } else if (request.startsWith("@gemini-cli /deploy")) {
              core.setOutput('command', 'deploy');
              core.setOutput('additional_context', request.replace(/^@gemini-cli \/deploy/, '').trim());
            } else if (request.startsWith("@gemini-cli")) {
              core.setOutput('command', 'invoke');
              core.setOutput('additional_context', request.replace(/^@gemini-cli/, '').trim());
            } else {
              core.setOutput('command', 'fallthrough');
            }

      - name: "Acknowledge"
        if: steps.extract_command.outputs.command != 'fallthrough' && (github.event.pull_request.number || github.event.issue.number)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment "${{ github.event.pull_request.number || github.event.issue.number }}" \
            --body "ü§ñ Received your request! Tracking progress [here](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" \
            --repo "${{ github.repository }}"

  # Sub-Dispatch Tasks
  review:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'review'
    uses: "./.github/workflows/gemini-review.yml"
    permissions:
      contents: "read"
      id-token: "write"
      issues: "write"
      pull-requests: "write"
    with:
      additional_context: "${{ needs.dispatch.outputs.additional_context }}"
    secrets: inherit

  triage:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'triage'
    uses: "./.github/workflows/gemini-triage.yml"
    permissions:
      contents: "read"
      id-token: "write"
      issues: "write"
      pull-requests: "write"
    with:
      additional_context: "${{ needs.dispatch.outputs.additional_context }}"
    secrets: inherit

  invoke:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'invoke'
    uses: "./.github/workflows/gemini-invoke.yml"
    permissions:
      contents: "write"
      id-token: "write"
      issues: "write"
      pull-requests: "write"
    with:
      additional_context: "${{ needs.dispatch.outputs.additional_context }}"
    secrets: inherit

  # ==================================================================================
  # 2. PUSH ORCHESTRATOR (Automated Release Analysis)
  # ==================================================================================
  orchestrator:
    needs: [dispatch]
    if: needs.dispatch.outputs.command == 'deploy'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    outputs:
      new_version: ${{ steps.exec.outputs.new_version }}
      docker_version: ${{ steps.exec.outputs.docker_version }}
      do_managed: ${{ steps.exec.outputs.do_managed }}
      do_local: ${{ steps.exec.outputs.do_local }}
      do_desktop: ${{ steps.exec.outputs.do_desktop }}
      do_mobile: ${{ steps.exec.outputs.do_mobile }}
      should_deploy: ${{ steps.exec.outputs.should_deploy }}
      reasoning: ${{ steps.exec.outputs.reasoning }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 50
          fetch-tags: true

      - name: "Mint identity token"
        id: "mint_identity_token"
        if: vars.APP_ID != ''
        uses: "actions/create-github-app-token@a8d616148505b5069dccd32f177bb87d7f39123b"
        with:
          app-id: "${{ vars.APP_ID }}"
          private-key: "${{ secrets.APP_PRIVATE_KEY }}"

      - name: "Run Analysis"
        id: "analysis"
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          IS_MANUAL: ${{ github.event_name == 'workflow_dispatch' }}
          MANUAL_MANAGED: ${{ github.event.inputs.do_managed }}
          MANUAL_LOCAL: ${{ github.event.inputs.do_local }}
          MANUAL_DESKTOP: ${{ github.event.inputs.do_desktop }}
          MANUAL_MOBILE: ${{ github.event.inputs.do_mobile }}
          VERSION_OVERRIDE: ${{ github.event.inputs.version_override }}
        run: |
          set -e

          # 1. Strict Credential Validation
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "‚ùå CRITICAL FAILURE: GEMINI_API_KEY is not set. Deployment cannot proceed without AI analysis."
            exit 1
          fi

          # 2. Tool Verification
          if ! command -v jq &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

          # 2.5 context: Current Tags & Recent Changes
          echo "üè∑Ô∏è  Fetching repository status..."
          EXISTING_TAGS=$(git tag --sort=-v:refname | head -n 10 | tr '\n' ',' | sed 's/,$//')

          cat << EOF > prompt.txt
          Analyze the following project state and determine the release strategy.
          1. Current Version (from assets/version.json): $(jq -r '.version' assets/version.json)
          2. Recent Commits: $(git log --oneline --no-merges -5 | tr '\n' ' ' )
          3. EXISTING REPOSITORY TAGS: $EXISTING_TAGS
          4. COMMAND/INTENT CONTEXT: ${{ needs.dispatch.outputs.additional_context }}

          CRITICAL: Your 'new_version' MUST NOT exist in the EXISTING REPOSITORY TAGS. 
          If the next logical semantic version is already a tag, you MUST increment the patch version until you find a unique version.

          Return ONLY a valid JSON object with these keys:
          {
            "new_version": "string (next semantic version)",
            "docker_version": "string (docker-safe version)",
            "do_managed": "true/false",
            "do_local": "true/false",
            "do_desktop": "true/false",
            "do_mobile": "true/false",
            "should_deploy": "true/false",
            "version_bump_needed": "true/false",
            "reasoning": "string"
          }
          EOF

          # 3. Execution via Curl (More robust in CI)
          echo "üöÄ Executing Gemini Analysis via API..."

          PROMPT=$(cat prompt.txt)
          JSON_PROMPT=$(echo "$PROMPT" | jq -aRs .)

          API_URL="https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}"

          cat << EOF > request.json
          {
            "contents": [{
              "parts":[{"text": $JSON_PROMPT}]
            }],
            "generationConfig": {
              "response_mime_type": "application/json"
            }
          }
          EOF

          curl -s -X POST "$API_URL" \
               -H "Content-Type: application/json" \
               -d @request.json > response.json

          if [ "$(jq -r '.candidates[0].content.parts[0].text' response.json)" != "null" ]; then
             jq -r '.candidates[0].content.parts[0].text' response.json > gemini_output.json
             echo "‚úÖ Gemini Analysis Successful."
          else
             echo "‚ùå CRITICAL FAILURE: Gemini API returned an error or empty response."
             cat response.json
             exit 1
          fi

          # 4. Handle Manual Overrides
          if [ "$IS_MANUAL" == "true" ]; then
            echo "üõ†Ô∏è  Applying manual overrides..."
            # Use jq to update the JSON file with inputs
            CLEAN_JSON=$(cat gemini_output.json)
            [ -n "$MANUAL_MANAGED" ] && CLEAN_JSON=$(echo "$CLEAN_JSON" | jq ".do_managed = $MANUAL_MANAGED")
            [ -n "$MANUAL_LOCAL" ] && CLEAN_JSON=$(echo "$CLEAN_JSON" | jq ".do_local = $MANUAL_LOCAL")
            [ -n "$MANUAL_DESKTOP" ] && CLEAN_JSON=$(echo "$CLEAN_JSON" | jq ".do_desktop = $MANUAL_DESKTOP")
            [ -n "$MANUAL_MOBILE" ] && CLEAN_JSON=$(echo "$CLEAN_JSON" | jq ".do_mobile = $MANUAL_MOBILE")
            if [ -n "$VERSION_OVERRIDE" ]; then
                CLEAN_JSON=$(echo "$CLEAN_JSON" | jq ".new_version = \"$VERSION_OVERRIDE\"")
                CLEAN_JSON=$(echo "$CLEAN_JSON" | jq ".version_bump_needed = true")
            fi
            # Ensure should_deploy is true if any platform is selected
            if [ "$MANUAL_MANAGED" == "true" ] || [ "$MANUAL_LOCAL" == "true" ] || [ "$MANUAL_DESKTOP" == "true" ] || [ "$MANUAL_MOBILE" == "true" ]; then
                CLEAN_JSON=$(echo "$CLEAN_JSON" | jq ".should_deploy = true")
            fi
            echo "$CLEAN_JSON" > gemini_output.json
          fi

          echo "::: Validated Gemini Output :::"
          cat gemini_output.json

      - name: "Execute Logic"
        id: "exec"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: "${{ secrets.GEMINI_API_KEY }}"
        run: |
          set -e
          CLEAN_JSON=$(sed -n '/{/,/}/p' gemini_output.json)
          echo "new_version=$(echo "$CLEAN_JSON" | jq -r '.new_version')" >> $GITHUB_OUTPUT
          echo "docker_version=$(echo "$CLEAN_JSON" | jq -r '.docker_version')" >> $GITHUB_OUTPUT
          echo "do_managed=$(echo "$CLEAN_JSON" | jq -r '.do_managed')" >> $GITHUB_OUTPUT
          echo "do_local=$(echo "$CLEAN_JSON" | jq -r '.do_local')" >> $GITHUB_OUTPUT
          echo "do_desktop=$(echo "$CLEAN_JSON" | jq -r '.do_desktop')" >> $GITHUB_OUTPUT
          echo "do_mobile=$(echo "$CLEAN_JSON" | jq -r '.do_mobile')" >> $GITHUB_OUTPUT
          echo "should_deploy=$(echo "$CLEAN_JSON" | jq -r '.should_deploy')" >> $GITHUB_OUTPUT
          echo "reasoning=$(echo "$CLEAN_JSON" | jq -r '.reasoning')" >> $GITHUB_OUTPUT

          if [ "$(echo "$CLEAN_JSON" | jq -r '.version_bump_needed')" == "true" ]; then
            git config user.name "gemini-cli[bot]"
            git config user.email "gemini-cli[bot]@users.noreply.github.com"
            chmod +x scripts/update-all-versions.sh
            ./scripts/update-all-versions.sh "$(echo "$CLEAN_JSON" | jq -r '.new_version')" "${{ github.sha }}"
            git add -A
            git commit -m "chore: bump version to $(echo "$CLEAN_JSON" | jq -r '.new_version') [skip ci]"
            git push origin main && git tag "v$(echo "$CLEAN_JSON" | jq -r '.new_version')" -f && git push origin --tags -f

            # --- Platform Distribution ---
            NEW_VERSION=$(echo "$CLEAN_JSON" | jq -r '.new_version')
            SHORT_SHA=$(git rev-parse --short HEAD)
            DO_MANAGED=$(echo "$CLEAN_JSON" | jq -r '.do_managed')
            DO_DESKTOP=$(echo "$CLEAN_JSON" | jq -r '.do_desktop')
            DO_MOBILE=$(echo "$CLEAN_JSON" | jq -r '.do_mobile')

            # Cloud Branch
            if [ "$DO_MANAGED" == "true" ]; then
               echo "‚òÅÔ∏è  Pushing to cloud branch..."
               if [ -f "scripts/push-to-cloud-branch.sh" ]; then
                  chmod +x scripts/push-to-cloud-branch.sh
                  CLOUD_PUSH_PAT="${{ secrets.GITHUB_TOKEN }}" ./scripts/push-to-cloud-branch.sh "$NEW_VERSION"
               else
                  git checkout -B cloud main
                  git push -f origin cloud
                  git tag "${NEW_VERSION}-cloud-${SHORT_SHA}" -f
                  git push origin "${NEW_VERSION}-cloud-${SHORT_SHA}" -f
                  git checkout main
               fi
            fi

            # Desktop Branch
            if [ "$DO_DESKTOP" == "true" ]; then
               echo "üñ•Ô∏è  Pushing to desktop branch..."
               git checkout -B desktop main
               git push -f origin desktop
               git tag "${NEW_VERSION}-desktop-${SHORT_SHA}" -f
               git push origin "${NEW_VERSION}-desktop-${SHORT_SHA}" -f
               git checkout main
            fi

            # Mobile Branch
            if [ "$DO_MOBILE" == "true" ]; then
               echo "üì± Pushing to mobile branch..."
               git checkout -B mobile main
               git push -f origin mobile
               git tag "${NEW_VERSION}-mobile-${SHORT_SHA}" -f
               git push origin "${NEW_VERSION}-mobile-${SHORT_SHA}" -f
               git checkout main
            fi
          fi

  # ==================================================================================
  # 3. CHANGE DETECTION (Path-based)
  # ==================================================================================
  detect_changes:
    needs: [orchestrator]
    if: needs.orchestrator.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    outputs:
      base: ${{ steps.detect.outputs.base }}
      postgres: ${{ steps.detect.outputs.postgres }}
      web: ${{ steps.detect.outputs.web }}
      api: ${{ steps.detect.outputs.api }}
      proxy: ${{ steps.detect.outputs.proxy }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Detect Service Changes
        id: detect
        run: |
          set -e
          PREV_TAG=$(git tag -l "*-cloud-*" --sort=-version:refname | head -n 1 || echo "")
          if [ -z "$PREV_TAG" ]; then
            echo "base=true" >> $GITHUB_OUTPUT
            echo "postgres=true" >> $GITHUB_OUTPUT
            echo "web=true" >> $GITHUB_OUTPUT
            echo "api=true" >> $GITHUB_OUTPUT
            echo "proxy=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Comparing against $PREV_TAG"
          echo "base=$(git diff --name-only $PREV_TAG HEAD | grep -qE '^config/docker/Dockerfile\.base' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "postgres=$(git diff --name-only $PREV_TAG HEAD | grep -qE '^config/docker/Dockerfile\.postgres' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "web=$(git diff --name-only $PREV_TAG HEAD | grep -qE '^(web|lib|pubspec\.)' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "api=$(git diff --name-only $PREV_TAG HEAD | grep -qE '^services/api-backend' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "proxy=$(git diff --name-only $PREV_TAG HEAD | grep -qE '^services/streaming-proxy' && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT

  # ==================================================================================
  # 4. INFRASTRUCTURE & BUILD
  # ==================================================================================
  infrastructure:
    needs: [orchestrator, detect_changes]
    if: needs.orchestrator.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      login_server: ${{ steps.acr.outputs.login_server }}
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Bootstrap Azure Infra
        id: acr
        run: |
          set -e
          chmod +x scripts/bootstrap-azure-infra.sh
          ./scripts/bootstrap-azure-infra.sh "${{ env.AZURE_RESOURCE_GROUP }}" "eastus" "${{ env.ACR_NAME }}" "${{ secrets.AZURE_KEY_VAULT_NAME }}"

          # Create AKS if not exists
          if ! az aks show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_CLUSTER_NAME }} >/dev/null 2>&1; then
            az aks create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_CLUSTER_NAME }} --node-count 1 --enable-managed-identity --attach-acr ${{ env.ACR_NAME }} --generate-ssh-keys
          fi

          echo "login_server=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_OUTPUT

      - name: Setup AKS Context & CSI
        run: |
          az aks get-credentials --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_CLUSTER_NAME }} --overwrite-existing
          kubectl create namespace cloudtolocalllm --dry-run=client -o yaml | kubectl apply -f -

          # Secrets Store CSI setup (Helm)
          helm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts --force-update
          helm repo add csi-secrets-store-provider-azure https://azure.github.io/secrets-store-csi-driver-provider-azure/charts --force-update
          helm upgrade --install csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver --namespace kube-system --set "providers.azure.enabled=true" --wait

  build_base:
    needs: [orchestrator, detect_changes, infrastructure]
    if: needs.detect_changes.outputs.base == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login
        run: |
          ACR_USER=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASS=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value -o tsv)
          echo "$ACR_PASS" | docker login ${{ needs.infrastructure.outputs.login_server }} -u "$ACR_USER" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: config/docker/Dockerfile.base
          push: true
          tags: |
            ${{ needs.infrastructure.outputs.login_server }}/base:${{ needs.orchestrator.outputs.new_version }}-base
            ${{ needs.infrastructure.outputs.login_server }}/base:latest
          cache-from: type=registry,ref=${{ needs.infrastructure.outputs.login_server }}/base:latest
          cache-to: type=inline

  build_postgres:
    needs: [orchestrator, detect_changes, infrastructure, build_base]
    if: always() && needs.detect_changes.outputs.postgres == 'true' && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login
        run: |
          ACR_USER=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASS=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value -o tsv)
          echo "$ACR_PASS" | docker login ${{ needs.infrastructure.outputs.login_server }} -u "$ACR_USER" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: config/docker/Dockerfile.postgres
          push: true
          tags: ${{ needs.infrastructure.outputs.login_server }}/postgres:${{ needs.orchestrator.outputs.new_version }}-postgres
          build-args: BASE_REGISTRY=${{ needs.infrastructure.outputs.login_server }}

  build_web:
    needs: [orchestrator, detect_changes, infrastructure, build_base]
    if: always() && needs.detect_changes.outputs.web == 'true' && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: subosito/flutter-action@v2
        with:
          channel: "stable"
          cache: true
      - name: Build Web
        run: |
          flutter pub get
          flutter build web --release --no-tree-shake-icons --base-href /
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login
        run: |
          ACR_USER=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASS=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value -o tsv)
          echo "$ACR_PASS" | docker login ${{ needs.infrastructure.outputs.login_server }} -u "$ACR_USER" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: web/Dockerfile
          push: true
          tags: ${{ needs.infrastructure.outputs.login_server }}/web:${{ needs.orchestrator.outputs.new_version }}
          build-args: BASE_REGISTRY=${{ needs.infrastructure.outputs.login_server }}

  build_api:
    needs: [orchestrator, detect_changes, infrastructure, build_base]
    if: always() && needs.detect_changes.outputs.api == 'true' && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login
        run: |
          ACR_USER=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASS=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value -o tsv)
          echo "$ACR_PASS" | docker login ${{ needs.infrastructure.outputs.login_server }} -u "$ACR_USER" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: services/api-backend
          file: services/api-backend/Dockerfile
          push: true
          tags: ${{ needs.infrastructure.outputs.login_server }}/api-backend:${{ needs.orchestrator.outputs.new_version }}-api
          build-args: BASE_REGISTRY=${{ needs.infrastructure.outputs.login_server }}

  build_proxy:
    needs: [orchestrator, detect_changes, infrastructure, build_base]
    if: always() && needs.detect_changes.outputs.proxy == 'true' && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login
        run: |
          ACR_USER=$(az acr credential show --name ${{ env.ACR_NAME }} --query username -o tsv)
          ACR_PASS=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value -o tsv)
          echo "$ACR_PASS" | docker login ${{ needs.infrastructure.outputs.login_server }} -u "$ACR_USER" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: services/streaming-proxy
          file: services/streaming-proxy/Dockerfile
          push: true
          tags: ${{ needs.infrastructure.outputs.login_server }}/streaming-proxy:${{ needs.orchestrator.outputs.new_version }}-proxy
          build-args: BASE_REGISTRY=${{ needs.infrastructure.outputs.login_server }}

  # ==================================================================================
  # 5. GITOPS PROMOTION
  # ==================================================================================
  promote:
    needs:
      [
        orchestrator,
        detect_changes,
        infrastructure,
        build_postgres,
        build_web,
        build_api,
        build_proxy,
      ]
    if: always() && needs.orchestrator.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Update Manifests
        env:
          APP_VERSION: ${{ needs.orchestrator.outputs.new_version }}
          LOGIN_SERVER: ${{ needs.infrastructure.outputs.login_server }}
        run: |
          set -e
          cd k8s/overlays/managed
          [ "${{ needs.detect_changes.outputs.postgres }}" == "true" ] && kustomize edit set image cloudtolocalllm/postgres=$LOGIN_SERVER/postgres:$APP_VERSION-postgres
          [ "${{ needs.detect_changes.outputs.web }}" == "true" ] && kustomize edit set image cloudtolocalllm/web=$LOGIN_SERVER/web:$APP_VERSION
          [ "${{ needs.detect_changes.outputs.api }}" == "true" ] && kustomize edit set image cloudtolocalllm/api-backend=$LOGIN_SERVER/api-backend:$APP_VERSION-api
          [ "${{ needs.detect_changes.outputs.proxy }}" == "true" ] && kustomize edit set image cloudtolocalllm/streaming-proxy=$LOGIN_SERVER/streaming-proxy:$APP_VERSION-proxy

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add kustomization.yaml
          if ! git diff --staged --quiet; then
            git commit -m "chore(ops): update manifests for v$APP_VERSION [skip ci]"
            git push origin main
          fi

      - name: Purge Cache
        continue-on-error: true
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          ZONE_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=cloudtolocalllm.online" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json" | jq -r '.result[0].id')
          if [ -n "$ZONE_ID" ]; then
            curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/purge_cache" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data '{"purge_everything": true}'
          fi

      - name: Create Release
        run: |
          VERSION="v${{ needs.orchestrator.outputs.new_version }}"
          if gh release view "$VERSION" >/dev/null 2>&1; then
            gh release edit "$VERSION" --notes "${{ needs.orchestrator.outputs.reasoning }}"
          else
            gh release create "$VERSION" --title "Release $VERSION" --notes "${{ needs.orchestrator.outputs.reasoning }}"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
