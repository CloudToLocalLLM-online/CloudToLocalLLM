name: 'ðŸ”€ Gemini Dispatch'

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, reopened, synchronize]
  issues:
    types: [opened, reopened]
  issue_comment:
    types: [created]
  pull_request_review:
    types: [submitted]
  pull_request_review_comment:
    types: [created]

defaults:
  run:
    shell: 'bash'

jobs:
  # ==================================================================================
  # 1. CORE DISPATCHER (Issues, PR Comments, Reviews)
  # ==================================================================================
  dispatch:
    if: |- 
      github.event_name != 'push' && (
        (github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false) ||
        (github.event_name == 'issues') ||
        (github.event.sender.type == 'User' && startsWith(github.event.comment.body || github.event.review.body || github.event.issue.body, '@gemini-cli'))
      )
    runs-on: 'ubuntu-latest'
    permissions:
      contents: 'read'
      issues: 'write'
      pull-requests: 'write'
    outputs:
      command: '${{ steps.extract_command.outputs.command }}'
      additional_context: '${{ steps.extract_command.outputs.additional_context }}'
    steps:
      - name: 'Mint identity token'
        id: 'mint_identity_token'
        if: vars.APP_ID != ''
        uses: 'actions/create-github-app-token@a8d616148505b5069dccd32f177bb87d7f39123b'
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'

      - name: 'Extract command'
        id: 'extract_command'
        uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea'
        env:
          EVENT_TYPE: '${{ github.event_name }}.${{ github.event.action }}'
          REQUEST: '${{ github.event.comment.body || github.event.review.body || github.event.issue.body }}'
        with:
          script: |
            const eventType = process.env.EVENT_TYPE;
            const request = process.env.REQUEST || '';
            if (eventType === 'pull_request.opened') core.setOutput('command', 'review');
            else if (['issues.opened', 'issues.reopened'].includes(eventType)) core.setOutput('command', 'triage');
            else if (request.startsWith("@gemini-cli /review")) {
              core.setOutput('command', 'review');
              core.setOutput('additional_context', request.replace(/^@gemini-cli \/review/, '').trim());
            } else if (request.startsWith("@gemini-cli /triage")) core.setOutput('command', 'triage');
            else if (request.startsWith("@gemini-cli")) {
              core.setOutput('command', 'invoke');
              core.setOutput('additional_context', request.replace(/^@gemini-cli/, '').trim());
            } else core.setOutput('command', 'fallthrough');

      - name: 'Acknowledge'
        if: steps.extract_command.outputs.command != 'fallthrough'
        env:
          GITHUB_TOKEN: '${{ steps.mint_identity_token.outputs.token || secrets.GITHUB_TOKEN }}'
        run: |
          gh issue comment "${{ github.event.pull_request.number || github.event.issue.number }}" \
            --body "ðŸ¤– Received your request! Tracking progress [here](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" \
            --repo "${{ github.repository }}"

  # Sub-Dispatch Tasks
  review:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'review'
    uses: './.github/workflows/gemini-review.yml'
    permissions:
      contents: 'read'
      id-token: 'write'
      issues: 'write'
      pull-requests: 'write'
    with:
      additional_context: '${{ needs.dispatch.outputs.additional_context }}'
    secrets: inherit

  triage:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'triage'
    uses: './.github/workflows/gemini-triage.yml'
    permissions:
      contents: 'read'
      id-token: 'write'
      issues: 'write'
      pull-requests: 'write'
    with:
      additional_context: '${{ needs.dispatch.outputs.additional_context }}'
    secrets: inherit

  invoke:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'invoke'
    uses: './.github/workflows/gemini-invoke.yml'
    permissions:
      contents: 'read'
      id-token: 'write'
      issues: 'write'
      pull-requests: 'write'
    with:
      additional_context: '${{ needs.dispatch.outputs.additional_context }}'
    secrets: inherit

  # ==================================================================================
  # 2. PUSH ORCHESTRATOR (Automated Release Analysis)
  # ==================================================================================
  orchestrator:
    if: github.event_name == 'push' && !contains(github.event.head_commit.message, '[skip ci]')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    outputs:
      new_version: ${{ steps.exec.outputs.new_version }}
      docker_version: ${{ steps.exec.outputs.docker_version }}
      do_managed: ${{ steps.exec.outputs.do_managed }}
      do_local: ${{ steps.exec.outputs.do_local }}
      do_desktop: ${{ steps.exec.outputs.do_desktop }}
      do_mobile: ${{ steps.exec.outputs.do_mobile }}
      should_deploy: ${{ steps.exec.outputs.should_deploy }}
      reasoning: ${{ steps.exec.outputs.reasoning }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 50
          fetch-tags: true

      - name: 'Mint identity token'
        id: 'mint_identity_token'
        if: vars.APP_ID != ''
        uses: 'actions/create-github-app-token@a8d616148505b5069dccd32f177bb87d7f39123b'
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'

      - name: 'Run Analysis'
        id: 'analysis'
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          set -e
          npm install -g @google/gemini-cli@latest
          cat << 'EOF' > prompt.txt
          Analyze the following project state and determine the release strategy.
          1. Read 'assets/version.json' for the current version.
          2. Check 'git log --oneline --no-merges -5' for recent context.
          3. Check 'git diff --name-only HEAD~1..HEAD' for changed files.

          Return ONLY a valid JSON object with these keys:
          {
            "new_version": "string (next semantic version)",
            "docker_version": "string (docker-safe version)",
            "do_managed": "true/false",
            "do_local": "true/false",
            "do_desktop": "true/false",
            "do_mobile": "true/false",
            "should_deploy": "true/false",
            "version_bump_needed": "true/false",
            "reasoning": "string"
          }
          EOF
          gemini --yolo --prompt "$(cat prompt.txt)" > gemini_output.json 2> gemini_stderr.log || true
          echo "::: Gemini Output :::"
          cat gemini_output.json

      - name: 'Execute Logic'
        id: 'exec'
        env:
          GITHUB_TOKEN: '${{ steps.mint_identity_token.outputs.token || secrets.GITHUB_TOKEN }}'
        run: |
          set -e
          CLEAN_JSON=$(sed -n '/{/,/}/p' gemini_output.json)
          echo "new_version=$(echo "$CLEAN_JSON" | jq -r '.new_version')" >> $GITHUB_OUTPUT
          echo "docker_version=$(echo "$CLEAN_JSON" | jq -r '.docker_version')" >> $GITHUB_OUTPUT
          echo "do_managed=$(echo "$CLEAN_JSON" | jq -r '.do_managed')" >> $GITHUB_OUTPUT
          echo "do_local=$(echo "$CLEAN_JSON" | jq -r '.do_local')" >> $GITHUB_OUTPUT
          echo "do_desktop=$(echo "$CLEAN_JSON" | jq -r '.do_desktop')" >> $GITHUB_OUTPUT
          echo "do_mobile=$(echo "$CLEAN_JSON" | jq -r '.do_mobile')" >> $GITHUB_OUTPUT
          echo "should_deploy=$(echo "$CLEAN_JSON" | jq -r '.should_deploy')" >> $GITHUB_OUTPUT
          echo "reasoning=$(echo "$CLEAN_JSON" | jq -r '.reasoning')" >> $GITHUB_OUTPUT

          if [ "$(echo "$CLEAN_JSON" | jq -r '.version_bump_needed')" == "true" ]; then
            git config user.name "gemini-cli[bot]"
            git config user.email "gemini-cli[bot]@users.noreply.github.com"
            chmod +x scripts/update-all-versions.sh
            ./scripts/update-all-versions.sh "$(echo "$CLEAN_JSON" | jq -r '.new_version')" "${{ github.sha }}"
            git add -A
            git commit -m "chore: bump version to $(echo "$CLEAN_JSON" | jq -r '.new_version') [skip ci]"
            git push origin main && git tag "v$(echo "$CLEAN_JSON" | jq -r '.new_version')" -f && git push origin --tags -f
          fi

  # ==================================================================================
  # 3. CI/CD PIPELINE (Deployment)
  # ==================================================================================
  deploy:
    needs: [orchestrator]
    if: always() && needs.orchestrator.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    env:
      AZURE_RESOURCE_GROUP: cloudtolocalllm-rg
      ACR_NAME: imrightguycloudtolocalllm
    steps:
      - uses: actions/checkout@v6
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Setup ACR
        id: acr
        run: |
          az acr create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.ACR_NAME }} --sku Basic --admin-enabled true
          echo "server=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_OUTPUT
      - name: Build & Release
        run: |
          echo "Building v${{ needs.orchestrator.outputs.new_version }}"...
          gh release create "v${{ needs.orchestrator.outputs.new_version }}" --title "Release v${{ needs.orchestrator.outputs.new_version }}" --notes "${{ needs.orchestrator.outputs.reasoning }}"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}