name: "üîÄ Gemini Dispatch"

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, reopened, synchronize]
  issues:
    types: [opened, reopened]
  issue_comment:
    types: [created]
  pull_request_review:
    types: [submitted]
  pull_request_review_comment:
    types: [created]

defaults:
  run:
    shell: "bash"

jobs:
  # ==================================================================================
  # 1. CORE DISPATCHER (Issues, PR Comments, Reviews)
  # ==================================================================================
  dispatch:
    if: |-
      github.event_name != 'push' && (
        (github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false) ||
        (github.event_name == 'issues') ||
        (github.event.sender.type == 'User' && startsWith(github.event.comment.body || github.event.review.body || github.event.issue.body, '@gemini-cli'))
      )
    runs-on: "ubuntu-latest"
    permissions:
      contents: "read"
      issues: "write"
      pull-requests: "write"
    outputs:
      command: "${{ steps.extract_command.outputs.command }}"
      additional_context: "${{ steps.extract_command.outputs.additional_context }}"
    steps:
      - name: "Mint identity token"
        id: "mint_identity_token"
        if: vars.APP_ID != ''
        uses: "actions/create-github-app-token@a8d616148505b5069dccd32f177bb87d7f39123b"
        with:
          app-id: "${{ vars.APP_ID }}"
          private-key: "${{ secrets.APP_PRIVATE_KEY }}"

      - name: "Extract command"
        id: "extract_command"
        uses: "actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea"
        env:
          EVENT_TYPE: "${{ github.event_name }}.${{ github.event.action }}"
          REQUEST: "${{ github.event.comment.body || github.event.review.body || github.event.issue.body }}"
        with:
          script: |
            const eventType = process.env.EVENT_TYPE;
            const request = process.env.REQUEST || '';
            if (eventType === 'pull_request.opened') core.setOutput('command', 'review');
            else if (['issues.opened', 'issues.reopened'].includes(eventType)) core.setOutput('command', 'triage');
            else if (request.startsWith("@gemini-cli /review")) {
              core.setOutput('command', 'review');
              core.setOutput('additional_context', request.replace(/^@gemini-cli \/review/, '').trim());
            } else if (request.startsWith("@gemini-cli /triage")) core.setOutput('command', 'triage');
            else if (request.startsWith("@gemini-cli")) {
              core.setOutput('command', 'invoke');
              core.setOutput('additional_context', request.replace(/^@gemini-cli/, '').trim());
            } else core.setOutput('command', 'fallthrough');

      - name: "Acknowledge"
        if: steps.extract_command.outputs.command != 'fallthrough'
        env:
          GITHUB_TOKEN: "${{ steps.mint_identity_token.outputs.token || secrets.GITHUB_TOKEN }}"
        run: |
          gh issue comment "${{ github.event.pull_request.number || github.event.issue.number }}" \
            --body "ü§ñ Received your request! Tracking progress [here](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" \
            --repo "${{ github.repository }}"

  # Sub-Dispatch Tasks
  review:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'review'
    uses: "./.github/workflows/gemini-review.yml"
    permissions:
      contents: "read"
      id-token: "write"
      issues: "write"
      pull-requests: "write"
    with:
      additional_context: "${{ needs.dispatch.outputs.additional_context }}"
    secrets: inherit

  triage:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'triage'
    uses: "./.github/workflows/gemini-triage.yml"
    permissions:
      contents: "read"
      id-token: "write"
      issues: "write"
      pull-requests: "write"
    with:
      additional_context: "${{ needs.dispatch.outputs.additional_context }}"
    secrets: inherit

  invoke:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'invoke'
    uses: "./.github/workflows/gemini-invoke.yml"
    permissions:
      contents: "write"
      id-token: "write"
      issues: "write"
      pull-requests: "write"
    with:
      additional_context: "${{ needs.dispatch.outputs.additional_context }}"
    secrets: inherit

  # ==================================================================================
  # 2. PUSH ORCHESTRATOR (Automated Release Analysis)
  # ==================================================================================
  orchestrator:
    if: github.event_name == 'push' && !contains(github.event.head_commit.message, '[skip ci]')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    outputs:
      new_version: ${{ steps.exec.outputs.new_version }}
      docker_version: ${{ steps.exec.outputs.docker_version }}
      do_managed: ${{ steps.exec.outputs.do_managed }}
      do_local: ${{ steps.exec.outputs.do_local }}
      do_desktop: ${{ steps.exec.outputs.do_desktop }}
      do_mobile: ${{ steps.exec.outputs.do_mobile }}
      should_deploy: ${{ steps.exec.outputs.should_deploy }}
      reasoning: ${{ steps.exec.outputs.reasoning }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 50
          fetch-tags: true

      - name: "Mint identity token"
        id: "mint_identity_token"
        if: vars.APP_ID != ''
        uses: "actions/create-github-app-token@a8d616148505b5069dccd32f177bb87d7f39123b"
        with:
          app-id: "${{ vars.APP_ID }}"
          private-key: "${{ secrets.APP_PRIVATE_KEY }}"

      - name: "Run Analysis"
        id: "analysis"
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          set -e

          # 1. Strict Credential Validation
          if [ -z "$GEMINI_API_KEY" ]; then
            echo "‚ùå CRITICAL FAILURE: GEMINI_API_KEY is not set. Deployment cannot proceed without AI analysis."
            exit 1
          fi

          # 2. Tool Verification
          if ! command -v jq &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

          if ! command -v gemini &> /dev/null; then
             echo "üì¶ Installing @google/gemini-cli..."
             npm install -g @google/gemini-cli@latest
          fi

          # 2.5 context: Current Tags
          echo "üè∑Ô∏è  Fetching repository tags..."
          EXISTING_TAGS=$(git tag --sort=-v:refname | head -n 10 | tr '\n' ',' | sed 's/,$//')
          echo "Existing Tags: $EXISTING_TAGS"

          cat << EOF > prompt.txt
          Analyze the following project state and determine the release strategy.
          1. Read 'assets/version.json' for the current version.
          2. Check 'git log --oneline --no-merges -5' for recent context.
          3. Check 'git diff --name-only HEAD~1..HEAD' for changed files.
          4. EXISTING REPOSITORY TAGS: $EXISTING_TAGS

          CRITICAL: Your 'new_version' MUST NOT exist in the EXISTING REPOSITORY TAGS. 
          If the next logical semantic version is already a tag, you MUST increment the patch version until you find a unique version.

          Return ONLY a valid JSON object with these keys:
          {
            "new_version": "string (next semantic version)",
            "docker_version": "string (docker-safe version)",
            "do_managed": "true/false",
            "do_local": "true/false",
            "do_desktop": "true/false",
            "do_mobile": "true/false",
            "should_deploy": "true/false",
            "version_bump_needed": "true/false",
            "reasoning": "string"
          }
          EOF

          # 3. Strict Execution Loop (Fail Fast on unrecoverable errors)
          echo "üöÄ Executing Gemini Analysis..."
          MAX_RETRIES=3
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            # Run Gemini with strict environment
            if gemini --yolo --model gemini-1.5-flash --prompt "$(cat prompt.txt)" > gemini_output_raw.txt 2> gemini_stderr.log; then
              
              # Extract JSON block
              sed -n '/{/,/}/p' gemini_output_raw.txt > gemini_output.json
              
              # Validation: Fail if empty or invalid JSON
              if [ -s gemini_output.json ] && jq empty gemini_output.json >/dev/null 2>&1; then
                echo "‚úÖ Gemini Analysis Successful."
                break
              else
                echo "‚ö†Ô∏è  Attempt $((RETRY_COUNT+1)) failed: Invalid JSON response."
              fi
            else
               echo "‚ö†Ô∏è  Attempt $((RETRY_COUNT+1)) failed: CLI Execution Error."
            fi
            
            RETRY_COUNT=$((RETRY_COUNT+1))
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "‚ùå CRITICAL FAILURE: Gemini Analysis failed after $MAX_RETRIES attempts."
              echo "::: Stderr :::"
              cat gemini_stderr.log
              echo "::: Raw Output :::"
              cat gemini_output_raw.txt
              exit 1
            fi
            
            SLEEP_TIME=$((RETRY_COUNT * 5))
            echo "Retrying in ${SLEEP_TIME}s..."
            sleep $SLEEP_TIME
          done

          echo "::: Validated Gemini Output :::"
          cat gemini_output.json

      - name: "Execute Logic"
        id: "exec"
        env:
          GITHUB_TOKEN: "${{ steps.mint_identity_token.outputs.token || secrets.GITHUB_TOKEN }}"
          GEMINI_API_KEY: "${{ secrets.GEMINI_API_KEY }}"
        run: |
          set -e
          CLEAN_JSON=$(sed -n '/{/,/}/p' gemini_output.json)
          echo "new_version=$(echo "$CLEAN_JSON" | jq -r '.new_version')" >> $GITHUB_OUTPUT
          echo "docker_version=$(echo "$CLEAN_JSON" | jq -r '.docker_version')" >> $GITHUB_OUTPUT
          echo "do_managed=$(echo "$CLEAN_JSON" | jq -r '.do_managed')" >> $GITHUB_OUTPUT
          echo "do_local=$(echo "$CLEAN_JSON" | jq -r '.do_local')" >> $GITHUB_OUTPUT
          echo "do_desktop=$(echo "$CLEAN_JSON" | jq -r '.do_desktop')" >> $GITHUB_OUTPUT
          echo "do_mobile=$(echo "$CLEAN_JSON" | jq -r '.do_mobile')" >> $GITHUB_OUTPUT
          echo "should_deploy=$(echo "$CLEAN_JSON" | jq -r '.should_deploy')" >> $GITHUB_OUTPUT
          echo "reasoning=$(echo "$CLEAN_JSON" | jq -r '.reasoning')" >> $GITHUB_OUTPUT

          if [ "$(echo "$CLEAN_JSON" | jq -r '.version_bump_needed')" == "true" ]; then
            git config user.name "gemini-cli[bot]"
            git config user.email "gemini-cli[bot]@users.noreply.github.com"
            chmod +x scripts/update-all-versions.sh
            ./scripts/update-all-versions.sh "$(echo "$CLEAN_JSON" | jq -r '.new_version')" "${{ github.sha }}"
            git add -A
            git commit -m "chore: bump version to $(echo "$CLEAN_JSON" | jq -r '.new_version') [skip ci]"
            git push origin main && git tag "v$(echo "$CLEAN_JSON" | jq -r '.new_version')" -f && git push origin --tags -f

            # --- Platform Distribution ---
            NEW_VERSION=$(echo "$CLEAN_JSON" | jq -r '.new_version')
            SHORT_SHA=$(git rev-parse --short HEAD)
            DO_MANAGED=$(echo "$CLEAN_JSON" | jq -r '.do_managed')
            DO_DESKTOP=$(echo "$CLEAN_JSON" | jq -r '.do_desktop')
            DO_MOBILE=$(echo "$CLEAN_JSON" | jq -r '.do_mobile')

            # Cloud Branch & Deployment
            if [ "$DO_MANAGED" == "true" ]; then
               echo "‚òÅÔ∏è  Pushing to cloud branch..."
               if [ -f "scripts/push-to-cloud-branch.sh" ]; then
                  chmod +x scripts/push-to-cloud-branch.sh
                  CLOUD_PUSH_PAT="${{ steps.mint_identity_token.outputs.token || secrets.GITHUB_TOKEN }}" ./scripts/push-to-cloud-branch.sh "$NEW_VERSION"
               else
                  git checkout -B cloud main
                  git push -f origin cloud
                  git tag "${NEW_VERSION}-cloud-${SHORT_SHA}" -f
                  git push origin "${NEW_VERSION}-cloud-${SHORT_SHA}" -f
                  git checkout main
               fi
               
               echo "üöÄ Triggering AKS deployment..."
               curl -X POST \
                  -H "Authorization: token ${{ steps.mint_identity_token.outputs.token || secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  -H "Content-Type: application/json" \
                  "${{ github.api_url }}/repos/${{ github.repository }}/dispatches" \
                  -d "{\"event_type\":\"cloud-deploy-$NEW_VERSION\",\"client_payload\":{\"version\":\"$NEW_VERSION\",\"branch\":\"cloud\"}}" || echo "‚ö†Ô∏è Failed to trigger dispatch"
            fi

            # Desktop Branch
            if [ "$DO_DESKTOP" == "true" ]; then
               echo "üñ•Ô∏è  Pushing to desktop branch..."
               git checkout -B desktop main
               git push -f origin desktop
               git tag "${NEW_VERSION}-desktop-${SHORT_SHA}" -f
               git push origin "${NEW_VERSION}-desktop-${SHORT_SHA}" -f
               git checkout main
            fi

            # Mobile Branch
            if [ "$DO_MOBILE" == "true" ]; then
               echo "üì± Pushing to mobile branch..."
               git checkout -B mobile main
               git push -f origin mobile
               git tag "${NEW_VERSION}-mobile-${SHORT_SHA}" -f
               git push origin "${NEW_VERSION}-mobile-${SHORT_SHA}" -f
               git checkout main
            fi
          fi

  # ==================================================================================
  # 3. CI/CD PIPELINE (Deployment)
  # ==================================================================================
  deploy:
    needs: [orchestrator]
    if: always() && needs.orchestrator.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    env:
      AZURE_RESOURCE_GROUP: cloudtolocalllm-rg
      ACR_NAME: imrightguycloudtolocalllm
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Setup ACR
        id: acr
        run: |
          az acr create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.ACR_NAME }} --sku Basic --admin-enabled true
          echo "server=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_OUTPUT
      - name: Build & Release
        run: |
          VERSION="v${{ needs.orchestrator.outputs.new_version }}"
          echo "Building $VERSION..."
          # Use edit if release exists, otherwise create
          if gh release view "$VERSION" >/dev/null 2>&1; then
            echo "Release $VERSION already exists. Updating..."
            gh release edit "$VERSION" --title "Release $VERSION (Updated)" --notes "${{ needs.orchestrator.outputs.reasoning }}"
          else
            echo "Creating new release $VERSION..."
            gh release create "$VERSION" --title "Release $VERSION" --notes "${{ needs.orchestrator.outputs.reasoning }}"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
