name: 'ðŸ”€ Gemini Dispatch'

on:
  push:
    branches: [main]
  pull_request:
    types: [opened, reopened, synchronize]
  issues:
    types: [opened, reopened]
  issue_comment:
    types: [created]
  pull_request_review:
    types: [submitted]
  pull_request_review_comment:
    types: [created]

defaults:
  run:
    shell: 'bash'

jobs:
  # ==================================================================================
  # 1. CORE DISPATCHER (Issues, PR Comments, Reviews)
  # ==================================================================================
  dispatch:
    if: |- 
      github.event_name != 'push' && (
        (github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false) ||
        (github.event_name == 'issues') ||
        (github.event.sender.type == 'User' && startsWith(github.event.comment.body || github.event.review.body || github.event.issue.body, '@gemini-cli'))
      )
    runs-on: 'ubuntu-latest'
    permissions:
      contents: 'read'
      issues: 'write'
      pull-requests: 'write'
    outputs:
      command: '${{ steps.extract_command.outputs.command }}'
      additional_context: '${{ steps.extract_command.outputs.additional_context }}'
    steps:
      - name: 'Mint identity token'
        id: 'mint_identity_token'
        if: vars.APP_ID != ''
        uses: 'actions/create-github-app-token@a8d616148505b5069dccd32f177bb87d7f39123b'
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'

      - name: 'Extract command'
        id: 'extract_command'
        uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea'
        env:
          EVENT_TYPE: '${{ github.event_name }}.${{ github.event.action }}'
          REQUEST: '${{ github.event.comment.body || github.event.review.body || github.event.issue.body }}'
        with:
          script: |
            const eventType = process.env.EVENT_TYPE;
            const request = process.env.REQUEST || '';
            if (eventType === 'pull_request.opened') core.setOutput('command', 'review');
            else if (['issues.opened', 'issues.reopened'].includes(eventType)) core.setOutput('command', 'triage');
            else if (request.startsWith("@gemini-cli /review")) {
              core.setOutput('command', 'review');
              core.setOutput('additional_context', request.replace(/^@gemini-cli \/review/, '').trim());
            } else if (request.startsWith("@gemini-cli /triage")) core.setOutput('command', 'triage');
            else if (request.startsWith("@gemini-cli")) {
              core.setOutput('command', 'invoke');
              core.setOutput('additional_context', request.replace(/^@gemini-cli/, '').trim());
            } else core.setOutput('command', 'fallthrough');

      - name: 'Acknowledge'
        if: steps.extract_command.outputs.command != 'fallthrough'
        env:
          GITHUB_TOKEN: '${{ steps.mint_identity_token.outputs.token || secrets.GITHUB_TOKEN }}'
        run: |
          gh issue comment "${{ github.event.pull_request.number || github.event.issue.number }}" \
            --body "ðŸ¤– Received your request! Tracking progress [here](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" \
            --repo "${{ github.repository }}"

  # Sub-Dispatch Tasks
  review:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'review'
    uses: './.github/workflows/gemini-review.yml'
    permissions:
      contents: 'read'
      id-token: 'write'
      issues: 'write'
      pull-requests: 'write'
    with:
      additional_context: '${{ needs.dispatch.outputs.additional_context }}'
    secrets: inherit

  triage:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'triage'
    uses: './.github/workflows/gemini-triage.yml'
    permissions:
      contents: 'read'
      id-token: 'write'
      issues: 'write'
      pull-requests: 'write'
    with:
      additional_context: '${{ needs.dispatch.outputs.additional_context }}'
    secrets: inherit

  invoke:
    needs: dispatch
    if: needs.dispatch.outputs.command == 'invoke'
    uses: './.github/workflows/gemini-invoke.yml'
    permissions:
      contents: 'write'
      id-token: 'write'
      issues: 'write'
      pull-requests: 'write'
    with:
      additional_context: '${{ needs.dispatch.outputs.additional_context }}'
    secrets: inherit

  # ==================================================================================
  # 2. PUSH ORCHESTRATOR (Automated Release Analysis)
  # ==================================================================================
  orchestrator:
    if: github.event_name == 'push' && !contains(github.event.head_commit.message, '[skip ci]')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    outputs:
      new_version: ${{ steps.exec.outputs.new_version }}
      docker_version: ${{ steps.exec.outputs.docker_version }}
      do_managed: ${{ steps.exec.outputs.do_managed }}
      do_local: ${{ steps.exec.outputs.do_local }}
      do_desktop: ${{ steps.exec.outputs.do_desktop }}
      do_mobile: ${{ steps.exec.outputs.do_mobile }}
      should_deploy: ${{ steps.exec.outputs.should_deploy }}
      reasoning: ${{ steps.exec.outputs.reasoning }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 50
          fetch-tags: true

      - name: 'Mint identity token'
        id: 'mint_identity_token'
        if: vars.APP_ID != ''
        uses: 'actions/create-github-app-token@a8d616148505b5069dccd32f177bb87d7f39123b'
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'

      - name: 'Run Analysis'
        id: 'analysis'
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          set -e
          
          # 1. Credential Setup & Debug
          if [ -n "$GEMINI_API_KEY" ]; then
            echo "âœ… GEMINI_API_KEY found in secrets (length: ${#GEMINI_API_KEY})"
            export GOOGLE_API_KEY="$GEMINI_API_KEY"
          else
            echo "âŒ Error: GEMINI_API_KEY secret is missing or empty."
            echo "   Available secrets: $(env | grep -i api_key | awk -F= '{print $1}' | tr '\n' ' ')"
            exit 1
          fi

          # 2. Setup: Tools
          if ! command -v jq &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          fi

          if ! command -v gemini &> /dev/null; then
             echo "Installing Gemini CLI..."
             npm install -g @google/gemini-cli@latest || (sleep 5 && npm install -g @google/gemini-cli@latest)
          fi

          cat << 'EOF' > prompt.txt
          Analyze the following project state and determine the release strategy.
          1. Read 'assets/version.json' for the current version.
          2. Check 'git log --oneline --no-merges -5' for recent context.
          3. Check 'git diff --name-only HEAD~1..HEAD' for changed files.

          Return ONLY a valid JSON object with these keys:
          {
            "new_version": "string (next semantic version)",
            "docker_version": "string (docker-safe version)",
            "do_managed": "true/false",
            "do_local": "true/false",
            "do_desktop": "true/false",
            "do_mobile": "true/false",
            "should_deploy": "true/false",
            "version_bump_needed": "true/false",
            "reasoning": "string"
          }
          EOF

          # 3. Execution: Retry Mechanism with Backoff
          echo "Running Gemini Analysis..."
          MAX_RETRIES=3
          RETRY_COUNT=0
          SUCCESS=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            # Run Gemini, capture both stdout and stderr
            if gemini --yolo --prompt "$(cat prompt.txt)" > gemini_output_raw.txt 2> gemini_stderr.log; then
              
              # 4. Sanitation: Extract JSON
              # Try to find JSON block, fallback to raw if not found
              sed -n '/{/,/}/p' gemini_output_raw.txt > gemini_output.json
              
              if [ ! -s gemini_output.json ]; then
                 cp gemini_output_raw.txt gemini_output.json
              fi

              # 5. Validation: Check if output is valid JSON
              if jq empty gemini_output.json >/dev/null 2>&1; then
                echo "âœ… Gemini Analysis Successful (Attempt $((RETRY_COUNT+1)))"
                SUCCESS=1
                break
              else
                echo "âš ï¸  Attempt $((RETRY_COUNT+1)): Invalid JSON output."
                echo "--- Raw Output ---"
                cat gemini_output_raw.txt
                echo "--- End ---"
              fi
            else
               echo "âš ï¸  Attempt $((RETRY_COUNT+1)): Gemini CLI failed."
               cat gemini_stderr.log
            fi
            
            RETRY_COUNT=$((RETRY_COUNT+1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              SLEEP_TIME=$((RETRY_COUNT * 5))
              echo "Retrying in ${SLEEP_TIME}s..."
              sleep $SLEEP_TIME
            fi
          done

          if [ $SUCCESS -eq 0 ]; then
            echo "âŒ Critical Error: Gemini Analysis failed after $MAX_RETRIES attempts."
            exit 1 # Fail fast
          fi

          echo "::: Gemini Output :::"
          cat gemini_output.json

      - name: 'Execute Logic'
        id: 'exec'
        env:
          GITHUB_TOKEN: '${{ steps.mint_identity_token.outputs.token || secrets.GITHUB_TOKEN }}'
        run: |
          set -e
          CLEAN_JSON=$(sed -n '/{/,/}/p' gemini_output.json)
          echo "new_version=$(echo "$CLEAN_JSON" | jq -r '.new_version')" >> $GITHUB_OUTPUT
          echo "docker_version=$(echo "$CLEAN_JSON" | jq -r '.docker_version')" >> $GITHUB_OUTPUT
          echo "do_managed=$(echo "$CLEAN_JSON" | jq -r '.do_managed')" >> $GITHUB_OUTPUT
          echo "do_local=$(echo "$CLEAN_JSON" | jq -r '.do_local')" >> $GITHUB_OUTPUT
          echo "do_desktop=$(echo "$CLEAN_JSON" | jq -r '.do_desktop')" >> $GITHUB_OUTPUT
          echo "do_mobile=$(echo "$CLEAN_JSON" | jq -r '.do_mobile')" >> $GITHUB_OUTPUT
          echo "should_deploy=$(echo "$CLEAN_JSON" | jq -r '.should_deploy')" >> $GITHUB_OUTPUT
          echo "reasoning=$(echo "$CLEAN_JSON" | jq -r '.reasoning')" >> $GITHUB_OUTPUT

          if [ "$(echo "$CLEAN_JSON" | jq -r '.version_bump_needed')" == "true" ]; then
            git config user.name "gemini-cli[bot]"
            git config user.email "gemini-cli[bot]@users.noreply.github.com"
            chmod +x scripts/update-all-versions.sh
            ./scripts/update-all-versions.sh "$(echo "$CLEAN_JSON" | jq -r '.new_version')" "${{ github.sha }}"
            git add -A
            git commit -m "chore: bump version to $(echo "$CLEAN_JSON" | jq -r '.new_version') [skip ci]"
            git push origin main && git tag "v$(echo "$CLEAN_JSON" | jq -r '.new_version')" -f && git push origin --tags -f

            # --- Platform Distribution ---
            NEW_VERSION=$(echo "$CLEAN_JSON" | jq -r '.new_version')
            SHORT_SHA=$(git rev-parse --short HEAD)
            DO_MANAGED=$(echo "$CLEAN_JSON" | jq -r '.do_managed')
            DO_DESKTOP=$(echo "$CLEAN_JSON" | jq -r '.do_desktop')
            DO_MOBILE=$(echo "$CLEAN_JSON" | jq -r '.do_mobile')

            # Cloud Branch & Deployment
            if [ "$DO_MANAGED" == "true" ]; then
               echo "â˜ï¸  Pushing to cloud branch..."
               if [ -f "scripts/push-to-cloud-branch.sh" ]; then
                  chmod +x scripts/push-to-cloud-branch.sh
                  CLOUD_PUSH_PAT="${{ steps.mint_identity_token.outputs.token || secrets.GITHUB_TOKEN }}" ./scripts/push-to-cloud-branch.sh "$NEW_VERSION"
               else
                  git checkout -B cloud main
                  git push -f origin cloud
                  git tag "${NEW_VERSION}-cloud-${SHORT_SHA}" -f
                  git push origin "${NEW_VERSION}-cloud-${SHORT_SHA}" -f
                  git checkout main
               fi
               
               echo "ðŸš€ Triggering AKS deployment..."
               curl -X POST \
                  -H "Authorization: token ${{ steps.mint_identity_token.outputs.token || secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  -H "Content-Type: application/json" \
                  "${{ github.api_url }}/repos/${{ github.repository }}/dispatches" \
                  -d "{\"event_type\":\"cloud-deploy-$NEW_VERSION\",\"client_payload\":{\"version\":\"$NEW_VERSION\",\"branch\":\"cloud\"}}" || echo "âš ï¸ Failed to trigger dispatch"
            fi

            # Desktop Branch
            if [ "$DO_DESKTOP" == "true" ]; then
               echo "ðŸ–¥ï¸  Pushing to desktop branch..."
               git checkout -B desktop main
               git push -f origin desktop
               git tag "${NEW_VERSION}-desktop-${SHORT_SHA}" -f
               git push origin "${NEW_VERSION}-desktop-${SHORT_SHA}" -f
               git checkout main
            fi

            # Mobile Branch
            if [ "$DO_MOBILE" == "true" ]; then
               echo "ðŸ“± Pushing to mobile branch..."
               git checkout -B mobile main
               git push -f origin mobile
               git tag "${NEW_VERSION}-mobile-${SHORT_SHA}" -f
               git push origin "${NEW_VERSION}-mobile-${SHORT_SHA}" -f
               git checkout main
            fi
          fi

  # ==================================================================================
  # 3. CI/CD PIPELINE (Deployment)
  # ==================================================================================
  deploy:
    needs: [orchestrator]
    if: always() && needs.orchestrator.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    env:
      AZURE_RESOURCE_GROUP: cloudtolocalllm-rg
      ACR_NAME: imrightguycloudtolocalllm
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Setup ACR
        id: acr
        run: |
          az acr create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.ACR_NAME }} --sku Basic --admin-enabled true
          echo "server=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_OUTPUT
      - name: Build & Release
        run: |
          echo "Building v${{ needs.orchestrator.outputs.new_version }}"...
          gh release create "v${{ needs.orchestrator.outputs.new_version }}" --title "Release v${{ needs.orchestrator.outputs.new_version }}" --notes "${{ needs.orchestrator.outputs.reasoning }}"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}