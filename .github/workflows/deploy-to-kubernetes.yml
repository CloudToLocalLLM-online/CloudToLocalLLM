name: Deploy to DigitalOcean Kubernetes

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  REGISTRY: registry.digitalocean.com/cloudtolocalllm
  CLUSTER_NAME: cloudtolocalllm
  NAMESPACE: cloudtolocalllm

jobs:
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Log in to DigitalOcean Container Registry
        run: doctl registry login --expiry-seconds 1200

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        id: meta
        run: |
          VERSION=$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA::7}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Build and push Web image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./config/docker/Dockerfile.web
          push: true
          tags: |
            ${{ env.REGISTRY }}/web:latest
            ${{ env.REGISTRY }}/web:${{ steps.meta.outputs.version }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/web:latest
          cache-to: type=inline

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./services/api-backend/Dockerfile.prod
          push: true
          tags: |
            ${{ env.REGISTRY }}/api:latest
            ${{ env.REGISTRY }}/api:${{ steps.meta.outputs.version }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/api:latest
          cache-to: type=inline

  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: 
      name: ${{ github.event.inputs.environment || 'production' }}
      url: https://app.${{ secrets.DOMAIN }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Save kubeconfig
        run: doctl kubernetes cluster kubeconfig save ${{ env.CLUSTER_NAME }}

      - name: Create namespace if not exists
        run: kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create secrets
        run: |
          kubectl create secret generic cloudtolocalllm-secrets \
            --from-literal=postgres-password='${{ secrets.POSTGRES_PASSWORD }}' \
            --from-literal=jwt-secret='${{ secrets.JWT_SECRET }}' \
            --from-literal=supertokens-api-key='${{ secrets.SUPERTOKENS_API_KEY }}' \
            --from-literal=auth0-domain='${{ secrets.AUTH0_DOMAIN }}' \
            --from-literal=auth0-audience='${{ secrets.AUTH0_AUDIENCE }}' \
            --from-literal=sentry-dsn='${{ secrets.SENTRY_DSN }}' \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Update ConfigMap with domain
        run: |
          sed -i 's/DOMAIN: "cloudtolocalllm.online"/DOMAIN: "${{ secrets.DOMAIN }}"/' k8s/configmap.yaml
          kubectl apply -f k8s/configmap.yaml

      - name: Update image references
        run: |
          sed -i 's|YOUR_REGISTRY|${{ env.REGISTRY }}|g' k8s/api-backend-deployment.yaml
          sed -i 's|YOUR_REGISTRY|${{ env.REGISTRY }}|g' k8s/web-deployment.yaml
          sed -i 's|cloudtolocalllm.online|${{ secrets.DOMAIN }}|g' k8s/ingress-nginx.yaml
          sed -i 's|admin@cloudtolocalllm.online|admin@${{ secrets.DOMAIN }}|g' k8s/cert-manager.yaml

      - name: Deploy PostgreSQL
        run: kubectl apply -f k8s/postgres-statefulset.yaml

      - name: Wait for PostgreSQL
        run: |
          kubectl wait --for=condition=ready pod -l app=postgres \
            --namespace=${{ env.NAMESPACE }} \
            --timeout=300s

      - name: Deploy API Backend
        run: |
          kubectl apply -f k8s/api-backend-deployment.yaml
          kubectl set image deployment/api-backend \
            api-backend=${{ env.REGISTRY }}/api:${{ needs.build-and-push.outputs.image_tag }} \
            --namespace=${{ env.NAMESPACE }}

      - name: Deploy Web Application
        run: |
          kubectl apply -f k8s/web-deployment.yaml
          kubectl set image deployment/web \
            web=${{ env.REGISTRY }}/web:${{ needs.build-and-push.outputs.image_tag }} \
            --namespace=${{ env.NAMESPACE }}

      - name: Deploy Ingress
        run: |
          kubectl apply -f k8s/cert-manager.yaml
          kubectl apply -f k8s/ingress-nginx.yaml

      - name: Wait for deployments
        run: |
          kubectl rollout status deployment/api-backend --namespace=${{ env.NAMESPACE }} --timeout=300s
          kubectl rollout status deployment/web --namespace=${{ env.NAMESPACE }} --timeout=300s

      - name: Get deployment status
        run: |
          echo "=== Pods ===" 
          kubectl get pods -n ${{ env.NAMESPACE }}
          echo "=== Services ===" 
          kubectl get svc -n ${{ env.NAMESPACE }}
          echo "=== Ingress ===" 
          kubectl get ingress -n ${{ env.NAMESPACE }}

      - name: Health check
        run: |
          # Get load balancer IP
          LB_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Load Balancer IP: $LB_IP"
          
          # Wait for services to be ready (retry for 2 minutes)
          for i in {1..24}; do
            if curl -f -k https://${{ secrets.DOMAIN }}/health 2>/dev/null; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Waiting for services to be ready... ($i/24)"
            sleep 5
          done
          
          echo "Warning: Health check did not pass within timeout. Check DNS propagation."

      - name: Deployment summary
        if: always()
        run: |
          echo "### Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${{ needs.build-and-push.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster**: ${{ env.CLUSTER_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ env.NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Domain**: https://${{ secrets.DOMAIN }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Pods:**" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ env.NAMESPACE }} >> $GITHUB_STEP_SUMMARY || true

