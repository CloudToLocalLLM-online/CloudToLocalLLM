name: Unified Deployment Workflow

on:
  push:
    branches:
      - main
    # Don't trigger on version bump commits
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.gitignore'
      - 'LICENSE'
  workflow_dispatch:
    inputs:
      force_deployment:
        description: "Force deployment even if no changes detected"
        required: false
        default: false
        type: boolean
      deployment_type:
        description: "Override deployment type (cloud, desktop, mobile, all)"
        required: false
        default: "auto"
        type: choice
        options:
          - auto
          - cloud
          - desktop
          - mobile
          - all

# Prevent multiple deployments running simultaneously
concurrency:
  group: unified-deployment
  cancel-in-progress: false

permissions:
  contents: write
  id-token: write

env:
  # Azure AKS (Current Production Infrastructure)
  AZURE_RESOURCE_GROUP: cloudtolocalllm-rg
  AZURE_CLUSTER_NAME: cloudtolocalllm-aks
  ACR_NAME: imrightguycloudtolocalllm

jobs:
  # AI Analysis and Version Management
  ai_analysis:
    if: ${{ !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[no-version]') }}
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.analyze.outputs.new_version }}
      needs_cloud: ${{ steps.analyze.outputs.needs_cloud }}
      needs_desktop: ${{ steps.analyze.outputs.needs_desktop }}
      needs_mobile: ${{ steps.analyze.outputs.needs_mobile }}
      reasoning: ${{ steps.analyze.outputs.reasoning }}
      should_deploy: ${{ steps.decision.outputs.should_deploy }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 50
          fetch-tags: true
          token: "${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}"

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Setup Kilocode CLI
        run: |
          chmod +x scripts/kilocode-cli.cjs
          sudo ln -sf "$(pwd)/scripts/kilocode-cli.cjs" /usr/local/bin/kilocode-cli
          kilocode-cli "Respond with just OK" && echo "âœ… Kilocode CLI test passed" || echo "âš ï¸  Kilocode test failed"
          echo "âœ… Kilocode CLI ready"

      - name: Install jq
        run: |
          if ! command -v jq &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          fi
          jq --version

      - name: AI Analysis with Kilocode
        id: analyze
        run: |
          chmod +x scripts/analyze-platforms.sh
          ./scripts/analyze-platforms.sh

      - name: Make Deployment Decision
        id: decision
        env:
          FORCE_DEPLOYMENT: ${{ github.event.inputs.force_deployment }}
          DEPLOYMENT_TYPE: ${{ github.event.inputs.deployment_type }}
          NEEDS_CLOUD: ${{ steps.analyze.outputs.needs_cloud }}
          NEEDS_DESKTOP: ${{ steps.analyze.outputs.needs_desktop }}
          NEEDS_MOBILE: ${{ steps.analyze.outputs.needs_mobile }}
        run: |
          # Determine if we should deploy
          SHOULD_DEPLOY="false"
          
          # Force deployment if requested
          if [ "$FORCE_DEPLOYMENT" = "true" ]; then
            SHOULD_DEPLOY="true"
            echo "ðŸ”§ Force deployment requested"
          fi
          
          # Deploy if AI detected changes
          if [ "$NEEDS_CLOUD" = "true" ] || [ "$NEEDS_DESKTOP" = "true" ] || [ "$NEEDS_MOBILE" = "true" ]; then
            SHOULD_DEPLOY="true"
            echo "ðŸ¤– AI detected changes requiring deployment"
          fi
          
          # Override deployment type if specified
          if [ "$DEPLOYMENT_TYPE" != "auto" ]; then
            echo "ðŸŽ¯ Deployment type override: $DEPLOYMENT_TYPE"
            case "$DEPLOYMENT_TYPE" in
              "cloud")
                echo "needs_cloud=true" >> $GITHUB_OUTPUT
                echo "needs_desktop=false" >> $GITHUB_OUTPUT
                echo "needs_mobile=false" >> $GITHUB_OUTPUT
                ;;
              "desktop")
                echo "needs_cloud=false" >> $GITHUB_OUTPUT
                echo "needs_desktop=true" >> $GITHUB_OUTPUT
                echo "needs_mobile=false" >> $GITHUB_OUTPUT
                ;;
              "mobile")
                echo "needs_cloud=false" >> $GITHUB_OUTPUT
                echo "needs_desktop=false" >> $GITHUB_OUTPUT
                echo "needs_mobile=true" >> $GITHUB_OUTPUT
                ;;
              "all")
                echo "needs_cloud=true" >> $GITHUB_OUTPUT
                echo "needs_desktop=true" >> $GITHUB_OUTPUT
                echo "needs_mobile=true" >> $GITHUB_OUTPUT
                ;;
            esac
            SHOULD_DEPLOY="true"
          fi
          
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Deployment Decision Summary"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Should Deploy: $SHOULD_DEPLOY"
          echo "Cloud: ${NEEDS_CLOUD}"
          echo "Desktop: ${NEEDS_DESKTOP}"
          echo "Mobile: ${NEEDS_MOBILE}"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Update Version Files
        if: steps.decision.outputs.should_deploy == 'true'
        env:
          NEW_VERSION: "${{ steps.analyze.outputs.new_version }}"
          COMMIT_SHA: "${{ github.sha }}"
        run: |
          chmod +x scripts/update-all-versions.sh
          ./scripts/update-all-versions.sh "$NEW_VERSION" "$COMMIT_SHA"

      - name: Commit Version Changes
        if: steps.decision.outputs.should_deploy == 'true'
        env:
          NEW_VERSION: "${{ steps.analyze.outputs.new_version }}"
        run: |
          # Commit version changes to main
          git add -A
          if ! git diff --cached --quiet; then
            git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
            git push origin main
            
            # Create version tag
            git tag "v$NEW_VERSION" -f
            git push origin "v$NEW_VERSION" -f
            echo "âœ… Version $NEW_VERSION committed and tagged"
          else
            echo "â„¹ï¸  No version changes to commit"
          fi

  # Changes job removed - AI analysis already determines what needs to be built

  # Setup ACR and retrieve login server
  setup_acr:
    needs: ai_analysis
    if: ${{ needs.ai_analysis.outputs.should_deploy == 'true' && needs.ai_analysis.outputs.needs_cloud == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      login_server: ${{ steps.acr_setup.outputs.login_server }}
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Create Azure Resource Group if not exists
        run: az group create --name ${{ env.AZURE_RESOURCE_GROUP }} --location eastus --query "properties.provisioningState" --output tsv
      - name: Setup ACR
        id: acr_setup
        run: |
          # Create ACR if not exists
          az acr create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.ACR_NAME }} --sku Basic --admin-enabled true --query "provisioningState" --output tsv
          # Get Login Server and set as output
          LOGIN_SERVER=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)
          echo "login_server=$LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "DOCKER_REGISTRY=$LOGIN_SERVER" >> $GITHUB_ENV
      - name: Docker Login to ACR
        run: |
          # Get ACR admin credentials
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          # Login to ACR
          echo "$ACR_PASSWORD" | docker login "${{ steps.acr_setup.outputs.login_server }}" --username "$ACR_USERNAME" --password-stdin

  build_base:
    needs: [ai_analysis, setup_acr]
    if: ${{ !cancelled() && needs.ai_analysis.outputs.needs_cloud == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login to ACR
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          echo "$ACR_PASSWORD" | docker login "${{ needs.setup_acr.outputs.login_server }}" --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: config/docker/Dockerfile.base
          push: true
          tags: |
            ${{ needs.setup_acr.outputs.login_server }}/base:${{ needs.ai_analysis.outputs.new_version }}-base
            ${{ needs.setup_acr.outputs.login_server }}/base:latest
          cache-from: type=registry,ref=${{ needs.setup_acr.outputs.login_server }}/base:latest
          cache-to: type=inline

  build_postgres:
    needs: [ai_analysis, setup_acr, build_base]
    if: ${{ !cancelled() && needs.ai_analysis.outputs.needs_cloud == 'true' && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login to ACR
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          echo "$ACR_PASSWORD" | docker login "${{ needs.setup_acr.outputs.login_server }}" --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: config/docker/Dockerfile.postgres
          push: true
          tags: |
            ${{ needs.setup_acr.outputs.login_server }}/postgres:${{ needs.ai_analysis.outputs.new_version }}-postgres
            ${{ needs.setup_acr.outputs.login_server }}/postgres:latest
          build-args: |
            BASE_REGISTRY=${{ needs.setup_acr.outputs.login_server }}
          cache-from: type=registry,ref=${{ needs.setup_acr.outputs.login_server }}/postgres:latest
          cache-to: type=inline

  build_web:
    needs: [ai_analysis, setup_acr, build_base]
    if: ${{ !cancelled() && needs.ai_analysis.outputs.needs_cloud == 'true' && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login to ACR
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          echo "$ACR_PASSWORD" | docker login "${{ needs.setup_acr.outputs.login_server }}" --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - name: Check if Flutter is already installed
        id: flutter_check
        run: |
          if command -v flutter >/dev/null 2>&1; then
            FLUTTER_VERSION=$(flutter --version | head -n1 || echo "unknown")
            echo "Flutter is already installed: $FLUTTER_VERSION"
            echo "flutter_installed=true" >> $GITHUB_OUTPUT
          else
            echo "Flutter not found, will install"
            echo "flutter_installed=false" >> $GITHUB_OUTPUT
          fi
      - name: Install Flutter (if needed)
        if: steps.flutter_check.outputs.flutter_installed != 'true'
        uses: subosito/flutter-action@v2
        with:
          channel: "stable"
          cache: true
      - name: Build Flutter Web
        run: |
          flutter pub get
          flutter build web --release --no-tree-shake-icons --base-href / --dart-define=FLUTTER_BUILD_NUMBER=${{ github.sha }}
      - name: Apply Cache Busting to index.html
        run: |
          sed -i "s|\$FLUTTER_BUILD_NUMBER|${{ github.sha }}|g" build/web/index.html
          sed -i "s|\$FLUTTER_BASE_HREF|/|g" build/web/index.html
      - name: Debug - Verify index.html cache busting
        run: |
          echo "Checking if cache-busting was applied:"
          grep "flutter_bootstrap.js" build/web/index.html
      - name: Debug - List web build
        run: ls -R build/web || echo "build/web not found"
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: web/Dockerfile
          push: true
          tags: |
            ${{ needs.setup_acr.outputs.login_server }}/web:${{ needs.ai_analysis.outputs.new_version }}
            ${{ needs.setup_acr.outputs.login_server }}/web:latest
          build-args: |
            BASE_REGISTRY=${{ needs.setup_acr.outputs.login_server }}
          cache-from: type=registry,ref=${{ needs.setup_acr.outputs.login_server }}/web:latest
          cache-to: type=inline

  build_api:
    needs: [ai_analysis, setup_acr, build_base]
    if: ${{ !cancelled() && needs.ai_analysis.outputs.needs_cloud == 'true' && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login to ACR
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          echo "$ACR_PASSWORD" | docker login "${{ needs.setup_acr.outputs.login_server }}" --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: services/api-backend
          file: services/api-backend/Dockerfile
          push: true
          tags: |
            ${{ needs.setup_acr.outputs.login_server }}/api-backend:${{ needs.ai_analysis.outputs.new_version }}-api
            ${{ needs.setup_acr.outputs.login_server }}/api-backend:latest
          build-args: |
            BASE_REGISTRY=${{ needs.setup_acr.outputs.login_server }}
          cache-from: type=registry,ref=${{ needs.setup_acr.outputs.login_server }}/api-backend:latest
          cache-to: type=inline

  build_proxy:
    needs: [ai_analysis, setup_acr, build_base]
    if: ${{ !cancelled() && needs.ai_analysis.outputs.needs_cloud == 'true' && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login to ACR
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          echo "$ACR_PASSWORD" | docker login "${{ needs.setup_acr.outputs.login_server }}" --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: services/streaming-proxy
          file: services/streaming-proxy/Dockerfile
          push: true
          tags: |
            ${{ needs.setup_acr.outputs.login_server }}/streaming-proxy:${{ needs.ai_analysis.outputs.new_version }}-proxy
            ${{ needs.setup_acr.outputs.login_server }}/streaming-proxy:latest
          build-args: |
            BASE_REGISTRY=${{ needs.setup_acr.outputs.login_server }}
          cache-from: type=registry,ref=${{ needs.setup_acr.outputs.login_server }}/streaming-proxy:latest
          cache-to: type=inline

  # Cloud Deployment (conditional) - Azure AKS
  deploy_infrastructure:
    permissions:
      id-token: write
    needs: [ai_analysis, setup_acr, build_base, build_postgres, build_web, build_api, build_proxy]
    if: |
      !cancelled() &&
      needs.ai_analysis.outputs.needs_cloud == 'true' &&
      (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') &&
      (needs.build_postgres.result == 'success' || needs.build_postgres.result == 'skipped') &&
      (needs.build_web.result == 'success' || needs.build_web.result == 'skipped') &&
      (needs.build_api.result == 'success' || needs.build_api.result == 'skipped') &&
      (needs.build_proxy.result == 'success' || needs.build_proxy.result == 'skipped')
    runs-on: ubuntu-latest
    outputs:
      cache_purge_status: ${{ steps.cache_purge.outputs.cache_purge_status }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.AZURE_RESOURCE_GROUP }}
          cluster-name: ${{ env.AZURE_CLUSTER_NAME }}

      - name: Ensure Namespace Exists
        run: |
          kubectl create namespace cloudtolocalllm --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          STRIPE_TEST_SECRET_KEY: ${{ secrets.STRIPE_TEST_SECRET_KEY }}
          STRIPE_TEST_PUBLISHABLE_KEY: ${{ secrets.STRIPE_TEST_PUBLISHABLE_KEY }}
          STRIPE_TEST_WEBHOOK_SECRET: ${{ secrets.STRIPE_TEST_WEBHOOK_SECRET }}
          STRIPE_LIVE_SECRET_KEY: ${{ secrets.STRIPE_LIVE_SECRET_KEY }}
          STRIPE_LIVE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_LIVE_PUBLISHABLE_KEY }}
          STRIPE_LIVE_WEBHOOK_SECRET: ${{ secrets.STRIPE_LIVE_WEBHOOK_SECRET }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
          CLOUDFLARE_DNS_TOKEN: ${{ secrets.CLOUDFLARE_DNS_TOKEN }}
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          SUPABASE_JWT_SECRET: ${{ secrets.SUPABASE_JWT_SECRET }}
          AUTH0_DOMAIN: ${{ secrets.AUTH0_DOMAIN }}
          AUTH0_AUDIENCE: ${{ secrets.AUTH0_AUDIENCE }}
          AUTH0_CLIENT_ID: ${{ secrets.AUTH0_CLIENT_ID }}
          AUTH0_CLIENT_SECRET: ${{ secrets.AUTH0_CLIENT_SECRET }}
          AUTH0_ISSUER_URL: ${{ secrets.AUTH0_ISSUER_URL }}
        run: |
          # Get ACR Admin Credentials
          ACR_ADMIN_USER=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_ADMIN_PASS=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)

          # Docker Registry Secret for ACR
          kubectl create secret docker-registry regcred \
            --docker-server=${{ needs.setup_acr.outputs.login_server }} \
            --docker-username=$ACR_ADMIN_USER \
            --docker-password=$ACR_ADMIN_PASS \
            --docker-email=github-actions@cloudtolocalllm.online \
            -n cloudtolocalllm --dry-run=client -o yaml | kubectl apply -f -

          # App Secrets
          kubectl create secret generic cloudtolocalllm-secrets \
            --namespace cloudtolocalllm \
            --from-literal=postgres-user=cloud_admin \
            --from-literal=postgres-password="$POSTGRES_PASSWORD" \
            --from-literal=jwt-secret="$JWT_SECRET" \
            --from-literal=stripe-test-secret-key="$STRIPE_TEST_SECRET_KEY" \
            --from-literal=stripe-test-publishable-key="$STRIPE_TEST_PUBLISHABLE_KEY" \
            --from-literal=stripe-test-webhook-secret="$STRIPE_TEST_WEBHOOK_SECRET" \
            --from-literal=stripe-live-secret-key="$STRIPE_LIVE_SECRET_KEY" \
            --from-literal=stripe-live-publishable-key="$STRIPE_LIVE_PUBLISHABLE_KEY" \
            --from-literal=stripe-live-webhook-secret="$STRIPE_LIVE_WEBHOOK_SECRET" \
            --from-literal=sentry-dsn="$SENTRY_DSN" \
            --from-literal=supabase-jwt-secret="$SUPABASE_JWT_SECRET" \
            --from-literal=supabase-url="https://cvaqhvpbnemweqrojasm.supabase.co" \
            --from-literal=auth0-domain="$AUTH0_DOMAIN" \
            --from-literal=auth0-audience="$AUTH0_AUDIENCE" \
            --from-literal=auth0-client-id="$AUTH0_CLIENT_ID" \
            --from-literal=auth0-client-secret="$AUTH0_CLIENT_SECRET" \
            --from-literal=auth0-issuer-url="$AUTH0_ISSUER_URL" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Cloudflare Tunnel Secret
          kubectl create secret generic tunnel-credentials \
            --namespace cloudtolocalllm \
            --from-literal=token="$CLOUDFLARE_TUNNEL_TOKEN" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Streaming Proxy Secret
          kubectl create secret generic streaming-proxy-secrets \
            --namespace cloudtolocalllm \
            --from-literal=SENTRY_DSN="$SENTRY_DSN" \
            --from-literal=SUPABASE_JWT_SECRET="$SUPABASE_JWT_SECRET" \
            --from-literal=SUPABASE_URL="https://cvaqhvpbnemweqrojasm.supabase.co" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Manifests
        env:
          NEEDS_CLOUD: ${{ needs.ai_analysis.outputs.needs_cloud }}
          APP_VERSION: ${{ needs.ai_analysis.outputs.new_version }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          set -e

          # Use semantic version tags for all services when cloud deployment is needed
          POSTGRES_TAG="${APP_VERSION}-postgres"
          WEB_TAG="${APP_VERSION}"
          API_TAG="${APP_VERSION}-api"
          PROXY_TAG="${APP_VERSION}-proxy"

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Deployment Version: $APP_VERSION"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "  Postgres: $POSTGRES_TAG"
          echo "  Web:      $WEB_TAG"
          echo "  API:      $API_TAG"
          echo "  Proxy:    $PROXY_TAG"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""

          # Replace image registry in manifests
          sed -i "s|cloudtolocalllm/postgres:latest|${{ needs.setup_acr.outputs.login_server }}/postgres:${POSTGRES_TAG}|g" k8s/postgres-statefulset.yaml
          sed -i "s|cloudtolocalllm/web:latest|${{ needs.setup_acr.outputs.login_server }}/web:${WEB_TAG}|g" k8s/web-deployment.yaml
          sed -i "s|cloudtolocalllm/api-backend:latest|${{ needs.setup_acr.outputs.login_server }}/api-backend:${API_TAG}|g" k8s/api-backend-deployment.yaml
          sed -i "s|cloudtolocalllm/streaming-proxy:latest|${{ needs.setup_acr.outputs.login_server }}/streaming-proxy:${PROXY_TAG}|g" k8s/streaming-proxy-deployment.yaml

          # Validate manifests with server-side dry-run before applying
          echo "Validating Kubernetes manifests with server-side dry-run..."
          kubectl apply --dry-run=server -f k8s/rbac.yaml
          kubectl apply --dry-run=server -f k8s/configmap.yaml
          kubectl apply --dry-run=server -f k8s/streaming-proxy-configmap.yaml
          kubectl apply --dry-run=server -f k8s/postgres-statefulset.yaml
          kubectl apply --dry-run=server -f k8s/cloudflared.yaml
          kubectl apply --dry-run=server -f k8s/web-deployment.yaml
          kubectl apply --dry-run=server -f k8s/api-backend-deployment.yaml
          kubectl apply --dry-run=server -f k8s/streaming-proxy-deployment.yaml

          # Apply RBAC and ConfigMaps first
          kubectl apply -f k8s/rbac.yaml
          kubectl apply -f k8s/configmap.yaml
          kubectl apply -f k8s/streaming-proxy-configmap.yaml
          
          # ===== STEP 1: Deploy and wait for PostgreSQL (all services depend on it) =====
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "STEP 1: Deploying PostgreSQL (all services depend on this)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          kubectl apply -f k8s/postgres-statefulset.yaml
          
          # Add annotation to force update
          kubectl annotate statefulset postgres -n cloudtolocalllm \
            deployment.kubernetes.io/revision="${{ github.sha }}" \
            deployment.kubernetes.io/timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --overwrite
          
          # Force delete postgres pod to ensure it picks up new spec (if it exists)
          kubectl delete pod postgres-0 -n cloudtolocalllm --force --grace-period=0 2>/dev/null || true
          kubectl rollout restart statefulset/postgres -n cloudtolocalllm
          
          # Wait for postgres to be ready before proceeding
          echo "Waiting for PostgreSQL to be ready..."
          chmod +x scripts/watch_rollout.sh
          ./scripts/watch_rollout.sh cloudtolocalllm statefulset postgres
          
          echo "âœ… PostgreSQL is ready"
          echo ""
          
          # ===== STEP 2: Deploy API Backend (depends on postgres) =====
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "STEP 2: Deploying API Backend (depends on postgres)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          kubectl apply -f k8s/api-backend-deployment.yaml
          
          # Add annotation to force update
          kubectl annotate deployment api-backend -n cloudtolocalllm \
            deployment.kubernetes.io/revision="${{ github.sha }}" \
            deployment.kubernetes.io/timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --overwrite
          
          # Trigger rolling update
          kubectl rollout restart deployment/api-backend -n cloudtolocalllm
          
          echo "Waiting for API Backend to be ready..."
          ./scripts/watch_rollout.sh cloudtolocalllm deployment api-backend
          echo "âœ… API Backend is ready"
          echo ""
          
          # ===== STEP 3: Deploy Streaming Proxy (depends on api-backend) =====
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "STEP 3: Deploying Streaming Proxy (depends on api-backend)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          kubectl apply -f k8s/streaming-proxy-deployment.yaml
          
          # Add annotation to force update
          kubectl annotate deployment streaming-proxy -n cloudtolocalllm \
            deployment.kubernetes.io/revision="${{ github.sha }}" \
            deployment.kubernetes.io/timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --overwrite
          
          # Trigger rolling update
          kubectl rollout restart deployment/streaming-proxy -n cloudtolocalllm
          
          echo "Waiting for Streaming Proxy to be ready..."
          ./scripts/watch_rollout.sh cloudtolocalllm deployment streaming-proxy
          echo "âœ… Streaming Proxy is ready"
          echo ""
          
          # ===== STEP 4: Deploy Web and Cloudflared (depend on api-backend and streaming) =====
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "STEP 4: Deploying Web Frontend and Cloudflared"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          kubectl apply -f k8s/web-deployment.yaml
          kubectl apply -f k8s/cloudflared.yaml
          
          # Add annotations to force updates
          kubectl annotate deployment web -n cloudtolocalllm \
            deployment.kubernetes.io/revision="${{ github.sha }}" \
            deployment.kubernetes.io/timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --overwrite
          
          kubectl annotate deployment cloudflared -n cloudtolocalllm \
            deployment.kubernetes.io/revision="${{ github.sha }}" \
            deployment.kubernetes.io/timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --overwrite
          
          # Trigger rolling updates
          kubectl rollout restart deployment/web -n cloudtolocalllm
          kubectl rollout restart deployment/cloudflared -n cloudtolocalllm
          
          echo "Waiting for Web to be ready..."
          ./scripts/watch_rollout.sh cloudtolocalllm deployment web
          echo "âœ… Web is ready"
          echo ""
          
          echo "âœ… All services deployed successfully in dependency order:"
          echo "   1. PostgreSQL"
          echo "   2. API Backend"
          echo "   3. Streaming Proxy"
          echo "   4. Web + Cloudflared"

      - name: Verify Deployment
        run: |
          echo "Waiting for health check..."
          for i in {1..24}; do
            http_status=$(curl -s -o /dev/null -w "%{http_code}" https://app.cloudtolocalllm.online/health || echo "000")
            if [ "$http_status" = "200" ]; then
              echo "âœ… Health check passed with HTTP 200"
              exit 0
            fi
            echo "Attempt $i/24: Health check returned HTTP $http_status, waiting 5s..."
            sleep 5
          done
          echo "âŒ Health check failed after 2 minutes"
          exit 1

      - name: Purge Cloudflare Cache
        id: cache_purge
        continue-on-error: true
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          chmod +x scripts/cloudflare-cache-purge.sh
          if ./scripts/cloudflare-cache-purge.sh; then
            echo "cache_purge_status=success" >> $GITHUB_OUTPUT
            echo "âœ… Cloudflare cache purged successfully"
          else
            echo "cache_purge_status=failed" >> $GITHUB_OUTPUT
            echo "âŒ WARNING: Cloudflare cache purge failed - users may see stale content"
            echo "::warning::Cloudflare cache purge failed after 3 attempts. Users may see cached content until cache expires naturally."
          fi

  # Desktop Build (conditional) - Enhanced with comprehensive monitoring and optimization
  build_desktop:
    needs: ai_analysis
    if: ${{ needs.ai_analysis.outputs.should_deploy == 'true' && needs.ai_analysis.outputs.needs_desktop == 'true' }}
    runs-on: windows-2022  # Use specific version for better stability
    timeout-minutes: 45    # Increased timeout for comprehensive build process
    
    steps:
      - uses: actions/checkout@v4
      
      - name: System Resource Check
        run: |
          Write-Host "=== System Resources Before Build ===" -ForegroundColor Green
          Get-ComputerInfo | Select-Object TotalPhysicalMemory, AvailablePhysicalMemory
          Get-WmiObject -Class Win32_LogicalDisk | Select-Object DeviceID, Size, FreeSpace
          Write-Host "======================================" -ForegroundColor Green

      - name: Setup Flutter with Enhanced Caching
        uses: subosito/flutter-action@v2
        with:
          channel: "stable"
          cache: true
          cache-key: "flutter-${{ runner.os }}-${{ hashFiles('**/pubspec.lock') }}"
          cache-path: ${{ runner.tool_cache }}/flutter

      - name: Verify Flutter Installation
        timeout-minutes: 5
        run: |
          Write-Host "=== Flutter Environment Verification ===" -ForegroundColor Green
          flutter --version
          flutter doctor -v
          flutter config --enable-windows-desktop
          Write-Host "=========================================" -ForegroundColor Green

      - name: Clean Previous Build Artifacts
        timeout-minutes: 3
        run: |
          Write-Host "=== Cleaning Previous Build Artifacts ===" -ForegroundColor Green
          if (Test-Path "build") { Remove-Item -Recurse -Force "build" }
          if (Test-Path ".dart_tool") { Remove-Item -Recurse -Force ".dart_tool" }
          flutter clean
          Write-Host "==========================================" -ForegroundColor Green

      - name: Install Dependencies with Progress Monitoring
        timeout-minutes: 10
        run: |
          Write-Host "=== Installing Flutter Dependencies ===" -ForegroundColor Green
          $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
          
          # Run flutter pub get with verbose output
          flutter pub get --verbose
          
          $stopwatch.Stop()
          Write-Host "Dependencies installed in $($stopwatch.Elapsed.TotalSeconds) seconds" -ForegroundColor Green
          
          # Verify dependencies
          if (-not (Test-Path ".dart_tool/package_config.json")) {
            Write-Host "ERROR: Dependencies not properly installed" -ForegroundColor Red
            exit 1
          }
          Write-Host "=======================================" -ForegroundColor Green

      - name: Pre-build Resource Check
        run: |
          Write-Host "=== Resources After Dependencies ===" -ForegroundColor Green
          Get-ComputerInfo | Select-Object TotalPhysicalMemory, AvailablePhysicalMemory
          Get-WmiObject -Class Win32_LogicalDisk | Select-Object DeviceID, Size, FreeSpace
          Write-Host "====================================" -ForegroundColor Green

      - name: Build Windows Desktop Application
        timeout-minutes: 25
        run: |
          Write-Host "=== Starting Windows Desktop Build ===" -ForegroundColor Green
          $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
          
          # Build with optimized flags and progress monitoring
          try {
            flutter build windows --release --verbose `
              --split-debug-info=debug_info `
              --dart-define=FLUTTER_WEB_USE_SKIA=false `
              --dart-define=FLUTTER_BUILD_NUMBER=${{ github.sha }}
            
            $stopwatch.Stop()
            Write-Host "Windows build completed in $($stopwatch.Elapsed.TotalSeconds) seconds" -ForegroundColor Green
            
            # Verify build output
            if (-not (Test-Path "build/windows/x64/runner/Release")) {
              Write-Host "ERROR: Build output directory not found" -ForegroundColor Red
              exit 1
            }
            
            # Check for main executable
            if (-not (Test-Path "build/windows/x64/runner/Release/cloudtolocalllm.exe")) {
              Write-Host "ERROR: Main executable not found" -ForegroundColor Red
              Get-ChildItem "build/windows/x64/runner/Release" -Recurse
              exit 1
            }
            
            Write-Host "âœ… Windows build successful" -ForegroundColor Green
            
          } catch {
            Write-Host "ERROR during Windows build: $_" -ForegroundColor Red
            
            # Diagnostic information
            Write-Host "=== Build Failure Diagnostics ===" -ForegroundColor Yellow
            Get-ComputerInfo | Select-Object TotalPhysicalMemory, AvailablePhysicalMemory
            Get-WmiObject -Class Win32_LogicalDisk | Select-Object DeviceID, Size, FreeSpace
            
            if (Test-Path "build") {
              Write-Host "Build directory contents:" -ForegroundColor Yellow
              Get-ChildItem "build" -Recurse -ErrorAction SilentlyContinue
            }
            
            throw $_
          }
          Write-Host "======================================" -ForegroundColor Green

      - name: Create Distribution Package with Installer
        timeout-minutes: 10
        run: |
          Write-Host "=== Creating Complete Release Assets ===" -ForegroundColor Green
          
          # Use the comprehensive build script that creates both ZIP and installer
          $buildScript = "scripts/powershell/Build-GitHubReleaseAssets.ps1"
          
          if (-not (Test-Path $buildScript)) {
            Write-Host "ERROR: Build script not found: $buildScript" -ForegroundColor Red
            exit 1
          }
          
          Write-Host "Running comprehensive release assets builder..." -ForegroundColor Green
          
          # Run the script with appropriate parameters
          try {
            & $buildScript -SkipBuild -InstallInnoSetup
            Write-Host "âœ… Release assets created successfully" -ForegroundColor Green
          } catch {
            Write-Host "ERROR: Release assets creation failed: $($_.Exception.Message)" -ForegroundColor Red
            
            # Fallback: create just the portable ZIP if installer fails
            Write-Host "Attempting fallback to portable ZIP only..." -ForegroundColor Yellow
            & $buildScript -SkipBuild -SkipInstaller
          }
          
          # Verify assets were created
          if (Test-Path "dist/windows") {
            Write-Host "Created assets:" -ForegroundColor Green
            Get-ChildItem "dist/windows" | ForEach-Object {
              $size = if ($_.Length) { "$([math]::Round($_.Length / 1MB, 2)) MB" } else { "N/A" }
              Write-Host "  â€¢ $($_.Name) ($size)" -ForegroundColor Green
            }
          } else {
            Write-Host "ERROR: No assets were created" -ForegroundColor Red
            exit 1
          }
          
          Write-Host "=========================================" -ForegroundColor Green

      - name: Final Resource Check
        if: always()
        run: |
          Write-Host "=== Final System Resources ===" -ForegroundColor Green
          Get-ComputerInfo | Select-Object TotalPhysicalMemory, AvailablePhysicalMemory
          Get-WmiObject -Class Win32_LogicalDisk | Select-Object DeviceID, Size, FreeSpace
          Write-Host "===============================" -ForegroundColor Green

      - name: Upload Desktop Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-desktop-${{ needs.ai_analysis.outputs.new_version }}
          path: |
            dist/windows/*.zip
            dist/windows/*.exe
            dist/windows/*.sha256

  # Mobile Build (conditional - placeholder for future)
  build_mobile:
    needs: ai_analysis
    if: ${{ needs.ai_analysis.outputs.should_deploy == 'true' && needs.ai_analysis.outputs.needs_mobile == 'true' }}
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Mobile Build Placeholder
        run: |
          echo "ðŸš§ Mobile build not yet implemented"
          echo "This job will be expanded when mobile deployment is needed"

  # Create GitHub Release with Artifacts
  create_release:
    needs: [ai_analysis, deploy_infrastructure, build_desktop, build_mobile]
    if: |
      always() && 
      needs.ai_analysis.outputs.should_deploy == 'true' && 
      (needs.deploy_infrastructure.result == 'success' || needs.build_desktop.result == 'success')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Download Desktop Artifacts
        if: needs.build_desktop.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: windows-desktop-${{ needs.ai_analysis.outputs.new_version }}
          path: ./release-artifacts/
      
      - name: Prepare Release Assets
        env:
          NEW_VERSION: ${{ needs.ai_analysis.outputs.new_version }}
        run: |
          echo "Preparing release assets for version $NEW_VERSION"
          
          # Create release directory
          mkdir -p release-assets
          
          # Copy desktop artifacts if they exist
          if [ -d "./release-artifacts" ]; then
            cp -r ./release-artifacts/* ./release-assets/
            echo "âœ… Desktop artifacts prepared"
            ls -la ./release-assets/
          fi
          
          # Generate release notes
          cat > release-notes.md << EOF
          # CloudToLocalLLM v$NEW_VERSION
          
          ## What's New
          
          This release includes the latest updates and improvements to CloudToLocalLLM.
          
          ## Downloads
          
          - **Windows Desktop**: Download the portable zip package below
          - **Web Application**: Available at [app.cloudtolocalllm.online](https://app.cloudtolocalllm.online)
          
          ## Installation
          
          ### Windows Desktop
          1. Download \`cloudtolocalllm-$NEW_VERSION-portable.zip\`
          2. Extract to your desired location
          3. Run \`cloudtolocalllm.exe\`
          
          ## Verification
          
          All packages include SHA256 checksums for verification.
          
          ---
          
          **Full Changelog**: https://github.com/imrightguy/CloudToLocalLLM/compare/v4.3.0...v$NEW_VERSION
          EOF
          
          echo "âœ… Release notes generated"

      - name: Create GitHub Release
        env:
          NEW_VERSION: ${{ needs.ai_analysis.outputs.new_version }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Creating GitHub release for version $NEW_VERSION"
          
          # Create the release
          gh release create "v$NEW_VERSION" \
            --title "CloudToLocalLLM v$NEW_VERSION" \
            --notes-file release-notes.md \
            --draft=false \
            --prerelease=false
          
          echo "âœ… GitHub release v$NEW_VERSION created"

      - name: Upload Release Assets
        if: success()
        env:
          NEW_VERSION: ${{ needs.ai_analysis.outputs.new_version }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Uploading release assets..."
          
          # Upload all files in release-assets directory
          if [ -d "./release-assets" ] && [ "$(ls -A ./release-assets)" ]; then
            for file in ./release-assets/*; do
              if [ -f "$file" ]; then
                echo "Uploading $(basename "$file")..."
                gh release upload "v$NEW_VERSION" "$file"
              fi
            done
            echo "âœ… All release assets uploaded"
          else
            echo "â„¹ï¸ No release assets to upload"
          fi

  # Deployment Summary
  deployment_summary:
    needs: [ai_analysis, deploy_infrastructure, build_desktop, build_mobile, create_release]
    if: always() && needs.ai_analysis.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Generate Deployment Summary
        env:
          NEW_VERSION: ${{ needs.ai_analysis.outputs.new_version }}
          NEEDS_CLOUD: ${{ needs.ai_analysis.outputs.needs_cloud }}
          NEEDS_DESKTOP: ${{ needs.ai_analysis.outputs.needs_desktop }}
          NEEDS_MOBILE: ${{ needs.ai_analysis.outputs.needs_mobile }}
          REASONING: ${{ needs.ai_analysis.outputs.reasoning }}
          CLOUD_STATUS: ${{ needs.deploy_infrastructure.result }}
          DESKTOP_STATUS: ${{ needs.build_desktop.result }}
          MOBILE_STATUS: ${{ needs.build_mobile.result }}
          RELEASE_STATUS: ${{ needs.create_release.result }}
          CACHE_PURGE_STATUS: ${{ needs.deploy_infrastructure.outputs.cache_purge_status }}
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >> $GITHUB_STEP_SUMMARY
          echo "# Unified Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** $NEW_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**AI Reasoning:** $REASONING" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Platform Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$NEEDS_CLOUD" = "true" ]; then
            if [ "$CLOUD_STATUS" = "success" ]; then
              echo "â˜ï¸ **Cloud (Azure AKS):** âœ… Deployed successfully" >> $GITHUB_STEP_SUMMARY
              echo "   - Web: https://app.cloudtolocalllm.online" >> $GITHUB_STEP_SUMMARY
              echo "   - API: https://api.cloudtolocalllm.online" >> $GITHUB_STEP_SUMMARY
            else
              echo "â˜ï¸ **Cloud (Azure AKS):** âŒ Deployment failed" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "â˜ï¸ **Cloud (Azure AKS):** â­ï¸ Skipped (no changes detected)" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "$NEEDS_DESKTOP" = "true" ]; then
            if [ "$DESKTOP_STATUS" = "success" ]; then
              echo "ðŸ–¥ï¸ **Desktop:** âœ… Built successfully" >> $GITHUB_STEP_SUMMARY
            else
              echo "ðŸ–¥ï¸ **Desktop:** âŒ Build failed" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "ðŸ–¥ï¸ **Desktop:** â­ï¸ Skipped (no changes detected)" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "$NEEDS_MOBILE" = "true" ]; then
            echo "ðŸ“± **Mobile:** ðŸš§ Not yet implemented" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ“± **Mobile:** â­ï¸ Skipped (no changes detected)" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Release status
          if [ "$RELEASE_STATUS" = "success" ]; then
            echo "ðŸš€ **GitHub Release:** âœ… Created successfully" >> $GITHUB_STEP_SUMMARY
            echo "   - Release: https://github.com/imrightguy/CloudToLocalLLM/releases/tag/v$NEW_VERSION" >> $GITHUB_STEP_SUMMARY
          elif [ "$RELEASE_STATUS" = "failure" ]; then
            echo "ðŸš€ **GitHub Release:** âŒ Creation failed" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸš€ **GitHub Release:** â­ï¸ Skipped (no successful builds)" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Cache purge status
          if [ "$CACHE_PURGE_STATUS" = "success" ]; then
            echo "ðŸŒ **Cloudflare Cache:** âœ… Purged successfully" >> $GITHUB_STEP_SUMMARY
          elif [ "$CACHE_PURGE_STATUS" = "failed" ]; then
            echo "ðŸŒ **Cloudflare Cache:** âš ï¸ Purge failed - users may see stale content" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸŒ **Cloudflare Cache:** â­ï¸ Skipped (cloud deployment not run)" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >> $GITHUB_STEP_SUMMARY