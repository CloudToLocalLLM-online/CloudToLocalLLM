name: Unified Deployment Workflow

on:
  push:
    branches:
      - main
    # Don't trigger on version bump commits
    paths-ignore:
      - 'docs/**'
      - '*.md'
      - '.gitignore'
      - 'LICENSE'
  workflow_dispatch:
    inputs:
      force_deployment:
        description: "Force deployment even if no changes detected"
        required: false
        default: false
        type: boolean
      deployment_type:
        description: "Override deployment type (cloud, desktop, mobile, all)"
        required: false
        default: "auto"
        type: choice
        options:
          - auto
          - cloud
          - desktop
          - mobile
          - all

# Prevent multiple deployments running simultaneously
concurrency:
  group: unified-deployment
  cancel-in-progress: false

permissions:
  contents: write
  id-token: write

env:
  # Azure AKS (Current Production Infrastructure)
  AZURE_RESOURCE_GROUP: cloudtolocalllm-rg
  AZURE_CLUSTER_NAME: cloudtolocalllm-aks
  ACR_NAME: imrightguycloudtolocalllm

jobs:
  # AI Analysis and Version Management
  ai_analysis:
    if: ${{ !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[no-version]') }}
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.analyze.outputs.new_version }}
      needs_cloud: ${{ steps.analyze.outputs.needs_cloud }}
      needs_desktop: ${{ steps.analyze.outputs.needs_desktop }}
      needs_mobile: ${{ steps.analyze.outputs.needs_mobile }}
      reasoning: ${{ steps.analyze.outputs.reasoning }}
      should_deploy: ${{ steps.decision.outputs.should_deploy }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 50
          fetch-tags: true
          token: "${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}"

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Setup Kilocode CLI
        run: |
          chmod +x scripts/kilocode-cli.cjs
          sudo ln -sf "$(pwd)/scripts/kilocode-cli.cjs" /usr/local/bin/kilocode-cli
          kilocode-cli "Respond with just OK" && echo "âœ… Kilocode CLI test passed" || echo "âš ï¸  Kilocode test failed"
          echo "âœ… Kilocode CLI ready"

      - name: Install jq
        run: |
          if ! command -v jq &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          fi
          jq --version

      - name: AI Analysis with Kilocode
        id: analyze
        run: |
          chmod +x scripts/analyze-platforms.sh
          ./scripts/analyze-platforms.sh

      - name: Make Deployment Decision
        id: decision
        env:
          FORCE_DEPLOYMENT: ${{ github.event.inputs.force_deployment }}
          DEPLOYMENT_TYPE: ${{ github.event.inputs.deployment_type }}
          NEEDS_CLOUD: ${{ steps.analyze.outputs.needs_cloud }}
          NEEDS_DESKTOP: ${{ steps.analyze.outputs.needs_desktop }}
          NEEDS_MOBILE: ${{ steps.analyze.outputs.needs_mobile }}
        run: |
          # Determine if we should deploy
          SHOULD_DEPLOY="false"
          
          # Force deployment if requested
          if [ "$FORCE_DEPLOYMENT" = "true" ]; then
            SHOULD_DEPLOY="true"
            echo "ðŸ”§ Force deployment requested"
          fi
          
          # Deploy if AI detected changes
          if [ "$NEEDS_CLOUD" = "true" ] || [ "$NEEDS_DESKTOP" = "true" ] || [ "$NEEDS_MOBILE" = "true" ]; then
            SHOULD_DEPLOY="true"
            echo "ðŸ¤– AI detected changes requiring deployment"
          fi
          
          # Override deployment type if specified
          if [ "$DEPLOYMENT_TYPE" != "auto" ]; then
            echo "ðŸŽ¯ Deployment type override: $DEPLOYMENT_TYPE"
            case "$DEPLOYMENT_TYPE" in
              "cloud")
                echo "needs_cloud=true" >> $GITHUB_OUTPUT
                echo "needs_desktop=false" >> $GITHUB_OUTPUT
                echo "needs_mobile=false" >> $GITHUB_OUTPUT
                ;;
              "desktop")
                echo "needs_cloud=false" >> $GITHUB_OUTPUT
                echo "needs_desktop=true" >> $GITHUB_OUTPUT
                echo "needs_mobile=false" >> $GITHUB_OUTPUT
                ;;
              "mobile")
                echo "needs_cloud=false" >> $GITHUB_OUTPUT
                echo "needs_desktop=false" >> $GITHUB_OUTPUT
                echo "needs_mobile=true" >> $GITHUB_OUTPUT
                ;;
              "all")
                echo "needs_cloud=true" >> $GITHUB_OUTPUT
                echo "needs_desktop=true" >> $GITHUB_OUTPUT
                echo "needs_mobile=true" >> $GITHUB_OUTPUT
                ;;
            esac
            SHOULD_DEPLOY="true"
          fi
          
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Deployment Decision Summary"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Should Deploy: $SHOULD_DEPLOY"
          echo "Cloud: ${NEEDS_CLOUD}"
          echo "Desktop: ${NEEDS_DESKTOP}"
          echo "Mobile: ${NEEDS_MOBILE}"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Update Version Files
        if: steps.decision.outputs.should_deploy == 'true'
        env:
          NEW_VERSION: "${{ steps.analyze.outputs.new_version }}"
          COMMIT_SHA: "${{ github.sha }}"
        run: |
          chmod +x scripts/update-all-versions.sh
          ./scripts/update-all-versions.sh "$NEW_VERSION" "$COMMIT_SHA"

      - name: Commit Version Changes
        if: steps.decision.outputs.should_deploy == 'true'
        env:
          NEW_VERSION: "${{ steps.analyze.outputs.new_version }}"
        run: |
          # Commit version changes to main
          git add -A
          if ! git diff --cached --quiet; then
            git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
            git push origin main
            
            # Create version tag
            git tag "v$NEW_VERSION" -f
            git push origin "v$NEW_VERSION" -f
            echo "âœ… Version $NEW_VERSION committed and tagged"
          else
            echo "â„¹ï¸  No version changes to commit"
          fi

  # Detect changes in specific paths (compare against last cloud tag)
  changes:
    needs: ai_analysis
    if: ${{ needs.ai_analysis.outputs.should_deploy == 'true' && needs.ai_analysis.outputs.needs_cloud == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      base: ${{ steps.detect.outputs.base }}
      postgres: ${{ steps.detect.outputs.postgres }}
      web: ${{ steps.detect.outputs.web }}
      api: ${{ steps.detect.outputs.api }}
      proxy: ${{ steps.detect.outputs.proxy }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect Service Changes
        id: detect
        run: |
          # Find the previous cloud tag
          PREV_TAG=$(git tag -l "*-cloud-*" --sort=-version:refname | head -2 | tail -1 || echo "")

          if [ -z "$PREV_TAG" ]; then
            echo "No previous tag found, building all services"
            echo "base=true" >> $GITHUB_OUTPUT
            echo "postgres=true" >> $GITHUB_OUTPUT
            echo "web=true" >> $GITHUB_OUTPUT
            echo "api=true" >> $GITHUB_OUTPUT
            echo "proxy=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Comparing against previous tag: $PREV_TAG"

          # Check for changes in each service (suppress grep output, only capture true/false)
          BASE_CHANGED=$(git diff --name-only $PREV_TAG HEAD | grep -qE '^config/docker/Dockerfile\.base' && echo "true" || echo "false")
          POSTGRES_CHANGED=$(git diff --name-only $PREV_TAG HEAD | grep -qE '^config/docker/(Dockerfile\.postgres|postgres-)' && echo "true" || echo "false")
          WEB_CHANGED=$(git diff --name-only $PREV_TAG HEAD | grep -qE '^(web|lib|pubspec\.)' && echo "true" || echo "false")
          API_CHANGED=$(git diff --name-only $PREV_TAG HEAD | grep -qE '^services/api-backend' && echo "true" || echo "false")
          PROXY_CHANGED=$(git diff --name-only $PREV_TAG HEAD | grep -qE '^services/streaming-proxy' && echo "true" || echo "false")

          echo "base=$BASE_CHANGED" >> $GITHUB_OUTPUT
          echo "postgres=$POSTGRES_CHANGED" >> $GITHUB_OUTPUT
          echo "web=$WEB_CHANGED" >> $GITHUB_OUTPUT
          echo "api=$API_CHANGED" >> $GITHUB_OUTPUT
          echo "proxy=$PROXY_CHANGED" >> $GITHUB_OUTPUT

          echo "Change detection:"
          echo "  Base: $BASE_CHANGED"
          echo "  Postgres: $POSTGRES_CHANGED"
          echo "  Web: $WEB_CHANGED"
          echo "  API: $API_CHANGED"
          echo "  Proxy: $PROXY_CHANGED"

  # Setup ACR and retrieve login server
  setup_acr:
    needs: ai_analysis
    if: ${{ needs.ai_analysis.outputs.should_deploy == 'true' && needs.ai_analysis.outputs.needs_cloud == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      login_server: ${{ steps.acr_setup.outputs.login_server }}
    steps:
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Create Azure Resource Group if not exists
        run: az group create --name ${{ env.AZURE_RESOURCE_GROUP }} --location eastus --query "properties.provisioningState" --output tsv
      - name: Setup ACR
        id: acr_setup
        run: |
          # Create ACR if not exists
          az acr create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.ACR_NAME }} --sku Basic --admin-enabled true --query "provisioningState" --output tsv
          # Get Login Server and set as output
          LOGIN_SERVER=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)
          echo "login_server=$LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "DOCKER_REGISTRY=$LOGIN_SERVER" >> $GITHUB_ENV
      - name: Docker Login to ACR
        run: |
          # Get ACR admin credentials
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          # Login to ACR
          echo "$ACR_PASSWORD" | docker login "${{ steps.acr_setup.outputs.login_server }}" --username "$ACR_USERNAME" --password-stdin

  build_base:
    needs: [ai_analysis, changes, setup_acr]
    if: ${{ !cancelled() && needs.changes.outputs.base == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login to ACR
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          echo "$ACR_PASSWORD" | docker login "${{ needs.setup_acr.outputs.login_server }}" --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: config/docker/Dockerfile.base
          push: true
          tags: |
            ${{ needs.setup_acr.outputs.login_server }}/base:${{ needs.ai_analysis.outputs.new_version }}-base
            ${{ needs.setup_acr.outputs.login_server }}/base:latest
          cache-from: type=registry,ref=${{ needs.setup_acr.outputs.login_server }}/base:latest
          cache-to: type=inline

  build_postgres:
    needs: [ai_analysis, changes, setup_acr, build_base]
    if: ${{ !cancelled() && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped' || needs.changes.outputs.base != 'true') && needs.changes.outputs.postgres == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login to ACR
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          echo "$ACR_PASSWORD" | docker login "${{ needs.setup_acr.outputs.login_server }}" --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: config/docker/Dockerfile.postgres
          push: true
          tags: |
            ${{ needs.setup_acr.outputs.login_server }}/postgres:${{ needs.ai_analysis.outputs.new_version }}-postgres
            ${{ needs.setup_acr.outputs.login_server }}/postgres:latest
          build-args: |
            BASE_REGISTRY=${{ needs.setup_acr.outputs.login_server }}
          cache-from: type=registry,ref=${{ needs.setup_acr.outputs.login_server }}/postgres:latest
          cache-to: type=inline

  build_web:
    needs: [ai_analysis, changes, setup_acr, build_base]
    if: ${{ !cancelled() && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped' || needs.changes.outputs.base != 'true') && needs.changes.outputs.web == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login to ACR
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          echo "$ACR_PASSWORD" | docker login "${{ needs.setup_acr.outputs.login_server }}" --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - name: Check if Flutter is already installed
        id: flutter_check
        run: |
          if command -v flutter >/dev/null 2>&1; then
            FLUTTER_VERSION=$(flutter --version | head -n1 || echo "unknown")
            echo "Flutter is already installed: $FLUTTER_VERSION"
            echo "flutter_installed=true" >> $GITHUB_OUTPUT
          else
            echo "Flutter not found, will install"
            echo "flutter_installed=false" >> $GITHUB_OUTPUT
          fi
      - name: Install Flutter (if needed)
        if: steps.flutter_check.outputs.flutter_installed != 'true'
        uses: subosito/flutter-action@v2
        with:
          channel: "stable"
          cache: true
      - name: Build Flutter Web
        run: |
          flutter pub get
          flutter build web --release --no-tree-shake-icons --base-href / --dart-define=FLUTTER_BUILD_NUMBER=${{ github.sha }}
      - name: Apply Cache Busting to index.html
        run: |
          sed -i "s|\$FLUTTER_BUILD_NUMBER|${{ github.sha }}|g" build/web/index.html
          sed -i "s|\$FLUTTER_BASE_HREF|/|g" build/web/index.html
      - name: Debug - Verify index.html cache busting
        run: |
          echo "Checking if cache-busting was applied:"
          grep "flutter_bootstrap.js" build/web/index.html
      - name: Debug - List web build
        run: ls -R build/web || echo "build/web not found"
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: web/Dockerfile
          push: true
          tags: |
            ${{ needs.setup_acr.outputs.login_server }}/web:${{ needs.ai_analysis.outputs.new_version }}
            ${{ needs.setup_acr.outputs.login_server }}/web:latest
          build-args: |
            BASE_REGISTRY=${{ needs.setup_acr.outputs.login_server }}
          cache-from: type=registry,ref=${{ needs.setup_acr.outputs.login_server }}/web:latest
          cache-to: type=inline

  build_api:
    needs: [ai_analysis, changes, setup_acr, build_base]
    if: ${{ !cancelled() && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped' || needs.changes.outputs.base != 'true') && needs.changes.outputs.api == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login to ACR
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          echo "$ACR_PASSWORD" | docker login "${{ needs.setup_acr.outputs.login_server }}" --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: services/api-backend
          file: services/api-backend/Dockerfile
          push: true
          tags: |
            ${{ needs.setup_acr.outputs.login_server }}/api-backend:${{ needs.ai_analysis.outputs.new_version }}-api
            ${{ needs.setup_acr.outputs.login_server }}/api-backend:latest
          build-args: |
            BASE_REGISTRY=${{ needs.setup_acr.outputs.login_server }}
          cache-from: type=registry,ref=${{ needs.setup_acr.outputs.login_server }}/api-backend:latest
          cache-to: type=inline

  build_proxy:
    needs: [ai_analysis, changes, setup_acr, build_base]
    if: ${{ !cancelled() && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped' || needs.changes.outputs.base != 'true') && needs.changes.outputs.proxy == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Docker Login to ACR
        run: |
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          echo "$ACR_PASSWORD" | docker login "${{ needs.setup_acr.outputs.login_server }}" --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: services/streaming-proxy
          file: services/streaming-proxy/Dockerfile
          push: true
          tags: |
            ${{ needs.setup_acr.outputs.login_server }}/streaming-proxy:${{ needs.ai_analysis.outputs.new_version }}-proxy
            ${{ needs.setup_acr.outputs.login_server }}/streaming-proxy:latest
          build-args: |
            BASE_REGISTRY=${{ needs.setup_acr.outputs.login_server }}
          cache-from: type=registry,ref=${{ needs.setup_acr.outputs.login_server }}/streaming-proxy:latest
          cache-to: type=inline

  # Cloud Deployment (conditional) - Azure AKS
  deploy_infrastructure:
    permissions:
      id-token: write
    needs: [ai_analysis, changes, setup_acr, build_base, build_postgres, build_web, build_api, build_proxy]
    if: |
      !cancelled() &&
      (needs.build_base.result == 'success' || needs.build_base.result == 'skipped' || needs.changes.outputs.base != 'true') &&
      (needs.build_postgres.result == 'success' || needs.build_postgres.result == 'skipped' || needs.changes.outputs.postgres != 'true') &&
      (needs.build_web.result == 'success' || needs.build_web.result == 'skipped' || needs.changes.outputs.web != 'true') &&
      (needs.build_api.result == 'success' || needs.build_api.result == 'skipped' || needs.changes.outputs.api != 'true') &&
      (needs.build_proxy.result == 'success' || needs.build_proxy.result == 'skipped' || needs.changes.outputs.proxy != 'true')
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.AZURE_RESOURCE_GROUP }}
          cluster-name: ${{ env.AZURE_CLUSTER_NAME }}

      - name: Ensure Namespace Exists
        run: |
          kubectl create namespace cloudtolocalllm --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          STRIPE_TEST_SECRET_KEY: ${{ secrets.STRIPE_TEST_SECRET_KEY }}
          STRIPE_TEST_PUBLISHABLE_KEY: ${{ secrets.STRIPE_TEST_PUBLISHABLE_KEY }}
          STRIPE_TEST_WEBHOOK_SECRET: ${{ secrets.STRIPE_TEST_WEBHOOK_SECRET }}
          STRIPE_LIVE_SECRET_KEY: ${{ secrets.STRIPE_LIVE_SECRET_KEY }}
          STRIPE_LIVE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_LIVE_PUBLISHABLE_KEY }}
          STRIPE_LIVE_WEBHOOK_SECRET: ${{ secrets.STRIPE_LIVE_WEBHOOK_SECRET }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
          CLOUDFLARE_DNS_TOKEN: ${{ secrets.CLOUDFLARE_DNS_TOKEN }}
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          SUPABASE_JWT_SECRET: ${{ secrets.SUPABASE_JWT_SECRET }}
          AUTH0_DOMAIN: ${{ secrets.AUTH0_DOMAIN }}
          AUTH0_AUDIENCE: ${{ secrets.AUTH0_AUDIENCE }}
          AUTH0_CLIENT_ID: ${{ secrets.AUTH0_CLIENT_ID }}
          AUTH0_CLIENT_SECRET: ${{ secrets.AUTH0_CLIENT_SECRET }}
          AUTH0_ISSUER_URL: ${{ secrets.AUTH0_ISSUER_URL }}
        run: |
          # Get ACR Admin Credentials
          ACR_ADMIN_USER=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_ADMIN_PASS=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)

          # Docker Registry Secret for ACR
          kubectl create secret docker-registry regcred \
            --docker-server=${{ needs.setup_acr.outputs.login_server }} \
            --docker-username=$ACR_ADMIN_USER \
            --docker-password=$ACR_ADMIN_PASS \
            --docker-email=github-actions@cloudtolocalllm.online \
            -n cloudtolocalllm --dry-run=client -o yaml | kubectl apply -f -

          # App Secrets
          kubectl create secret generic cloudtolocalllm-secrets \
            --namespace cloudtolocalllm \
            --from-literal=postgres-user=cloud_admin \
            --from-literal=postgres-password="$POSTGRES_PASSWORD" \
            --from-literal=jwt-secret="$JWT_SECRET" \
            --from-literal=stripe-test-secret-key="$STRIPE_TEST_SECRET_KEY" \
            --from-literal=stripe-test-publishable-key="$STRIPE_TEST_PUBLISHABLE_KEY" \
            --from-literal=stripe-test-webhook-secret="$STRIPE_TEST_WEBHOOK_SECRET" \
            --from-literal=stripe-live-secret-key="$STRIPE_LIVE_SECRET_KEY" \
            --from-literal=stripe-live-publishable-key="$STRIPE_LIVE_PUBLISHABLE_KEY" \
            --from-literal=stripe-live-webhook-secret="$STRIPE_LIVE_WEBHOOK_SECRET" \
            --from-literal=sentry-dsn="$SENTRY_DSN" \
            --from-literal=supabase-jwt-secret="$SUPABASE_JWT_SECRET" \
            --from-literal=supabase-url="https://cvaqhvpbnemweqrojasm.supabase.co" \
            --from-literal=auth0-domain="$AUTH0_DOMAIN" \
            --from-literal=auth0-audience="$AUTH0_AUDIENCE" \
            --from-literal=auth0-client-id="$AUTH0_CLIENT_ID" \
            --from-literal=auth0-client-secret="$AUTH0_CLIENT_SECRET" \
            --from-literal=auth0-issuer-url="$AUTH0_ISSUER_URL" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Cloudflare Tunnel Secret
          kubectl create secret generic tunnel-credentials \
            --namespace cloudtolocalllm \
            --from-literal=token="$CLOUDFLARE_TUNNEL_TOKEN" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Streaming Proxy Secret
          kubectl create secret generic streaming-proxy-secrets \
            --namespace cloudtolocalllm \
            --from-literal=SENTRY_DSN="$SENTRY_DSN" \
            --from-literal=SUPABASE_JWT_SECRET="$SUPABASE_JWT_SECRET" \
            --from-literal=SUPABASE_URL="https://cvaqhvpbnemweqrojasm.supabase.co" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Manifests
        env:
          POSTGRES_BUILT: ${{ needs.changes.outputs.postgres }}
          WEB_BUILT: ${{ needs.changes.outputs.web }}
          API_BUILT: ${{ needs.changes.outputs.api }}
          PROXY_BUILT: ${{ needs.changes.outputs.proxy }}
          APP_VERSION: ${{ needs.ai_analysis.outputs.new_version }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          set -e

          # Use semantic version if service was built, otherwise use latest
          [ "$POSTGRES_BUILT" = "true" ] && POSTGRES_TAG="${APP_VERSION}-postgres" || POSTGRES_TAG="latest"
          [ "$WEB_BUILT" = "true" ] && WEB_TAG="${APP_VERSION}" || WEB_TAG="latest"
          [ "$API_BUILT" = "true" ] && API_TAG="${APP_VERSION}-api" || API_TAG="latest"
          [ "$PROXY_BUILT" = "true" ] && PROXY_TAG="${APP_VERSION}-proxy" || PROXY_TAG="latest"

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Deployment Version: $APP_VERSION"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "  Postgres: $POSTGRES_TAG"
          echo "  Web:      $WEB_TAG"
          echo "  API:      $API_TAG"
          echo "  Proxy:    $PROXY_TAG"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""

          # Replace image registry in manifests
          sed -i "s|cloudtolocalllm/postgres:latest|${{ needs.setup_acr.outputs.login_server }}/postgres:${POSTGRES_TAG}|g" k8s/postgres-statefulset.yaml
          sed -i "s|cloudtolocalllm/web:latest|${{ needs.setup_acr.outputs.login_server }}/web:${WEB_TAG}|g" k8s/web-deployment.yaml
          sed -i "s|cloudtolocalllm/api-backend:latest|${{ needs.setup_acr.outputs.login_server }}/api-backend:${API_TAG}|g" k8s/api-backend-deployment.yaml
          sed -i "s|cloudtolocalllm/streaming-proxy:latest|${{ needs.setup_acr.outputs.login_server }}/streaming-proxy:${PROXY_TAG}|g" k8s/streaming-proxy-deployment.yaml

          # Validate manifests with server-side dry-run before applying
          echo "Validating Kubernetes manifests with server-side dry-run..."
          kubectl apply --dry-run=server -f k8s/rbac.yaml
          kubectl apply --dry-run=server -f k8s/configmap.yaml
          kubectl apply --dry-run=server -f k8s/streaming-proxy-configmap.yaml
          kubectl apply --dry-run=server -f k8s/postgres-statefulset.yaml
          kubectl apply --dry-run=server -f k8s/cloudflared.yaml
          kubectl apply --dry-run=server -f k8s/web-deployment.yaml
          kubectl apply --dry-run=server -f k8s/api-backend-deployment.yaml
          kubectl apply --dry-run=server -f k8s/streaming-proxy-deployment.yaml

          # Apply RBAC and ConfigMaps first
          kubectl apply -f k8s/rbac.yaml
          kubectl apply -f k8s/configmap.yaml
          kubectl apply -f k8s/streaming-proxy-configmap.yaml
          
          # ===== STEP 1: Deploy and wait for PostgreSQL (all services depend on it) =====
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "STEP 1: Deploying PostgreSQL (all services depend on this)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          kubectl apply -f k8s/postgres-statefulset.yaml
          
          # Add annotation to force update
          kubectl annotate statefulset postgres -n cloudtolocalllm \
            deployment.kubernetes.io/revision="${{ github.sha }}" \
            deployment.kubernetes.io/timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --overwrite
          
          # Force delete postgres pod to ensure it picks up new spec (if it exists)
          kubectl delete pod postgres-0 -n cloudtolocalllm --force --grace-period=0 2>/dev/null || true
          kubectl rollout restart statefulset/postgres -n cloudtolocalllm
          
          # Wait for postgres to be ready before proceeding
          echo "Waiting for PostgreSQL to be ready..."
          chmod +x scripts/watch_rollout.sh
          ./scripts/watch_rollout.sh cloudtolocalllm statefulset postgres
          
          echo "âœ… PostgreSQL is ready"
          echo ""
          
          # ===== STEP 2: Deploy API Backend (depends on postgres) =====
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "STEP 2: Deploying API Backend (depends on postgres)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          kubectl apply -f k8s/api-backend-deployment.yaml
          
          # Add annotation to force update
          kubectl annotate deployment api-backend -n cloudtolocalllm \
            deployment.kubernetes.io/revision="${{ github.sha }}" \
            deployment.kubernetes.io/timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --overwrite
          
          # Trigger rolling update
          kubectl rollout restart deployment/api-backend -n cloudtolocalllm
          
          echo "Waiting for API Backend to be ready..."
          ./scripts/watch_rollout.sh cloudtolocalllm deployment api-backend
          echo "âœ… API Backend is ready"
          echo ""
          
          # ===== STEP 3: Deploy Streaming Proxy (depends on api-backend) =====
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "STEP 3: Deploying Streaming Proxy (depends on api-backend)"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          kubectl apply -f k8s/streaming-proxy-deployment.yaml
          
          # Add annotation to force update
          kubectl annotate deployment streaming-proxy -n cloudtolocalllm \
            deployment.kubernetes.io/revision="${{ github.sha }}" \
            deployment.kubernetes.io/timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --overwrite
          
          # Trigger rolling update
          kubectl rollout restart deployment/streaming-proxy -n cloudtolocalllm
          
          echo "Waiting for Streaming Proxy to be ready..."
          ./scripts/watch_rollout.sh cloudtolocalllm deployment streaming-proxy
          echo "âœ… Streaming Proxy is ready"
          echo ""
          
          # ===== STEP 4: Deploy Web and Cloudflared (depend on api-backend and streaming) =====
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "STEP 4: Deploying Web Frontend and Cloudflared"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          kubectl apply -f k8s/web-deployment.yaml
          kubectl apply -f k8s/cloudflared.yaml
          
          # Add annotations to force updates
          kubectl annotate deployment web -n cloudtolocalllm \
            deployment.kubernetes.io/revision="${{ github.sha }}" \
            deployment.kubernetes.io/timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --overwrite
          
          kubectl annotate deployment cloudflared -n cloudtolocalllm \
            deployment.kubernetes.io/revision="${{ github.sha }}" \
            deployment.kubernetes.io/timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --overwrite
          
          # Trigger rolling updates
          kubectl rollout restart deployment/web -n cloudtolocalllm
          kubectl rollout restart deployment/cloudflared -n cloudtolocalllm
          
          echo "Waiting for Web to be ready..."
          ./scripts/watch_rollout.sh cloudtolocalllm deployment web
          echo "âœ… Web is ready"
          echo ""
          
          echo "âœ… All services deployed successfully in dependency order:"
          echo "   1. PostgreSQL"
          echo "   2. API Backend"
          echo "   3. Streaming Proxy"
          echo "   4. Web + Cloudflared"

      - name: Verify Deployment
        run: |
          echo "Waiting for health check..."
          for i in {1..24}; do
            http_status=$(curl -s -o /dev/null -w "%{http_code}" https://app.cloudtolocalllm.online/health || echo "000")
            if [ "$http_status" = "200" ]; then
              echo "âœ… Health check passed with HTTP 200"
              exit 0
            fi
            echo "Attempt $i/24: Health check returned HTTP $http_status, waiting 5s..."
            sleep 5
          done
          echo "âŒ Health check failed after 2 minutes"
          exit 1

      - name: Purge Cloudflare Cache
        continue-on-error: true
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          chmod +x scripts/cloudflare-cache-purge.sh
          ./scripts/cloudflare-cache-purge.sh

  # Desktop Build (conditional) - TEMPORARILY DISABLED DUE TO FLUTTER WINDOWS BUILD ISSUES
  build_desktop:
    needs: ai_analysis
    if: false  # Disabled until Flutter Windows build issues are resolved
    runs-on: windows-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - uses: subosito/flutter-action@v2
        with:
          channel: "stable"
          cache: true

      - name: Build Windows Desktop
        timeout-minutes: 20
        run: |
          flutter pub get
          echo "Configuring Windows build environment..."
          flutter config --enable-windows-desktop
          echo "Starting Windows build with optimizations..."
          flutter build windows --release --no-tree-shake-icons --dart-define=FLUTTER_WEB_USE_SKIA=false

      - name: Create Windows Installer
        run: |
          # Simple build without the complex deployment script
          if (-not (Test-Path "dist")) { New-Item -ItemType Directory -Path "dist" }
          
          # Copy built Windows app to dist
          if (Test-Path "build/windows/x64/runner/Release") {
            Copy-Item -Path "build/windows/x64/runner/Release" -Destination "dist/windows-release" -Recurse -Force
            
            # Create a simple zip package
            $version = (Get-Content "pubspec.yaml" | Select-String "version:" | ForEach-Object { $_.ToString().Split(":")[1].Trim().Split("+")[0] })
            Compress-Archive -Path "dist/windows-release/*" -DestinationPath "dist/cloudtolocalllm-$version-portable.zip" -Force
            
            # Generate SHA256 checksum
            $hash = Get-FileHash "dist/cloudtolocalllm-$version-portable.zip" -Algorithm SHA256
            "$($hash.Hash.ToLower())  cloudtolocalllm-$version-portable.zip" | Out-File "dist/cloudtolocalllm-$version-portable.zip.sha256" -Encoding ASCII
            
            Write-Host "âœ“ Created portable package: cloudtolocalllm-$version-portable.zip"
          } else {
            Write-Host "ERROR: Windows build output not found" -ForegroundColor Red
            exit 1
          }

      - name: Upload Desktop Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-desktop-${{ needs.ai_analysis.outputs.new_version }}
          path: |
            dist/*.zip
            dist/*.sha256

  # Mobile Build (conditional - placeholder for future)
  build_mobile:
    needs: ai_analysis
    if: ${{ needs.ai_analysis.outputs.should_deploy == 'true' && needs.ai_analysis.outputs.needs_mobile == 'true' }}
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Mobile Build Placeholder
        run: |
          echo "ðŸš§ Mobile build not yet implemented"
          echo "This job will be expanded when mobile deployment is needed"

  # Deployment Summary
  deployment_summary:
    needs: [ai_analysis, deploy_infrastructure, build_desktop, build_mobile]
    if: always() && needs.ai_analysis.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Generate Deployment Summary
        env:
          NEW_VERSION: ${{ needs.ai_analysis.outputs.new_version }}
          NEEDS_CLOUD: ${{ needs.ai_analysis.outputs.needs_cloud }}
          NEEDS_DESKTOP: ${{ needs.ai_analysis.outputs.needs_desktop }}
          NEEDS_MOBILE: ${{ needs.ai_analysis.outputs.needs_mobile }}
          REASONING: ${{ needs.ai_analysis.outputs.reasoning }}
          CLOUD_STATUS: ${{ needs.deploy_infrastructure.result }}
          DESKTOP_STATUS: ${{ needs.build_desktop.result }}
          MOBILE_STATUS: ${{ needs.build_mobile.result }}
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >> $GITHUB_STEP_SUMMARY
          echo "# Unified Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** $NEW_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**AI Reasoning:** $REASONING" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Platform Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$NEEDS_CLOUD" = "true" ]; then
            if [ "$CLOUD_STATUS" = "success" ]; then
              echo "â˜ï¸ **Cloud (Azure AKS):** âœ… Deployed successfully" >> $GITHUB_STEP_SUMMARY
              echo "   - Web: https://app.cloudtolocalllm.online" >> $GITHUB_STEP_SUMMARY
              echo "   - API: https://api.cloudtolocalllm.online" >> $GITHUB_STEP_SUMMARY
            else
              echo "â˜ï¸ **Cloud (Azure AKS):** âŒ Deployment failed" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "â˜ï¸ **Cloud (Azure AKS):** â­ï¸ Skipped (no changes detected)" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "$NEEDS_DESKTOP" = "true" ]; then
            if [ "$DESKTOP_STATUS" = "success" ]; then
              echo "ðŸ–¥ï¸ **Desktop:** âœ… Built successfully" >> $GITHUB_STEP_SUMMARY
            else
              echo "ðŸ–¥ï¸ **Desktop:** âŒ Build failed" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "ðŸ–¥ï¸ **Desktop:** â­ï¸ Skipped (no changes detected)" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "$NEEDS_MOBILE" = "true" ]; then
            echo "ðŸ“± **Mobile:** ðŸš§ Not yet implemented" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ“± **Mobile:** â­ï¸ Skipped (no changes detected)" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >> $GITHUB_STEP_SUMMARY