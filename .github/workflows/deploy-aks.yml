name: Deploy to Azure AKS

permissions:
  id-token: write

on:
  push:
    branches:
      - main
    paths:
      - "k8s/**"
      - ".github/workflows/deploy-aks.yml"
      - "services/**"
      - "web/**"
      - "lib/**"
      - "pubspec.**"
      - "config/docker/**"
      - "scripts/**"
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AZURE_RESOURCE_GROUP: cloudtolocalllm-rg
  AZURE_CLUSTER_NAME: cloudtolocalllm-aks
  ACR_NAME: imrightguycloudtolocalllm
  # DOCKER_REGISTRY will be set dynamically to the ACR login server
  DOCKER_REGISTRY: ""

jobs:
  # Job to detect changes in specific paths
  changes:
    runs-on: ubuntu-latest
    outputs:
      base: ${{ steps.filter.outputs.base }}
      postgres: ${{ steps.filter.outputs.postgres }}
      web: ${{ steps.filter.outputs.web }}
      api: ${{ steps.filter.outputs.api }}
      proxy: ${{ steps.filter.outputs.proxy }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            base:
              - 'config/docker/Dockerfile.base'
              - '.github/workflows/deploy-aks.yml'
            postgres:
              - 'config/docker/Dockerfile.postgres'
              - 'config/docker/postgres-init.sh'
              - 'config/docker/postgres-entrypoint.sh'
              - '.github/workflows/deploy-aks.yml'
            web:
              - 'web/**'
              - 'lib/**'
              - 'pubspec.**'
              - 'config/docker/Dockerfile.base'
              - '.github/workflows/deploy-aks.yml'
            api:
              - 'services/api-backend/**'
              - 'config/docker/Dockerfile.base'
              - '.github/workflows/deploy-aks.yml'
            proxy:
              - 'services/streaming-proxy/**'
              - 'config/docker/Dockerfile.base'
              - '.github/workflows/deploy-aks.yml'

  build_base:
    needs: changes
    if: ${{ !cancelled() && needs.changes.outputs.base == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Create Azure Resource Group if not exists
        run: az group create --name ${{ env.AZURE_RESOURCE_GROUP }} --location eastus --query "properties.provisioningState" --output tsv
      - name: Setup ACR
        run: |
          # Create ACR if not exists
          az acr create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.ACR_NAME }} --sku Basic --admin-enabled true
          # Get Login Server
          echo "DOCKER_REGISTRY=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_ENV
      - name: Docker Login to ACR
        run: |
          # Get ACR admin credentials
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          # Login to ACR
          echo "$ACR_PASSWORD" | docker login ${{ env.DOCKER_REGISTRY }} --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: config/docker/Dockerfile.base
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/base:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/base:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/base:latest
          cache-to: type=inline

  build_postgres:
    needs: [changes, build_base]
    if: ${{ !cancelled() && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') && needs.changes.outputs.postgres == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Create Azure Resource Group if not exists
        run: az group create --name ${{ env.AZURE_RESOURCE_GROUP }} --location eastus --query "properties.provisioningState" --output tsv
      - name: Get ACR Login Server
        run: echo "DOCKER_REGISTRY=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_ENV
      - name: Docker Login to ACR
        run: |
          # Get ACR admin credentials
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          # Login to ACR
          echo "$ACR_PASSWORD" | docker login ${{ env.DOCKER_REGISTRY }} --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: config/docker/Dockerfile.postgres
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/postgres:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/postgres:latest
          build-args: |
            BASE_REGISTRY=${{ env.DOCKER_REGISTRY }}
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/postgres:latest
          cache-to: type=inline

  build_web:
    needs: [changes, build_base]
    if: ${{ !cancelled() && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') && needs.changes.outputs.web == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Create Azure Resource Group if not exists
        run: az group create --name ${{ env.AZURE_RESOURCE_GROUP }} --location eastus --query "properties.provisioningState" --output tsv
      - name: Get ACR Login Server
        run: echo "DOCKER_REGISTRY=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_ENV
      - name: Docker Login to ACR
        run: |
          # Get ACR admin credentials
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          # Login to ACR
          echo "$ACR_PASSWORD" | docker login ${{ env.DOCKER_REGISTRY }} --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: subosito/flutter-action@v2
        with:
          channel: "stable"
          cache: true
      - run: flutter pub get && flutter build web --release --no-tree-shake-icons
      - name: Debug - List web build
        run: ls -R build/web || echo "build/web not found"
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: web/Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/web:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/web:latest
          build-args: |
            BASE_REGISTRY=${{ env.DOCKER_REGISTRY }}
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/web:latest
          cache-to: type=inline
  
  build_api:
    needs: [changes, build_base]
    if: ${{ !cancelled() && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') && needs.changes.outputs.api == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Create Azure Resource Group if not exists
        run: az group create --name ${{ env.AZURE_RESOURCE_GROUP }} --location eastus --query "properties.provisioningState" --output tsv
      - name: Get ACR Login Server
        run: echo "DOCKER_REGISTRY=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_ENV
      - name: Docker Login to ACR
        run: |
          # Get ACR admin credentials
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          # Login to ACR
          echo "$ACR_PASSWORD" | docker login ${{ env.DOCKER_REGISTRY }} --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: services/api-backend
          file: services/api-backend/Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/api-backend:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/api-backend:latest
          build-args: |
            BASE_REGISTRY=${{ env.DOCKER_REGISTRY }}
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/api-backend:latest
          cache-to: type=inline

  build_proxy:
    needs: [changes, build_base]
    if: ${{ !cancelled() && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') && needs.changes.outputs.proxy == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Create Azure Resource Group if not exists
        run: az group create --name ${{ env.AZURE_RESOURCE_GROUP }} --location eastus --query "properties.provisioningState" --output tsv
      - name: Get ACR Login Server
        run: echo "DOCKER_REGISTRY=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_ENV
      - name: Docker Login to ACR
        run: |
          # Get ACR admin credentials
          ACR_USERNAME=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_PASSWORD=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)
          # Login to ACR
          echo "$ACR_PASSWORD" | docker login ${{ env.DOCKER_REGISTRY }} --username "$ACR_USERNAME" --password-stdin
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: services/streaming-proxy
          file: services/streaming-proxy/Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/streaming-proxy:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/streaming-proxy:latest
          build-args: |
            BASE_REGISTRY=${{ env.DOCKER_REGISTRY }}
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/streaming-proxy:latest
          cache-to: type=inline

  deploy_infrastructure:
    permissions:
      id-token: write
    # Run after image builds (or if they were skipped due to unchanged paths)
    needs:
      [changes, build_base, build_postgres, build_web, build_api, build_proxy]
    if: |
      !cancelled() &&
      (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') &&
      (needs.build_postgres.result == 'success' || needs.build_postgres.result == 'skipped') &&
      (needs.build_web.result == 'success' || needs.build_web.result == 'skipped') &&
      (needs.build_api.result == 'success' || needs.build_api.result == 'skipped') &&
      (needs.build_proxy.result == 'success' || needs.build_proxy.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      - name: Bootstrap Azure RG/ACR/Key Vault
        run: |
          chmod +x scripts/bootstrap-azure-infra.sh
          scripts/bootstrap-azure-infra.sh "${{ env.AZURE_RESOURCE_GROUP }}" "eastus" "${{ env.ACR_NAME }}" "${{ secrets.AZURE_KEY_VAULT_NAME }}"
      - name: Create AKS Cluster if not exists
        run: |
          if ! az aks show --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_CLUSTER_NAME }} --query "name" --output tsv; then
            echo "AKS cluster ${{ env.AZURE_CLUSTER_NAME }} not found. Creating..."
            az aks create \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --name ${{ env.AZURE_CLUSTER_NAME }} \
              --node-count 1 \
              --enable-addons monitoring \
              --enable-managed-identity \
              --enable-oidc-issuer \
              --enable-workload-identity \
              --network-plugin azure \
              --dns-service-ip 10.2.0.10 \
              --service-cidr 10.2.0.0/24 \
              --location eastus \
              --generate-ssh-keys \
              --attach-acr ${{ env.ACR_NAME }}
          else
            echo "AKS cluster ${{ env.AZURE_CLUSTER_NAME }} already exists."
          fi
      
      - name: Get AKS credentials
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.AZURE_RESOURCE_GROUP }}
          cluster-name: ${{ env.AZURE_CLUSTER_NAME }}

      - name: Validate Required CLI Tools
        run: |
          set -e

          echo "Validating required CLI tools (az, kubectl, jq)..."

          missing=0
          for cmd in az kubectl jq; do
            if ! command -v "$cmd" >/dev/null 2>&1; then
              echo "Error: required CLI tool '$cmd' is not installed or not in PATH"
              missing=1
            else
              echo "Found $cmd: $(command -v "$cmd")"
            fi
          done

          if [ "$missing" -ne 0 ]; then
            echo "One or more required CLI tools are missing. Failing before deployment."
            exit 1
          fi

      - name: Setup ACR Integration
        run: |
          # Get Login Server (ACR assumed to exist or created in build steps)
          echo "DOCKER_REGISTRY=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_ENV

      - name: Configure Key Vault RBAC for AKS
        continue-on-error: true
        run: |
          set -e
          KV_NAME="${{ secrets.AZURE_KEY_VAULT_NAME }}"
          if [ -z "$KV_NAME" ]; then
            echo "Key Vault name not set, skipping RBAC configuration"
            exit 0
          fi
          KV_ID=$(az keyvault show -g ${{ env.AZURE_RESOURCE_GROUP }} -n "$KV_NAME" --query id -o tsv 2>/dev/null || echo "")
          if [ -z "$KV_ID" ]; then
            echo "Key Vault not found, skipping RBAC configuration"
            exit 0
          fi
          AKS_MI_ID=$(az aks show -g ${{ env.AZURE_RESOURCE_GROUP }} -n ${{ env.AZURE_CLUSTER_NAME }} --query identityProfile.kubeletidentity.objectId -o tsv 2>/dev/null || echo "")
          if [ -z "$AKS_MI_ID" ]; then
            AKS_MI_ID=$(az aks show -g ${{ env.AZURE_RESOURCE_GROUP }} -n ${{ env.AZURE_CLUSTER_NAME }} --query identity.principalId -o tsv 2>/dev/null || echo "")
          fi
          if [ -z "$AKS_MI_ID" ]; then
            echo "AKS managed identity not found, skipping RBAC configuration"
            exit 0
          fi
          ROLE="Key Vault Secrets User"
          COUNT=$(az role assignment list --assignee "$AKS_MI_ID" --scope "$KV_ID" --query "[?roleDefinitionName=='$ROLE'] | length(@)" -o tsv)
          if [ "$COUNT" = "0" ] || [ -z "$COUNT" ]; then
            echo "Attempting to assign Key Vault RBAC role..."
            if az role assignment create --assignee "$AKS_MI_ID" --role "$ROLE" --scope "$KV_ID" 2>/dev/null; then
              echo "Successfully assigned Key Vault RBAC role"
            else
              echo "WARNING: Could not assign Key Vault RBAC role (insufficient permissions)"
              echo "You may need to manually grant 'Key Vault Secrets User' role to AKS managed identity"
              exit 0
            fi
          else
            echo "Key Vault RBAC role already assigned"
          fi

      - name: Ensure Namespace Exists
        run: |
          kubectl create namespace cloudtolocalllm --dry-run=client -o yaml | kubectl apply -f -
      - name: Setup Azure Key Vault and Secrets Store CSI Driver
        run: |
          # Install the Secrets Store CSI Driver and Azure Provider
          helm repo add secrets-store-csi-driver https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts
          helm repo add csi-secrets-store-provider-azure https://azure.github.io/secrets-store-csi-driver-provider-azure/charts
          helm upgrade --install csi-secrets-store secrets-store-csi-driver/secrets-store-csi-driver --namespace kube-system --set "providers.azure.enabled=true"

      - name: Create SecretProviderClass
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: secrets-store.csi.x-k8s.io/v1
          kind: SecretProviderClass
          metadata:
            name: azure-kvname-user-msi
            namespace: cloudtolocalllm
          spec:
            provider: azure
            parameters:
              usePodIdentity: "false"
              useVMManagedIdentity: "true"
              userAssignedIdentityID: "" # Set this to the client ID of the user-assigned managed identity if you use one.
              keyvaultName: ${{ secrets.AZURE_KEY_VAULT_NAME }}
              objects:  |
                array:
                  - |
                    objectName: POSTGRES-PASSWORD
                    objectType: secret
                  - |
                    objectName: JWT-SECRET
                    objectType: secret
                  - |
                    objectName: STRIPE-TEST-SECRET-KEY
                    objectType: secret
                  - |
                    objectName: CLOUDFLARE-TUNNEL-TOKEN
                    objectType: secret
              tenantId: ${{ secrets.AZURE_TENANT_ID }}
          EOF

      - name: Validate Required Secrets
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          STRIPE_TEST_SECRET_KEY: ${{ secrets.STRIPE_TEST_SECRET_KEY }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
          CLOUDFLARE_DNS_TOKEN: ${{ secrets.CLOUDFLARE_DNS_TOKEN }}
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
          SUPABASE_JWT_SECRET: ${{ secrets.SUPABASE_JWT_SECRET }}
        run: |
          missing=0
          check_secret() {
            name="$1"
            value="$2"
            if [ -z "$value" ]; then
              echo "Error: required secret $name is empty or not set"
              missing=1
            fi
          }

          check_secret POSTGRES_PASSWORD "$POSTGRES_PASSWORD"
          check_secret JWT_SECRET "$JWT_SECRET"
          check_secret STRIPE_TEST_SECRET_KEY "$STRIPE_TEST_SECRET_KEY"
          check_secret SENTRY_DSN "$SENTRY_DSN"
          check_secret CLOUDFLARE_DNS_TOKEN "$CLOUDFLARE_DNS_TOKEN"
          check_secret CLOUDFLARE_TUNNEL_TOKEN "$CLOUDFLARE_TUNNEL_TOKEN"
          check_secret SUPABASE_JWT_SECRET "$SUPABASE_JWT_SECRET"

          if [ "$missing" -ne 0 ]; then
            echo "One or more required secrets are missing. Failing before deployment."
            exit 1
          fi

      - name: Seed Azure Key Vault from secrets
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          STRIPE_TEST_SECRET_KEY: ${{ secrets.STRIPE_TEST_SECRET_KEY }}
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
          SUPABASE_JWT_SECRET: ${{ secrets.SUPABASE_JWT_SECRET }}
        run: |
          set -e
          KV_NAME="${{ secrets.AZURE_KEY_VAULT_NAME }}"
          if [ -z "$KV_NAME" ]; then
            exit 0
          fi
          ensure_kv_secret() {
            local name="$1"
            local value="$2"
            if [ -z "$value" ]; then
              return
            fi
            if az keyvault secret show --vault-name "$KV_NAME" --name "$name" >/dev/null 2>&1; then
              return
            fi
            az keyvault secret set --vault-name "$KV_NAME" --name "$name" --value "$value" >/dev/null
          }
          ensure_kv_secret POSTGRES-PASSWORD "$POSTGRES_PASSWORD"
          ensure_kv_secret JWT-SECRET "$JWT_SECRET"
          ensure_kv_secret STRIPE-TEST-SECRET-KEY "$STRIPE_TEST_SECRET_KEY"
          ensure_kv_secret CLOUDFLARE-TUNNEL-TOKEN "$CLOUDFLARE_TUNNEL_TOKEN"
          ensure_kv_secret SUPABASE-JWT-SECRET "$SUPABASE_JWT_SECRET"

      - name: Create/Update Secrets
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          STRIPE_TEST_SECRET_KEY: ${{ secrets.STRIPE_TEST_SECRET_KEY }}
          STRIPE_TEST_PUBLISHABLE_KEY: ${{ secrets.STRIPE_TEST_PUBLISHABLE_KEY }}
          STRIPE_TEST_WEBHOOK_SECRET: ${{ secrets.STRIPE_TEST_WEBHOOK_SECRET }}
          STRIPE_LIVE_SECRET_KEY: ${{ secrets.STRIPE_LIVE_SECRET_KEY }}
          STRIPE_LIVE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_LIVE_PUBLISHABLE_KEY }}
          STRIPE_LIVE_WEBHOOK_SECRET: ${{ secrets.STRIPE_LIVE_WEBHOOK_SECRET }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
          CLOUDFLARE_DNS_TOKEN: ${{ secrets.CLOUDFLARE_DNS_TOKEN }}
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          SUPABASE_JWT_SECRET: ${{ secrets.SUPABASE_JWT_SECRET }}
        run: |
          # --- Create Kubernetes Secrets ---

          # Get ACR Admin Credentials
          ACR_ADMIN_USER=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_ADMIN_PASS=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)

          # Docker Registry Secret for ACR
          kubectl create secret docker-registry regcred \
            --docker-server=${{ env.DOCKER_REGISTRY }} \
            --docker-username=$ACR_ADMIN_USER \
            --docker-password=$ACR_ADMIN_PASS \
            --docker-email=github-actions@cloudtolocalllm.online \
            -n cloudtolocalllm --dry-run=client -o yaml | kubectl apply -f -

          # App Secrets
          kubectl create secret generic cloudtolocalllm-secrets \
            --namespace cloudtolocalllm \
            --from-literal=postgres-user=cloud_admin \
            --from-literal=postgres-password="$POSTGRES_PASSWORD" \
            --from-literal=jwt-secret="$JWT_SECRET" \
            --from-literal=stripe-test-secret-key="$STRIPE_TEST_SECRET_KEY" \
            --from-literal=stripe-test-publishable-key="$STRIPE_TEST_PUBLISHABLE_KEY" \
            --from-literal=stripe-test-webhook-secret="$STRIPE_TEST_WEBHOOK_SECRET" \
            --from-literal=stripe-live-secret-key="$STRIPE_LIVE_SECRET_KEY" \
            --from-literal=stripe-live-publishable-key="$STRIPE_LIVE_PUBLISHABLE_KEY" \
            --from-literal=stripe-live-webhook-secret="$STRIPE_LIVE_WEBHOOK_SECRET" \
            --from-literal=sentry-dsn="$SENTRY_DSN" \
            --from-literal=supabase-jwt-secret="$SUPABASE_JWT_SECRET" \
            --from-literal=supabase-url="https://cvaqhvpbnemweqrojasm.supabase.co" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Cloudflare Tunnel Secret
          kubectl create secret generic tunnel-credentials \
            --namespace cloudtolocalllm \
            --from-literal=token="$CLOUDFLARE_TUNNEL_TOKEN" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Streaming Proxy Secret
          kubectl create secret generic streaming-proxy-secrets \
            --namespace cloudtolocalllm \
            --from-literal=SENTRY_DSN="$SENTRY_DSN" \
            --from-literal=SUPABASE_JWT_SECRET="$SUPABASE_JWT_SECRET" \
            --from-literal=SUPABASE_URL="https://cvaqhvpbnemweqrojasm.supabase.co" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Manifests
        run: |
          set -e  # Exit immediately on any error
          
          # Replace image registry in manifests
          sed -i "s|cloudtolocalllm/postgres:latest|${{ env.DOCKER_REGISTRY }}/postgres:${{ github.sha }}|g" k8s/postgres-statefulset.yaml
          sed -i "s|cloudtolocalllm/web:latest|${{ env.DOCKER_REGISTRY }}/web:${{ github.sha }}|g" k8s/web-deployment.yaml
          sed -i "s|cloudtolocalllm/api-backend:latest|${{ env.DOCKER_REGISTRY }}/api-backend:${{ github.sha }}|g" k8s/api-backend-deployment.yaml
          sed -i "s|cloudtolocalllm/streaming-proxy:latest|${{ env.DOCKER_REGISTRY }}/streaming-proxy:${{ github.sha }}|g" k8s/streaming-proxy-deployment.yaml

          # Validate manifests with server-side dry-run before applying
          echo "Validating Kubernetes manifests with server-side dry-run..."
          kubectl apply --dry-run=server -f k8s/rbac.yaml
          kubectl apply --dry-run=server -f k8s/configmap.yaml
          kubectl apply --dry-run=server -f k8s/streaming-proxy-configmap.yaml
          kubectl apply --dry-run=server -f k8s/postgres-statefulset.yaml
          kubectl apply --dry-run=server -f k8s/cloudflared.yaml
          kubectl apply --dry-run=server -f k8s/web-deployment.yaml
          kubectl apply --dry-run=server -f k8s/api-backend-deployment.yaml
          kubectl apply --dry-run=server -f k8s/streaming-proxy-deployment.yaml

          # Apply RBAC and ConfigMaps first
          kubectl apply -f k8s/rbac.yaml
          kubectl apply -f k8s/configmap.yaml
          kubectl apply -f k8s/streaming-proxy-configmap.yaml

          # Apply Infrastructure
          kubectl apply -f k8s/postgres-statefulset.yaml
          kubectl apply -f k8s/cloudflared.yaml

          # Apply Services
          kubectl apply -f k8s/web-deployment.yaml
          kubectl apply -f k8s/api-backend-deployment.yaml
          kubectl apply -f k8s/streaming-proxy-deployment.yaml

          # Force roll out restart to pick up latest images and secrets
          # Force delete postgres pod to ensure it picks up new spec (fix for stuck CrashLoopBackOff)
          # Allow this to fail if pod doesn't exist yet
          kubectl delete pod postgres-0 -n cloudtolocalllm --force --grace-period=0 2>/dev/null || true
          kubectl rollout restart statefulset/postgres -n cloudtolocalllm
          kubectl rollout restart deployment/web -n cloudtolocalllm
          kubectl rollout restart deployment/api-backend -n cloudtolocalllm
          kubectl rollout restart deployment/streaming-proxy -n cloudtolocalllm
          kubectl rollout restart deployment/cloudflared -n cloudtolocalllm

          # Wait for Rollout to Complete (with Fail Fast - all pods must succeed)
          chmod +x scripts/watch_rollout.sh
          set -e  # Exit immediately if any command fails
          
          echo "Monitoring postgres rollout..."
          ./scripts/watch_rollout.sh cloudtolocalllm statefulset postgres
          
          echo "Monitoring web rollout..."
          ./scripts/watch_rollout.sh cloudtolocalllm deployment web
          
          echo "Monitoring api-backend rollout..."
          ./scripts/watch_rollout.sh cloudtolocalllm deployment api-backend
          
          echo "Monitoring streaming-proxy rollout..."
          ./scripts/watch_rollout.sh cloudtolocalllm deployment streaming-proxy
          
          echo "âœ… All deployments rolled out successfully"

      - name: Verify Cloudflare Tunnel
        run: |
          set -e

          echo "Waiting for Cloudflare Tunnel pod to be ready..."
          kubectl wait --for=condition=ready pod -l app=cloudflared -n cloudtolocalllm --timeout=300s

          echo "Checking Tunnel Logs for successful registration..."
          start_ts=$(date +%s)
          # Retry checking logs for connection success message (24 attempts = ~2 minutes)
          for i in {1..24}; do
            if kubectl logs -l app=cloudflared -n cloudtolocalllm | grep -q "Registered tunnel connection"; then
              elapsed=$(( $(date +%s) - start_ts ))
              echo "Tunnel connection verified after ${elapsed}s."
              exit 0
            fi
            echo "Attempt $i/24: Tunnel not yet registered, waiting 5s..."
            sleep 5
          done

          echo "Tunnel verification failed after 24 attempts (~2 minutes). Collecting diagnostics..."
          echo "--- cloudflared pods ---"
          kubectl get pods -l app=cloudflared -n cloudtolocalllm -o wide || true
          echo "--- recent cloudflared logs ---"
          kubectl logs -l app=cloudflared -n cloudtolocalllm --tail=200 || true
          echo "--- describe cloudflared pods ---"
          kubectl describe pod -l app=cloudflared -n cloudtolocalllm || true
          exit 1

      - name: Update Cloudflare DNS
        env:
          CLOUDFLARE_DNS_TOKEN: ${{ secrets.CLOUDFLARE_DNS_TOKEN }}
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
        run: |
          set -x
          # --- Update Cloudflare DNS Records ---
          ZONE_NAME="cloudtolocalllm.online"
          TUNNEL_ID="62da6c19-947b-4bf6-acad-100a73de4e0d"
          TUNNEL_CNAME="$TUNNEL_ID.cfargotunnel.com"
          TUNNEL_TOKEN="${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}"

          if [ -z "$TUNNEL_TOKEN" ]; then
            echo "Error: CLOUDFLARE_TUNNEL_TOKEN secret is empty"
            exit 1
          fi

          echo "Fetching Zone ID for $ZONE_NAME..."
          ZONE_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$ZONE_NAME" \
            -H "Authorization: Bearer $CLOUDFLARE_DNS_TOKEN" \
            -H "Content-Type: application/json" | jq -r '.result[0].id')
          
          if [ "$ZONE_ID" == "null" ] || [ -z "$ZONE_ID" ]; then
            echo "Error: Could not find Zone ID for $ZONE_NAME"
            exit 1
          fi

          # Function to update or create CNAME record
          update_dns_record() {
            local NAME=$1
            local CONTENT=$2
            local PROXIED=$3
            local FQDN

            if [ "$NAME" = "@" ]; then
              FQDN="$ZONE_NAME"
            else
              FQDN="$NAME.$ZONE_NAME"
            fi

            local RECORD_JSON=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?type=CNAME&name=$FQDN" \
              -H "Authorization: Bearer $CLOUDFLARE_DNS_TOKEN" \
              -H "Content-Type: application/json")

            local RECORD_ID=$(echo "$RECORD_JSON" | jq -r '.result[0].id')
            local CURRENT_CONTENT=$(echo "$RECORD_JSON" | jq -r '.result[0].content')

            if [ "$CURRENT_CONTENT" = "$CONTENT" ]; then
              echo "DNS record $FQDN already points to $CONTENT; no update required."
              return 0
            fi

            echo "Updating DNS record: $FQDN -> $CONTENT (Proxied: $PROXIED)"

            if [ "$RECORD_ID" != "null" ] && [ -n "$RECORD_ID" ]; then
              curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$RECORD_ID" \
                -H "Authorization: Bearer $CLOUDFLARE_DNS_TOKEN" \
                -H "Content-Type: application/json" \
                --data "{\"type\":\"CNAME\",\"name\":\"$FQDN\",\"content\":\"$CONTENT\",\"proxied\":$PROXIED,\"ttl\":1}" >/dev/null
            else
              curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records" \
                -H "Authorization: Bearer $CLOUDFLARE_DNS_TOKEN" \
                -H "Content-Type: application/json" \
                --data "{\"type\":\"CNAME\",\"name\":\"$FQDN\",\"content\":\"$CONTENT\",\"proxied\":$PROXIED,\"ttl\":1}" >/dev/null
            fi
          }

          # Update Records
          update_dns_record "app" "$TUNNEL_CNAME" true
          update_dns_record "api" "$TUNNEL_CNAME" true
          update_dns_record "@" "$TUNNEL_CNAME" true

      - name: Check Health Endpoint
        run: |
          set -e

          echo "Waiting for DNS propagation and service health..."
          start_ts=$(date +%s)

          # Retry loop for 2 minutes
          for i in {1..24}; do
            http_status=$(curl -s -o /dev/null -w "%{http_code}" https://app.cloudtolocalllm.online/health || echo "000")
            if [ "$http_status" = "200" ]; then
              elapsed=$(( $(date +%s) - start_ts ))
              echo "Health check passed with HTTP 200 after ${elapsed}s!"
              exit 0
            fi

            echo "Attempt $i/24: Health check returned HTTP $http_status, waiting 5s..."
            sleep 5
          done

          echo "Health check failed after 24 attempts (~2 minutes). Collecting diagnostics..."
          kubectl get pods -n cloudtolocalllm || true
          echo "--- postgres logs (tail 50) ---"
          kubectl logs postgres-0 -n cloudtolocalllm --tail=50 || true
          kubectl describe pod postgres-0 -n cloudtolocalllm || true
          echo "--- api-backend logs (tail 100) ---"
          kubectl logs -l app=api-backend -n cloudtolocalllm --tail=100 || true
          kubectl describe pod -l app=api-backend -n cloudtolocalllm || true
          exit 1

      - name: Deployment Summary
        if: success()
        run: |
          echo "Deployment to Azure AKS completed successfully."
          echo "Cluster: ${{ env.AZURE_CLUSTER_NAME }} (resource group: ${{ env.AZURE_RESOURCE_GROUP }})"
          echo "Namespace: cloudtolocalllm"
          echo "Images pulled from registry: ${{ env.DOCKER_REGISTRY }}"
          echo "Public endpoints:"
          echo "  - App:  https://app.cloudtolocalllm.online/"
          echo "  - API:  https://api.cloudtolocalllm.online/"
