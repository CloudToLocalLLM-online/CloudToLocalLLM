name: Deploy to Azure AKS

on:
  push:
    branches:
      - main
    paths:
      - "k8s/**"
      - ".github/workflows/deploy-aks.yml"
      - "services/**"
      - "web/**"
      - "config/docker/**"
      - "scripts/**"
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AZURE_RESOURCE_GROUP: cloudtolocalllm-rg
  AZURE_CLUSTER_NAME: cloudtolocalllm-aks
  ACR_NAME: cloudtolocalllm
  # DOCKER_REGISTRY will be set dynamically to the ACR login server

jobs:
  # Job to detect changes in specific paths
  changes:
    runs-on: ubuntu-latest
    outputs:
      base: ${{ steps.filter.outputs.base }}
      postgres: ${{ steps.filter.outputs.postgres }}
      web: ${{ steps.filter.outputs.web }}
      api: ${{ steps.filter.outputs.api }}
      proxy: ${{ steps.filter.outputs.proxy }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            base:
              - 'config/docker/Dockerfile.base'
              - '.github/workflows/deploy-aks.yml'
            postgres:
              - 'config/docker/Dockerfile.postgres'
              - 'config/docker/postgres-init.sh'
              - '.github/workflows/deploy-aks.yml'
            web:
              - 'web/**'
              - 'config/docker/Dockerfile.base'
              - '.github/workflows/deploy-aks.yml'
            api:
              - 'services/api-backend/**'
              - 'config/docker/Dockerfile.base'
              - '.github/workflows/deploy-aks.yml'
            proxy:
              - 'services/streaming-proxy/**'
              - 'config/docker/Dockerfile.base'
              - '.github/workflows/deploy-aks.yml'

  build_base:
    needs: changes
    if: ${{ !cancelled() && needs.changes.outputs.base == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: Setup ACR
        run: |
          # Create ACR if not exists
          az acr create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.ACR_NAME }} --sku Basic --admin-enabled true
          # Get Login Server
          echo "DOCKER_REGISTRY=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_ENV
      - name: Docker Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.AZURE_CLIENT_ID }}
          password: ${{ secrets.AZURE_CLIENT_SECRET }}
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: config/docker/Dockerfile.base
          push: true
          tags: ${{ env.DOCKER_REGISTRY }}/base:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/base:latest
          cache-to: type=inline

  build_postgres:
    needs: [changes, build_base]
    if: ${{ !cancelled() && (needs.changes.outputs.postgres == 'true' || needs.changes.outputs.base == 'true') && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: Get ACR Login Server
        run: echo "DOCKER_REGISTRY=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_ENV
      - name: Docker Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.AZURE_CLIENT_ID }}
          password: ${{ secrets.AZURE_CLIENT_SECRET }}
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: config/docker/Dockerfile.postgres
          push: true
          tags: ${{ env.DOCKER_REGISTRY }}/postgres:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/postgres:latest
          cache-to: type=inline

  build_web:
    needs: [changes, build_base]
    if: ${{ !cancelled() && (needs.changes.outputs.web == 'true' || needs.changes.outputs.base == 'true') && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: Get ACR Login Server
        run: echo "DOCKER_REGISTRY=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_ENV
      - name: Docker Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.AZURE_CLIENT_ID }}
          password: ${{ secrets.AZURE_CLIENT_SECRET }}
      - uses: docker/setup-buildx-action@v3
      - uses: subosito/flutter-action@v2
        with:
          channel: "stable"
          cache: true
      - run: flutter pub get && flutter build web --release --no-tree-shake-icons
      - name: Debug - List web build
        run: ls -R build/web || echo "build/web not found"
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: web/Dockerfile
          push: true
          tags: ${{ env.DOCKER_REGISTRY }}/web:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/web:latest
          cache-to: type=inline

  build_api:
    needs: [changes, build_base]
    if: ${{ !cancelled() && (needs.changes.outputs.api == 'true' || needs.changes.outputs.base == 'true') && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: Get ACR Login Server
        run: echo "DOCKER_REGISTRY=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_ENV
      - name: Docker Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.AZURE_CLIENT_ID }}
          password: ${{ secrets.AZURE_CLIENT_SECRET }}
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: services/api-backend
          file: services/api-backend/Dockerfile
          push: true
          tags: ${{ env.DOCKER_REGISTRY }}/api-backend:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/api-backend:latest
          cache-to: type=inline

  build_proxy:
    needs: [changes, build_base]
    if: ${{ !cancelled() && (needs.changes.outputs.proxy == 'true' || needs.changes.outputs.base == 'true') && (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: Get ACR Login Server
        run: echo "DOCKER_REGISTRY=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_ENV
      - name: Docker Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.AZURE_CLIENT_ID }}
          password: ${{ secrets.AZURE_CLIENT_SECRET }}
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v5
        with:
          context: services/streaming-proxy
          file: services/streaming-proxy/Dockerfile
          push: true
          tags: ${{ env.DOCKER_REGISTRY }}/streaming-proxy:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/streaming-proxy:latest
          cache-to: type=inline

  deploy_infrastructure:
    # Run if any build job ran OR if k8s files changed
    needs:
      [changes, build_base, build_postgres, build_web, build_api, build_proxy]
    if: |
      !cancelled() && 
      (needs.build_base.result == 'success' || needs.build_base.result == 'skipped') &&
      (needs.build_postgres.result == 'success' || needs.build_postgres.result == 'skipped') &&
      (needs.build_web.result == 'success' || needs.build_web.result == 'skipped') &&
      (needs.build_api.result == 'success' || needs.build_api.result == 'skipped') &&
      (needs.build_proxy.result == 'success' || needs.build_proxy.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.AZURE_RESOURCE_GROUP }}
          cluster-name: ${{ env.AZURE_CLUSTER_NAME }}

      - name: Setup ACR Integration
        run: |
          # Get Login Server (ACR assumed to exist or created in build steps)
          echo "DOCKER_REGISTRY=$(az acr show --name ${{ env.ACR_NAME }} --query loginServer --output tsv)" >> $GITHUB_ENV

      - name: Ensure Namespace Exists
        run: |
          kubectl create namespace cloudtolocalllm --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          AUTH0_CLIENT_SECRET: ${{ secrets.AUTH0_CLIENT_SECRET }}
          STRIPE_TEST_SECRET_KEY: ${{ secrets.STRIPE_TEST_SECRET_KEY }}
          STRIPE_TEST_PUBLISHABLE_KEY: ${{ secrets.STRIPE_TEST_PUBLISHABLE_KEY }}
          STRIPE_TEST_WEBHOOK_SECRET: ${{ secrets.STRIPE_TEST_WEBHOOK_SECRET }}
          STRIPE_LIVE_SECRET_KEY: ${{ secrets.STRIPE_LIVE_SECRET_KEY }}
          STRIPE_LIVE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_LIVE_PUBLISHABLE_KEY }}
          STRIPE_LIVE_WEBHOOK_SECRET: ${{ secrets.STRIPE_LIVE_WEBHOOK_SECRET }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
          CLOUDFLARE_DNS_TOKEN: ${{ secrets.CLOUDFLARE_DNS_TOKEN }}
          CLOUDFLARE_TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          set -x
          # --- Update Cloudflare DNS Records ---
          ZONE_NAME="cloudtolocalllm.online"
          TUNNEL_ID="ee26f195-904b-4406-a8ae-9265c9971004"
          TUNNEL_CNAME="$TUNNEL_ID.cfargotunnel.com"

          echo "Fetching Zone ID for $ZONE_NAME..."
          ZONE_ID=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$ZONE_NAME" \
            -H "Authorization: Bearer $CLOUDFLARE_DNS_TOKEN" \
            -H "Content-Type: application/json" | jq -r '.result[0].id')

          if [ "$ZONE_ID" == "null" ] || [ -z "$ZONE_ID" ]; then
            echo "Error: Could not find Zone ID for $ZONE_NAME"
            exit 1
          fi

          # Function to update or create CNAME record
          update_dns_record() {
            local NAME=$1
            local CONTENT=$2
            local PROXIED=$3
            
            echo "Updating DNS record: $NAME -> $CONTENT (Proxied: $PROXIED)"
            
            # Check if record exists
            local RECORD_JSON=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?type=CNAME&name=$NAME" \
              -H "Authorization: Bearer $CLOUDFLARE_DNS_TOKEN" \
              -H "Content-Type: application/json")
            
            local RECORD_ID=$(echo "$RECORD_JSON" | jq -r '.result[0].id')
            
            if [ "$RECORD_ID" != "null" ] && [ -n "$RECORD_ID" ]; then
               # Update existing
               curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$RECORD_ID" \
                 -H "Authorization: Bearer $CLOUDFLARE_DNS_TOKEN" \
                 -H "Content-Type: application/json" \
                 --data "{\"type\":\"CNAME\",\"name\":\"$NAME\",\"content\":\"$CONTENT\",\"proxied\":$PROXIED,\"ttl\":1}" > /dev/null
            else
               # Create new
               curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records" \
                 -H "Authorization: Bearer $CLOUDFLARE_DNS_TOKEN" \
                 -H "Content-Type: application/json" \
                 --data "{\"type\":\"CNAME\",\"name\":\"$NAME\",\"content\":\"$CONTENT\",\"proxied\":$PROXIED,\"ttl\":1}" > /dev/null
            fi
          }

          # --- Create Kubernetes Secrets ---

          # Get ACR Admin Credentials
          ACR_ADMIN_USER=$(az acr credential show --name ${{ env.ACR_NAME }} --query username --output tsv)
          ACR_ADMIN_PASS=$(az acr credential show --name ${{ env.ACR_NAME }} --query passwords[0].value --output tsv)

          # Docker Registry Secret for ACR
          kubectl create secret docker-registry regcred \
            --docker-server=${{ env.DOCKER_REGISTRY }} \
            --docker-username=$ACR_ADMIN_USER \
            --docker-password=$ACR_ADMIN_PASS \
            --docker-email=github-actions@cloudtolocalllm.online \
            -n cloudtolocalllm --dry-run=client -o yaml | kubectl apply -f -

          # App Secrets
          kubectl create secret generic cloudtolocalllm-secrets \
            --namespace cloudtolocalllm \
            --from-literal=postgres-user=cloud_admin \
            --from-literal=postgres-password="$POSTGRES_PASSWORD" \
            --from-literal=jwt-secret="$JWT_SECRET" \
            --from-literal=auth0-domain='dev-v2f2p008x3dr74ww.us.auth0.com' \
            --from-literal=auth0-audience='https://api.cloudtolocalllm.online' \
            --from-literal=auth0-client-id='FuXPnevXpp311CdYHGsbNZe9t3D8Ts7A' \
            --from-literal=auth0-client-secret="$AUTH0_CLIENT_SECRET" \
            --from-literal=stripe-test-secret-key="$STRIPE_TEST_SECRET_KEY" \
            --from-literal=stripe-test-publishable-key="$STRIPE_TEST_PUBLISHABLE_KEY" \
            --from-literal=stripe-test-webhook-secret="$STRIPE_TEST_WEBHOOK_SECRET" \
            --from-literal=stripe-live-secret-key="$STRIPE_LIVE_SECRET_KEY" \
            --from-literal=stripe-live-publishable-key="$STRIPE_LIVE_PUBLISHABLE_KEY" \
            --from-literal=stripe-live-webhook-secret="$STRIPE_LIVE_WEBHOOK_SECRET" \
            --from-literal=sentry-dsn="$SENTRY_DSN" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Cloudflare Tunnel Secret
          kubectl create secret generic tunnel-credentials \
            --namespace cloudtolocalllm \
            --from-literal=token="$TUNNEL_TOKEN" \
            --dry-run=client -o yaml | kubectl apply -f -

          # Streaming Proxy Secret
          kubectl create secret generic streaming-proxy-secrets \
            --namespace cloudtolocalllm \
            --from-literal=SENTRY_DSN="$SENTRY_DSN" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Manifests
        run: |
          # Replace image registry in manifests
          sed -i "s|cloudtolocalllm/postgres:latest|${{ env.DOCKER_REGISTRY }}/postgres:latest|g" k8s/postgres-statefulset.yaml
          sed -i "s|cloudtolocalllm/web:latest|${{ env.DOCKER_REGISTRY }}/web:latest|g" k8s/web-deployment.yaml
          sed -i "s|cloudtolocalllm/api-backend:latest|${{ env.DOCKER_REGISTRY }}/api-backend:latest|g" k8s/api-backend-deployment.yaml
          sed -i "s|cloudtolocalllm/streaming-proxy:latest|${{ env.DOCKER_REGISTRY }}/streaming-proxy:latest|g" k8s/streaming-proxy-deployment.yaml

          # Apply RBAC and ConfigMaps first
          kubectl apply -f k8s/rbac.yaml
          kubectl apply -f k8s/configmap.yaml
          kubectl apply -f k8s/streaming-proxy-configmap.yaml

          # Apply Infrastructure
          kubectl apply -f k8s/postgres-statefulset.yaml
          kubectl apply -f k8s/cloudflared.yaml

          # Apply Services
          kubectl apply -f k8s/web-deployment.yaml
          kubectl apply -f k8s/api-backend-deployment.yaml
          kubectl apply -f k8s/streaming-proxy-deployment.yaml

          # Force Rollout Restart to pick up new images
          kubectl rollout restart statefulset/postgres deployment/web deployment/api-backend deployment/streaming-proxy -n cloudtolocalllm

          # Wait for Rollout to Complete
          kubectl rollout status statefulset/postgres -n cloudtolocalllm --timeout=300s
          kubectl rollout status deployment/web -n cloudtolocalllm --timeout=300s
          kubectl rollout status deployment/api-backend -n cloudtolocalllm --timeout=300s
          kubectl rollout status deployment/streaming-proxy -n cloudtolocalllm --timeout=300s

  validation:
    name: Validate Deployment
    needs: deploy_infrastructure
    if: ${{ !cancelled() && (needs.deploy_infrastructure.result == 'success' || needs.deploy_infrastructure.result == 'skipped') }}
    runs-on: ubuntu-latest
    steps:
      - name: Check Health Endpoint
        run: |
          echo "Waiting for DNS propagation and service health..."
          # Retry loop for 2 minutes
          for i in {1..24}; do
            if curl -s -f https://app.cloudtolocalllm.online/health; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Attempt $i: Health check failed, waiting 5s..."
            sleep 5
          done
          echo "Health check failed after 2 minutes."
          exit 1
