name: Deploy to Azure AKS

on:
  push:
    branches:
      - main
    paths:
      - "k8s/**"
      - ".github/workflows/deploy-aks.yml"
      - "services/**"
      - "web/**"
      - "config/docker/**"
      - "scripts/**"

env:
  AZURE_RESOURCE_GROUP: cloudtolocalllm-rg
  AZURE_CLUSTER_NAME: cloudtolocalllm-aks
  DOCKER_REGISTRY: cloudtolocalllm

jobs:
  build_images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 1. Build Base Image
      - name: Build and push Base Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: config/docker/Dockerfile.base
          push: true
          tags: ${{ env.DOCKER_REGISTRY }}/base:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/base:latest
          cache-to: type=inline

      # 2. Build Postgres Image
      - name: Build and push Postgres Image
        uses: docker/build-push-action@v5
        with:
          context: config/docker
          file: config/docker/Dockerfile.postgres
          push: true
          tags: ${{ env.DOCKER_REGISTRY }}/postgres:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/postgres:latest
          cache-to: type=inline

      # 3. Build Flutter Web Artifacts
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: "stable"
          cache: true

      - name: Install Flutter Dependencies
        working-directory: ./web
        run: flutter pub get

      - name: Build Flutter Web
        working-directory: ./web
        run: flutter build web --release --no-tree-shake-icons

      # 4. Build Web Image (using built artifacts)
      - name: Build and push Web Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: web/Dockerfile
          push: true
          tags: ${{ env.DOCKER_REGISTRY }}/web:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/web:latest
          cache-to: type=inline

      # 5. Build API Image
      - name: Build and push API Image
        uses: docker/build-push-action@v5
        with:
          context: services/api-backend
          file: services/api-backend/Dockerfile
          push: true
          tags: ${{ env.DOCKER_REGISTRY }}/api-backend:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/api-backend:latest
          cache-to: type=inline

      # 6. Build Streaming Proxy Image
      - name: Build and push Streaming Proxy Image
        uses: docker/build-push-action@v5
        with:
          context: services/streaming-proxy
          file: services/streaming-proxy/Dockerfile
          push: true
          tags: ${{ env.DOCKER_REGISTRY }}/streaming-proxy:latest
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/streaming-proxy:latest
          cache-to: type=inline

  deploy_infrastructure:
    name: Deploy Infrastructure
    needs: build_images
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ env.AZURE_RESOURCE_GROUP }}
          cluster-name: ${{ env.AZURE_CLUSTER_NAME }}

      - name: Ensure Namespace Exists
        run: |
          kubectl create namespace cloudtolocalllm --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update Secrets
        run: |
          # Create secrets idempotently
          kubectl create secret generic cloudtolocalllm-secrets \
            --namespace cloudtolocalllm \
            --from-literal=POSTGRES_PASSWORD='${{ secrets.POSTGRES_PASSWORD }}' \
            --from-literal=POSTGRES_APP_PASSWORD='${{ secrets.POSTGRES_APP_PASSWORD }}' \
            --from-literal=AUTH0_DOMAIN='${{ secrets.AUTH0_DOMAIN }}' \
            --from-literal=AUTH0_CLIENT_ID='${{ secrets.AUTH0_CLIENT_ID }}' \
            --from-literal=AUTH0_CLIENT_SECRET='${{ secrets.AUTH0_CLIENT_SECRET }}' \
            --from-literal=STRIPE_SECRET_KEY='${{ secrets.STRIPE_SECRET_KEY }}' \
            --from-literal=STRIPE_WEBHOOK_SECRET='${{ secrets.STRIPE_WEBHOOK_SECRET }}' \
            --from-literal=SENTRY_DSN='${{ secrets.SENTRY_DSN }}' \
            --dry-run=client -o yaml | kubectl apply -f -

          # Create Tunnel Credentials Secret
          kubectl create secret generic tunnel-credentials \
            --namespace cloudtolocalllm \
            --from-literal=Tunnel-Token='${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}' \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Manifests
        run: |
          # Apply Infrastructure
          kubectl apply -f k8s/postgres-statefulset.yaml
          kubectl apply -f k8s/cloudflared.yaml

          # Apply Services
          kubectl apply -f k8s/web-deployment.yaml
          kubectl apply -f k8s/api-backend-deployment.yaml
          kubectl apply -f k8s/streaming-proxy-deployment.yaml

          # Force Rollout Restart to pick up new images
          kubectl rollout restart statefulset/postgres deployment/web deployment/api-backend deployment/streaming-proxy -n cloudtolocalllm

  validation:
    name: Validate Deployment
    needs: deploy_infrastructure
    runs-on: ubuntu-latest
    steps:
      - name: Check Health Endpoint
        run: |
          echo "Waiting for DNS propagation and service health..."
          # Add actual health check logic here if needed, e.g., curl with retry
